Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    NOT
    COLON
    NEWLINE
    FOR
    LQUOTE
    RQUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMI program1
Rule 2     program -> PROGRAM ID SEMI var program1
Rule 3     program1 -> function program1
Rule 4     program1 -> function
Rule 5     function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block
Rule 6     function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block
Rule 7     savefunc -> empty
Rule 8     parameter -> type ID pushid
Rule 9     parameter -> type ID pushid COMMA parameter
Rule 10    block -> LBRACE statements RETURN expression SEMI savereturn RBRACE
Rule 11    block -> LBRACE RETURN expression SEMI savereturn RBRACE
Rule 12    block -> LBRACE statements nortn RBRACE
Rule 13    block -> LBRACE nortn RBRACE
Rule 14    blocknortn -> LBRACE statements RBRACE
Rule 15    blocknortn -> LBRACE RBRACE
Rule 16    nortn -> empty
Rule 17    savereturn -> empty
Rule 18    statements -> statement
Rule 19    statements -> statement statements
Rule 20    statement -> condition
Rule 21    statement -> assignment
Rule 22    statement -> while
Rule 23    statement -> for
Rule 24    statement -> dowhile
Rule 25    statement -> comment
Rule 26    statement -> print
Rule 27    statement -> var
Rule 28    statement -> funcall
Rule 29    print -> PRINT LPAREN expression RPAREN SEMI
Rule 30    print -> PRINT LPAREN STRING_CONS RPAREN SEMI
Rule 31    print -> PRINT LPAREN ID RPAREN SEMI
Rule 32    funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI
Rule 33    funcall -> ID pushid RPAREN LPAREN assignvalues SEMI
Rule 34    startcount -> empty
Rule 35    exparam -> COMMA expression exparam
Rule 36    exparam -> COMMA expression
Rule 37    assignvalues -> empty
Rule 38    comment -> COMMENT ID
Rule 39    for -> LPAREN assignment expression SEMI expression RPAREN blocknortn
Rule 40    dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot
Rule 41    pushjump -> empty
Rule 42    gotot -> empty
Rule 43    while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile
Rule 44    gotowhile -> empty
Rule 45    condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
Rule 46    condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump
Rule 47    gotoif -> empty
Rule 48    gotof -> empty
Rule 49    updatejump -> empty
Rule 50    var -> VAR type var1 SEMI
Rule 51    var1 -> ID pushid savevar allocatevar
Rule 52    var1 -> ID pushid savevar allocatevar COMMA var1
Rule 53    var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
Rule 54    var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
Rule 55    settypeint -> empty
Rule 56    settypedec -> empty
Rule 57    settypefrac -> empty
Rule 58    settypestring -> empty
Rule 59    settypebool -> empty
Rule 60    settypevoid -> empty
Rule 61    savevar -> empty
Rule 62    allocatevar -> empty
Rule 63    updatesize -> empty
Rule 64    type -> BOOLEAN settypebool
Rule 65    type -> INTEGER settypeint
Rule 66    type -> DECIMAL settypedec
Rule 67    type -> STRING settypestring
Rule 68    type -> FRACTION settypefrac
Rule 69    type -> VOID settypevoid
Rule 70    assignment -> ID pushid EQUALS expression SEMI updatevar
Rule 71    assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
Rule 72    updatecell -> empty
Rule 73    updatevar -> empty
Rule 74    expression -> exp
Rule 75    exp -> exp OR exp
Rule 76    exp -> exp AND exp
Rule 77    exp -> exp SAME exp
Rule 78    exp -> exp DIF exp
Rule 79    exp -> exp GE exp
Rule 80    exp -> exp LE exp
Rule 81    exp -> exp NE exp
Rule 82    exp -> exp GT exp
Rule 83    exp -> exp LT exp
Rule 84    exp -> exp PLUS exp
Rule 85    exp -> exp MINUS exp
Rule 86    exp -> exp MODULO exp
Rule 87    exp -> exp DIVIDE exp
Rule 88    exp -> exp TIMES exp
Rule 89    exp -> exp POWER exp
Rule 90    exp -> ID pushdeclaredid
Rule 91    exp -> ID LBRACK expression RBRACK pushdeclaredid
Rule 92    exp -> LBRACK exp RBRACK
Rule 93    exp -> INTEGER_CONS settypeint pushcons
Rule 94    exp -> STRING_CONS settypestring pushcons
Rule 95    exp -> FRACTION_CONS settypefrac pushcons
Rule 96    exp -> DECIMAL_CONS settypedec pushcons
Rule 97    exp -> TRUE settypebool pushcons
Rule 98    exp -> FALSE settypebool pushcons
Rule 99    exp -> EXMARK exp
Rule 100   exp -> LPAREN exp RPAREN
Rule 101   pushtype -> empty
Rule 102   pushid -> pushtype
Rule 103   pushdeclaredid -> pushtype
Rule 104   pushcons -> pushtype
Rule 105   empty -> <empty>

Terminals, with rules where they appear

AND                  : 76
BOOLEAN              : 64
COLON                : 
COMMA                : 9 35 36 52 53
COMMENT              : 38
DECIMAL              : 66
DECIMAL_CONS         : 96
DIF                  : 78
DIVIDE               : 87
DO                   : 40
ELSE                 : 45
EQUALS               : 70 71
EXMARK               : 99
FALSE                : 98
FOR                  : 
FRACTION             : 68
FRACTION_CONS        : 95
FUNCTION             : 5 6
GE                   : 79
GT                   : 82
ID                   : 1 2 5 6 8 9 31 32 33 38 51 52 53 54 70 71 90 91
IF                   : 45 46
INTEGER              : 65
INTEGER_CONS         : 53 54 93
LBRACE               : 10 11 12 13 14 15
LBRACK               : 53 54 71 91 92
LE                   : 80
LPAREN               : 5 6 29 30 31 32 33 39 40 43 45 46 100
LQUOTE               : 
LT                   : 83
MINUS                : 85
MODULO               : 86
NE                   : 81
NEWLINE              : 
NOT                  : 
OR                   : 75
PLUS                 : 84
POWER                : 89
PRINT                : 29 30 31
PROGRAM              : 1 2
RBRACE               : 10 11 12 13 14 15
RBRACK               : 53 54 71 91 92
RETURN               : 10 11
RPAREN               : 5 6 29 30 31 32 33 39 40 43 45 46 100
RQUOTE               : 
SAME                 : 77
SEMI                 : 1 2 10 11 29 30 31 32 33 39 50 70 71
STRING               : 67
STRING_CONS          : 30 94
TIMES                : 88
TRUE                 : 97
VAR                  : 50
VOID                 : 69
WHILE                : 40 43
error                : 

Nonterminals, with rules where they appear

allocatevar          : 51 52 53 54
assignment           : 21 39
assignvalues         : 32 33
block                : 5 6
blocknortn           : 39 40 43 45 45 46
comment              : 25
condition            : 20
dowhile              : 24
empty                : 7 16 17 34 37 41 42 44 47 48 49 55 56 57 58 59 60 61 62 63 72 73 101
exp                  : 74 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 92 99 100
exparam              : 32 35
expression           : 10 11 29 32 35 36 39 39 40 43 45 46 70 71 71 91
for                  : 23
funcall              : 28
function             : 3 4
gotof                : 43 45 46
gotoif               : 45
gotot                : 40
gotowhile            : 43
nortn                : 12 13
parameter            : 5 9
print                : 26
program              : 0
program1             : 1 2 3
pushcons             : 93 94 95 96 97 98
pushdeclaredid       : 90 91
pushid               : 5 6 8 9 32 33 51 52 53 54 70 71
pushjump             : 40 43
pushtype             : 102 103 104
savefunc             : 5 6
savereturn           : 10 11
savevar              : 51 52 53 54
settypebool          : 64 97 98
settypedec           : 66 96
settypefrac          : 68 95
settypeint           : 65 93
settypestring        : 67 94
settypevoid          : 69
startcount           : 32
statement            : 18 19
statements           : 10 12 14 19
type                 : 5 6 8 9 50
updatecell           : 71
updatejump           : 45 46
updatesize           : 53 54
updatevar            : 70
var                  : 2 27
var1                 : 50 52 53
while                : 22

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMI program1
    (2) program -> . PROGRAM ID SEMI var program1

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . ID SEMI program1
    (2) program -> PROGRAM . ID SEMI var program1

    ID              shift and go to state 3


state 2

    (0) S' -> program .



state 3

    (1) program -> PROGRAM ID . SEMI program1
    (2) program -> PROGRAM ID . SEMI var program1

    SEMI            shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMI . program1
    (2) program -> PROGRAM ID SEMI . var program1
    (3) program1 -> . function program1
    (4) program1 -> . function
    (50) var -> . VAR type var1 SEMI
    (5) function -> . type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block
    (6) function -> . type FUNCTION ID pushid LPAREN RPAREN savefunc block
    (64) type -> . BOOLEAN settypebool
    (65) type -> . INTEGER settypeint
    (66) type -> . DECIMAL settypedec
    (67) type -> . STRING settypestring
    (68) type -> . FRACTION settypefrac
    (69) type -> . VOID settypevoid

    VAR             shift and go to state 14
    BOOLEAN         shift and go to state 10
    INTEGER         shift and go to state 8
    DECIMAL         shift and go to state 5
    STRING          shift and go to state 9
    FRACTION        shift and go to state 6
    VOID            shift and go to state 12

    program1                       shift and go to state 13
    type                           shift and go to state 11
    function                       shift and go to state 7
    var                            shift and go to state 15

state 5

    (66) type -> DECIMAL . settypedec
    (56) settypedec -> . empty
    (105) empty -> .

    FUNCTION        reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    empty                          shift and go to state 16
    settypedec                     shift and go to state 17

state 6

    (68) type -> FRACTION . settypefrac
    (57) settypefrac -> . empty
    (105) empty -> .

    FUNCTION        reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    settypefrac                    shift and go to state 18
    empty                          shift and go to state 19

state 7

    (3) program1 -> function . program1
    (4) program1 -> function .
    (3) program1 -> . function program1
    (4) program1 -> . function
    (5) function -> . type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block
    (6) function -> . type FUNCTION ID pushid LPAREN RPAREN savefunc block
    (64) type -> . BOOLEAN settypebool
    (65) type -> . INTEGER settypeint
    (66) type -> . DECIMAL settypedec
    (67) type -> . STRING settypestring
    (68) type -> . FRACTION settypefrac
    (69) type -> . VOID settypevoid

    $end            reduce using rule 4 (program1 -> function .)
    BOOLEAN         shift and go to state 10
    INTEGER         shift and go to state 8
    DECIMAL         shift and go to state 5
    STRING          shift and go to state 9
    FRACTION        shift and go to state 6
    VOID            shift and go to state 12

    program1                       shift and go to state 20
    type                           shift and go to state 11
    function                       shift and go to state 7

state 8

    (65) type -> INTEGER . settypeint
    (55) settypeint -> . empty
    (105) empty -> .

    FUNCTION        reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    settypeint                     shift and go to state 21
    empty                          shift and go to state 22

state 9

    (67) type -> STRING . settypestring
    (58) settypestring -> . empty
    (105) empty -> .

    FUNCTION        reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    settypestring                  shift and go to state 23
    empty                          shift and go to state 24

state 10

    (64) type -> BOOLEAN . settypebool
    (59) settypebool -> . empty
    (105) empty -> .

    FUNCTION        reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    empty                          shift and go to state 25
    settypebool                    shift and go to state 26

state 11

    (5) function -> type . FUNCTION ID pushid LPAREN parameter RPAREN savefunc block
    (6) function -> type . FUNCTION ID pushid LPAREN RPAREN savefunc block

    FUNCTION        shift and go to state 27


state 12

    (69) type -> VOID . settypevoid
    (60) settypevoid -> . empty
    (105) empty -> .

    FUNCTION        reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    settypevoid                    shift and go to state 28
    empty                          shift and go to state 29

state 13

    (1) program -> PROGRAM ID SEMI program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMI program1 .)


state 14

    (50) var -> VAR . type var1 SEMI
    (64) type -> . BOOLEAN settypebool
    (65) type -> . INTEGER settypeint
    (66) type -> . DECIMAL settypedec
    (67) type -> . STRING settypestring
    (68) type -> . FRACTION settypefrac
    (69) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 10
    INTEGER         shift and go to state 8
    DECIMAL         shift and go to state 5
    STRING          shift and go to state 9
    FRACTION        shift and go to state 6
    VOID            shift and go to state 12

    type                           shift and go to state 30

state 15

    (2) program -> PROGRAM ID SEMI var . program1
    (3) program1 -> . function program1
    (4) program1 -> . function
    (5) function -> . type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block
    (6) function -> . type FUNCTION ID pushid LPAREN RPAREN savefunc block
    (64) type -> . BOOLEAN settypebool
    (65) type -> . INTEGER settypeint
    (66) type -> . DECIMAL settypedec
    (67) type -> . STRING settypestring
    (68) type -> . FRACTION settypefrac
    (69) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 10
    INTEGER         shift and go to state 8
    DECIMAL         shift and go to state 5
    STRING          shift and go to state 9
    FRACTION        shift and go to state 6
    VOID            shift and go to state 12

    program1                       shift and go to state 31
    type                           shift and go to state 11
    function                       shift and go to state 7

state 16

    (56) settypedec -> empty .

    OR              reduce using rule 56 (settypedec -> empty .)
    AND             reduce using rule 56 (settypedec -> empty .)
    SAME            reduce using rule 56 (settypedec -> empty .)
    DIF             reduce using rule 56 (settypedec -> empty .)
    GE              reduce using rule 56 (settypedec -> empty .)
    LE              reduce using rule 56 (settypedec -> empty .)
    NE              reduce using rule 56 (settypedec -> empty .)
    GT              reduce using rule 56 (settypedec -> empty .)
    LT              reduce using rule 56 (settypedec -> empty .)
    PLUS            reduce using rule 56 (settypedec -> empty .)
    MINUS           reduce using rule 56 (settypedec -> empty .)
    MODULO          reduce using rule 56 (settypedec -> empty .)
    DIVIDE          reduce using rule 56 (settypedec -> empty .)
    TIMES           reduce using rule 56 (settypedec -> empty .)
    POWER           reduce using rule 56 (settypedec -> empty .)
    SEMI            reduce using rule 56 (settypedec -> empty .)
    RPAREN          reduce using rule 56 (settypedec -> empty .)
    RBRACK          reduce using rule 56 (settypedec -> empty .)
    COMMA           reduce using rule 56 (settypedec -> empty .)
    FUNCTION        reduce using rule 56 (settypedec -> empty .)
    ID              reduce using rule 56 (settypedec -> empty .)


state 17

    (66) type -> DECIMAL settypedec .

    FUNCTION        reduce using rule 66 (type -> DECIMAL settypedec .)
    ID              reduce using rule 66 (type -> DECIMAL settypedec .)


state 18

    (68) type -> FRACTION settypefrac .

    FUNCTION        reduce using rule 68 (type -> FRACTION settypefrac .)
    ID              reduce using rule 68 (type -> FRACTION settypefrac .)


state 19

    (57) settypefrac -> empty .

    OR              reduce using rule 57 (settypefrac -> empty .)
    AND             reduce using rule 57 (settypefrac -> empty .)
    SAME            reduce using rule 57 (settypefrac -> empty .)
    DIF             reduce using rule 57 (settypefrac -> empty .)
    GE              reduce using rule 57 (settypefrac -> empty .)
    LE              reduce using rule 57 (settypefrac -> empty .)
    NE              reduce using rule 57 (settypefrac -> empty .)
    GT              reduce using rule 57 (settypefrac -> empty .)
    LT              reduce using rule 57 (settypefrac -> empty .)
    PLUS            reduce using rule 57 (settypefrac -> empty .)
    MINUS           reduce using rule 57 (settypefrac -> empty .)
    MODULO          reduce using rule 57 (settypefrac -> empty .)
    DIVIDE          reduce using rule 57 (settypefrac -> empty .)
    TIMES           reduce using rule 57 (settypefrac -> empty .)
    POWER           reduce using rule 57 (settypefrac -> empty .)
    SEMI            reduce using rule 57 (settypefrac -> empty .)
    RPAREN          reduce using rule 57 (settypefrac -> empty .)
    RBRACK          reduce using rule 57 (settypefrac -> empty .)
    COMMA           reduce using rule 57 (settypefrac -> empty .)
    FUNCTION        reduce using rule 57 (settypefrac -> empty .)
    ID              reduce using rule 57 (settypefrac -> empty .)


state 20

    (3) program1 -> function program1 .

    $end            reduce using rule 3 (program1 -> function program1 .)


state 21

    (65) type -> INTEGER settypeint .

    FUNCTION        reduce using rule 65 (type -> INTEGER settypeint .)
    ID              reduce using rule 65 (type -> INTEGER settypeint .)


state 22

    (55) settypeint -> empty .

    FUNCTION        reduce using rule 55 (settypeint -> empty .)
    ID              reduce using rule 55 (settypeint -> empty .)
    OR              reduce using rule 55 (settypeint -> empty .)
    AND             reduce using rule 55 (settypeint -> empty .)
    SAME            reduce using rule 55 (settypeint -> empty .)
    DIF             reduce using rule 55 (settypeint -> empty .)
    GE              reduce using rule 55 (settypeint -> empty .)
    LE              reduce using rule 55 (settypeint -> empty .)
    NE              reduce using rule 55 (settypeint -> empty .)
    GT              reduce using rule 55 (settypeint -> empty .)
    LT              reduce using rule 55 (settypeint -> empty .)
    PLUS            reduce using rule 55 (settypeint -> empty .)
    MINUS           reduce using rule 55 (settypeint -> empty .)
    MODULO          reduce using rule 55 (settypeint -> empty .)
    DIVIDE          reduce using rule 55 (settypeint -> empty .)
    TIMES           reduce using rule 55 (settypeint -> empty .)
    POWER           reduce using rule 55 (settypeint -> empty .)
    SEMI            reduce using rule 55 (settypeint -> empty .)
    RPAREN          reduce using rule 55 (settypeint -> empty .)
    RBRACK          reduce using rule 55 (settypeint -> empty .)
    COMMA           reduce using rule 55 (settypeint -> empty .)


state 23

    (67) type -> STRING settypestring .

    FUNCTION        reduce using rule 67 (type -> STRING settypestring .)
    ID              reduce using rule 67 (type -> STRING settypestring .)


state 24

    (58) settypestring -> empty .

    OR              reduce using rule 58 (settypestring -> empty .)
    AND             reduce using rule 58 (settypestring -> empty .)
    SAME            reduce using rule 58 (settypestring -> empty .)
    DIF             reduce using rule 58 (settypestring -> empty .)
    GE              reduce using rule 58 (settypestring -> empty .)
    LE              reduce using rule 58 (settypestring -> empty .)
    NE              reduce using rule 58 (settypestring -> empty .)
    GT              reduce using rule 58 (settypestring -> empty .)
    LT              reduce using rule 58 (settypestring -> empty .)
    PLUS            reduce using rule 58 (settypestring -> empty .)
    MINUS           reduce using rule 58 (settypestring -> empty .)
    MODULO          reduce using rule 58 (settypestring -> empty .)
    DIVIDE          reduce using rule 58 (settypestring -> empty .)
    TIMES           reduce using rule 58 (settypestring -> empty .)
    POWER           reduce using rule 58 (settypestring -> empty .)
    RPAREN          reduce using rule 58 (settypestring -> empty .)
    SEMI            reduce using rule 58 (settypestring -> empty .)
    RBRACK          reduce using rule 58 (settypestring -> empty .)
    COMMA           reduce using rule 58 (settypestring -> empty .)
    FUNCTION        reduce using rule 58 (settypestring -> empty .)
    ID              reduce using rule 58 (settypestring -> empty .)


state 25

    (59) settypebool -> empty .

    OR              reduce using rule 59 (settypebool -> empty .)
    AND             reduce using rule 59 (settypebool -> empty .)
    SAME            reduce using rule 59 (settypebool -> empty .)
    DIF             reduce using rule 59 (settypebool -> empty .)
    GE              reduce using rule 59 (settypebool -> empty .)
    LE              reduce using rule 59 (settypebool -> empty .)
    NE              reduce using rule 59 (settypebool -> empty .)
    GT              reduce using rule 59 (settypebool -> empty .)
    LT              reduce using rule 59 (settypebool -> empty .)
    PLUS            reduce using rule 59 (settypebool -> empty .)
    MINUS           reduce using rule 59 (settypebool -> empty .)
    MODULO          reduce using rule 59 (settypebool -> empty .)
    DIVIDE          reduce using rule 59 (settypebool -> empty .)
    TIMES           reduce using rule 59 (settypebool -> empty .)
    POWER           reduce using rule 59 (settypebool -> empty .)
    SEMI            reduce using rule 59 (settypebool -> empty .)
    RPAREN          reduce using rule 59 (settypebool -> empty .)
    RBRACK          reduce using rule 59 (settypebool -> empty .)
    COMMA           reduce using rule 59 (settypebool -> empty .)
    FUNCTION        reduce using rule 59 (settypebool -> empty .)
    ID              reduce using rule 59 (settypebool -> empty .)


state 26

    (64) type -> BOOLEAN settypebool .

    FUNCTION        reduce using rule 64 (type -> BOOLEAN settypebool .)
    ID              reduce using rule 64 (type -> BOOLEAN settypebool .)


state 27

    (5) function -> type FUNCTION . ID pushid LPAREN parameter RPAREN savefunc block
    (6) function -> type FUNCTION . ID pushid LPAREN RPAREN savefunc block

    ID              shift and go to state 32


state 28

    (69) type -> VOID settypevoid .

    FUNCTION        reduce using rule 69 (type -> VOID settypevoid .)
    ID              reduce using rule 69 (type -> VOID settypevoid .)


state 29

    (60) settypevoid -> empty .

    FUNCTION        reduce using rule 60 (settypevoid -> empty .)
    ID              reduce using rule 60 (settypevoid -> empty .)


state 30

    (50) var -> VAR type . var1 SEMI
    (51) var1 -> . ID pushid savevar allocatevar
    (52) var1 -> . ID pushid savevar allocatevar COMMA var1
    (53) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 33

    var1                           shift and go to state 34

state 31

    (2) program -> PROGRAM ID SEMI var program1 .

    $end            reduce using rule 2 (program -> PROGRAM ID SEMI var program1 .)


state 32

    (5) function -> type FUNCTION ID . pushid LPAREN parameter RPAREN savefunc block
    (6) function -> type FUNCTION ID . pushid LPAREN RPAREN savefunc block
    (102) pushid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    LPAREN          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushtype                       shift and go to state 36
    pushid                         shift and go to state 37

state 33

    (51) var1 -> ID . pushid savevar allocatevar
    (52) var1 -> ID . pushid savevar allocatevar COMMA var1
    (53) var1 -> ID . pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> ID . pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (102) pushid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    LBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushid                         shift and go to state 38
    pushtype                       shift and go to state 36

state 34

    (50) var -> VAR type var1 . SEMI

    SEMI            shift and go to state 39


state 35

    (101) pushtype -> empty .

    OR              reduce using rule 101 (pushtype -> empty .)
    AND             reduce using rule 101 (pushtype -> empty .)
    SAME            reduce using rule 101 (pushtype -> empty .)
    DIF             reduce using rule 101 (pushtype -> empty .)
    GE              reduce using rule 101 (pushtype -> empty .)
    LE              reduce using rule 101 (pushtype -> empty .)
    NE              reduce using rule 101 (pushtype -> empty .)
    GT              reduce using rule 101 (pushtype -> empty .)
    LT              reduce using rule 101 (pushtype -> empty .)
    PLUS            reduce using rule 101 (pushtype -> empty .)
    MINUS           reduce using rule 101 (pushtype -> empty .)
    MODULO          reduce using rule 101 (pushtype -> empty .)
    DIVIDE          reduce using rule 101 (pushtype -> empty .)
    TIMES           reduce using rule 101 (pushtype -> empty .)
    POWER           reduce using rule 101 (pushtype -> empty .)
    SEMI            reduce using rule 101 (pushtype -> empty .)
    RPAREN          reduce using rule 101 (pushtype -> empty .)
    RBRACK          reduce using rule 101 (pushtype -> empty .)
    COMMA           reduce using rule 101 (pushtype -> empty .)
    EQUALS          reduce using rule 101 (pushtype -> empty .)
    LBRACK          reduce using rule 101 (pushtype -> empty .)
    LPAREN          reduce using rule 101 (pushtype -> empty .)


state 36

    (102) pushid -> pushtype .

    LPAREN          reduce using rule 102 (pushid -> pushtype .)
    EQUALS          reduce using rule 102 (pushid -> pushtype .)
    LBRACK          reduce using rule 102 (pushid -> pushtype .)
    RPAREN          reduce using rule 102 (pushid -> pushtype .)
    COMMA           reduce using rule 102 (pushid -> pushtype .)
    SEMI            reduce using rule 102 (pushid -> pushtype .)


state 37

    (5) function -> type FUNCTION ID pushid . LPAREN parameter RPAREN savefunc block
    (6) function -> type FUNCTION ID pushid . LPAREN RPAREN savefunc block

    LPAREN          shift and go to state 40


state 38

    (51) var1 -> ID pushid . savevar allocatevar
    (52) var1 -> ID pushid . savevar allocatevar COMMA var1
    (53) var1 -> ID pushid . savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> ID pushid . savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (61) savevar -> . empty
    (105) empty -> .

    LBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)

    empty                          shift and go to state 41
    savevar                        shift and go to state 42

state 39

    (50) var -> VAR type var1 SEMI .

    IF              reduce using rule 50 (var -> VAR type var1 SEMI .)
    ID              reduce using rule 50 (var -> VAR type var1 SEMI .)
    WHILE           reduce using rule 50 (var -> VAR type var1 SEMI .)
    LPAREN          reduce using rule 50 (var -> VAR type var1 SEMI .)
    DO              reduce using rule 50 (var -> VAR type var1 SEMI .)
    COMMENT         reduce using rule 50 (var -> VAR type var1 SEMI .)
    PRINT           reduce using rule 50 (var -> VAR type var1 SEMI .)
    VAR             reduce using rule 50 (var -> VAR type var1 SEMI .)
    RBRACE          reduce using rule 50 (var -> VAR type var1 SEMI .)
    BOOLEAN         reduce using rule 50 (var -> VAR type var1 SEMI .)
    INTEGER         reduce using rule 50 (var -> VAR type var1 SEMI .)
    DECIMAL         reduce using rule 50 (var -> VAR type var1 SEMI .)
    STRING          reduce using rule 50 (var -> VAR type var1 SEMI .)
    FRACTION        reduce using rule 50 (var -> VAR type var1 SEMI .)
    VOID            reduce using rule 50 (var -> VAR type var1 SEMI .)
    RETURN          reduce using rule 50 (var -> VAR type var1 SEMI .)


state 40

    (5) function -> type FUNCTION ID pushid LPAREN . parameter RPAREN savefunc block
    (6) function -> type FUNCTION ID pushid LPAREN . RPAREN savefunc block
    (8) parameter -> . type ID pushid
    (9) parameter -> . type ID pushid COMMA parameter
    (64) type -> . BOOLEAN settypebool
    (65) type -> . INTEGER settypeint
    (66) type -> . DECIMAL settypedec
    (67) type -> . STRING settypestring
    (68) type -> . FRACTION settypefrac
    (69) type -> . VOID settypevoid

    RPAREN          shift and go to state 45
    BOOLEAN         shift and go to state 10
    INTEGER         shift and go to state 8
    DECIMAL         shift and go to state 5
    STRING          shift and go to state 9
    FRACTION        shift and go to state 6
    VOID            shift and go to state 12

    parameter                      shift and go to state 43
    type                           shift and go to state 44

state 41

    (61) savevar -> empty .

    LBRACK          reduce using rule 61 (savevar -> empty .)
    COMMA           reduce using rule 61 (savevar -> empty .)
    SEMI            reduce using rule 61 (savevar -> empty .)


state 42

    (51) var1 -> ID pushid savevar . allocatevar
    (52) var1 -> ID pushid savevar . allocatevar COMMA var1
    (53) var1 -> ID pushid savevar . LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> ID pushid savevar . LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (62) allocatevar -> . empty
    (105) empty -> .

    LBRACK          shift and go to state 47
    COMMA           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)

    empty                          shift and go to state 46
    allocatevar                    shift and go to state 48

state 43

    (5) function -> type FUNCTION ID pushid LPAREN parameter . RPAREN savefunc block

    RPAREN          shift and go to state 49


state 44

    (8) parameter -> type . ID pushid
    (9) parameter -> type . ID pushid COMMA parameter

    ID              shift and go to state 50


state 45

    (6) function -> type FUNCTION ID pushid LPAREN RPAREN . savefunc block
    (7) savefunc -> . empty
    (105) empty -> .

    LBRACE          reduce using rule 105 (empty -> .)

    savefunc                       shift and go to state 51
    empty                          shift and go to state 52

state 46

    (62) allocatevar -> empty .

    COMMA           reduce using rule 62 (allocatevar -> empty .)
    SEMI            reduce using rule 62 (allocatevar -> empty .)


state 47

    (53) var1 -> ID pushid savevar LBRACK . INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> ID pushid savevar LBRACK . INTEGER_CONS updatesize RBRACK allocatevar

    INTEGER_CONS    shift and go to state 53


state 48

    (51) var1 -> ID pushid savevar allocatevar .
    (52) var1 -> ID pushid savevar allocatevar . COMMA var1

    SEMI            reduce using rule 51 (var1 -> ID pushid savevar allocatevar .)
    COMMA           shift and go to state 54


state 49

    (5) function -> type FUNCTION ID pushid LPAREN parameter RPAREN . savefunc block
    (7) savefunc -> . empty
    (105) empty -> .

    LBRACE          reduce using rule 105 (empty -> .)

    savefunc                       shift and go to state 55
    empty                          shift and go to state 52

state 50

    (8) parameter -> type ID . pushid
    (9) parameter -> type ID . pushid COMMA parameter
    (102) pushid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    COMMA           reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)

    pushtype                       shift and go to state 36
    pushid                         shift and go to state 56
    empty                          shift and go to state 35

state 51

    (6) function -> type FUNCTION ID pushid LPAREN RPAREN savefunc . block
    (10) block -> . LBRACE statements RETURN expression SEMI savereturn RBRACE
    (11) block -> . LBRACE RETURN expression SEMI savereturn RBRACE
    (12) block -> . LBRACE statements nortn RBRACE
    (13) block -> . LBRACE nortn RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 57

state 52

    (7) savefunc -> empty .

    LBRACE          reduce using rule 7 (savefunc -> empty .)


state 53

    (53) var1 -> ID pushid savevar LBRACK INTEGER_CONS . updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> ID pushid savevar LBRACK INTEGER_CONS . updatesize RBRACK allocatevar
    (63) updatesize -> . empty
    (105) empty -> .

    RBRACK          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 60
    updatesize                     shift and go to state 59

state 54

    (52) var1 -> ID pushid savevar allocatevar COMMA . var1
    (51) var1 -> . ID pushid savevar allocatevar
    (52) var1 -> . ID pushid savevar allocatevar COMMA var1
    (53) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 33

    var1                           shift and go to state 61

state 55

    (5) function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc . block
    (10) block -> . LBRACE statements RETURN expression SEMI savereturn RBRACE
    (11) block -> . LBRACE RETURN expression SEMI savereturn RBRACE
    (12) block -> . LBRACE statements nortn RBRACE
    (13) block -> . LBRACE nortn RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 62

state 56

    (8) parameter -> type ID pushid .
    (9) parameter -> type ID pushid . COMMA parameter

    RPAREN          reduce using rule 8 (parameter -> type ID pushid .)
    COMMA           shift and go to state 63


state 57

    (6) function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .

    BOOLEAN         reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)
    INTEGER         reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)
    DECIMAL         reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)
    STRING          reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)
    FRACTION        reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)
    VOID            reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)
    $end            reduce using rule 6 (function -> type FUNCTION ID pushid LPAREN RPAREN savefunc block .)


state 58

    (10) block -> LBRACE . statements RETURN expression SEMI savereturn RBRACE
    (11) block -> LBRACE . RETURN expression SEMI savereturn RBRACE
    (12) block -> LBRACE . statements nortn RBRACE
    (13) block -> LBRACE . nortn RBRACE
    (18) statements -> . statement
    (19) statements -> . statement statements
    (16) nortn -> . empty
    (20) statement -> . condition
    (21) statement -> . assignment
    (22) statement -> . while
    (23) statement -> . for
    (24) statement -> . dowhile
    (25) statement -> . comment
    (26) statement -> . print
    (27) statement -> . var
    (28) statement -> . funcall
    (105) empty -> .
    (45) condition -> . IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> . IF LPAREN expression RPAREN gotof blocknortn updatejump
    (70) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (71) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (43) while -> . WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile
    (39) for -> . LPAREN assignment expression SEMI expression RPAREN blocknortn
    (40) dowhile -> . DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot
    (38) comment -> . COMMENT ID
    (29) print -> . PRINT LPAREN expression RPAREN SEMI
    (30) print -> . PRINT LPAREN STRING_CONS RPAREN SEMI
    (31) print -> . PRINT LPAREN ID RPAREN SEMI
    (50) var -> . VAR type var1 SEMI
    (32) funcall -> . ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI
    (33) funcall -> . ID pushid RPAREN LPAREN assignvalues SEMI

    RETURN          shift and go to state 67
    RBRACE          reduce using rule 105 (empty -> .)
    IF              shift and go to state 66
    ID              shift and go to state 84
    WHILE           shift and go to state 81
    LPAREN          shift and go to state 74
    DO              shift and go to state 82
    COMMENT         shift and go to state 77
    PRINT           shift and go to state 83
    VAR             shift and go to state 14

    while                          shift and go to state 76
    funcall                        shift and go to state 78
    comment                        shift and go to state 64
    nortn                          shift and go to state 65
    dowhile                        shift and go to state 80
    assignment                     shift and go to state 68
    statements                     shift and go to state 69
    empty                          shift and go to state 70
    statement                      shift and go to state 71
    print                          shift and go to state 72
    for                            shift and go to state 73
    condition                      shift and go to state 79
    var                            shift and go to state 75

state 59

    (53) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize . RBRACK allocatevar COMMA var1
    (54) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize . RBRACK allocatevar

    RBRACK          shift and go to state 85


state 60

    (63) updatesize -> empty .

    RBRACK          reduce using rule 63 (updatesize -> empty .)


state 61

    (52) var1 -> ID pushid savevar allocatevar COMMA var1 .

    SEMI            reduce using rule 52 (var1 -> ID pushid savevar allocatevar COMMA var1 .)


state 62

    (5) function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .

    BOOLEAN         reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)
    INTEGER         reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)
    DECIMAL         reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)
    STRING          reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)
    FRACTION        reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)
    VOID            reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)
    $end            reduce using rule 5 (function -> type FUNCTION ID pushid LPAREN parameter RPAREN savefunc block .)


state 63

    (9) parameter -> type ID pushid COMMA . parameter
    (8) parameter -> . type ID pushid
    (9) parameter -> . type ID pushid COMMA parameter
    (64) type -> . BOOLEAN settypebool
    (65) type -> . INTEGER settypeint
    (66) type -> . DECIMAL settypedec
    (67) type -> . STRING settypestring
    (68) type -> . FRACTION settypefrac
    (69) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 10
    INTEGER         shift and go to state 8
    DECIMAL         shift and go to state 5
    STRING          shift and go to state 9
    FRACTION        shift and go to state 6
    VOID            shift and go to state 12

    type                           shift and go to state 44
    parameter                      shift and go to state 86

state 64

    (25) statement -> comment .

    IF              reduce using rule 25 (statement -> comment .)
    ID              reduce using rule 25 (statement -> comment .)
    WHILE           reduce using rule 25 (statement -> comment .)
    LPAREN          reduce using rule 25 (statement -> comment .)
    DO              reduce using rule 25 (statement -> comment .)
    COMMENT         reduce using rule 25 (statement -> comment .)
    PRINT           reduce using rule 25 (statement -> comment .)
    VAR             reduce using rule 25 (statement -> comment .)
    RETURN          reduce using rule 25 (statement -> comment .)
    RBRACE          reduce using rule 25 (statement -> comment .)


state 65

    (13) block -> LBRACE nortn . RBRACE

    RBRACE          shift and go to state 87


state 66

    (45) condition -> IF . LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> IF . LPAREN expression RPAREN gotof blocknortn updatejump

    LPAREN          shift and go to state 88


state 67

    (11) block -> LBRACE RETURN . expression SEMI savereturn RBRACE
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 95
    exp                            shift and go to state 97

state 68

    (21) statement -> assignment .

    IF              reduce using rule 21 (statement -> assignment .)
    ID              reduce using rule 21 (statement -> assignment .)
    WHILE           reduce using rule 21 (statement -> assignment .)
    LPAREN          reduce using rule 21 (statement -> assignment .)
    DO              reduce using rule 21 (statement -> assignment .)
    COMMENT         reduce using rule 21 (statement -> assignment .)
    PRINT           reduce using rule 21 (statement -> assignment .)
    VAR             reduce using rule 21 (statement -> assignment .)
    RETURN          reduce using rule 21 (statement -> assignment .)
    RBRACE          reduce using rule 21 (statement -> assignment .)


state 69

    (10) block -> LBRACE statements . RETURN expression SEMI savereturn RBRACE
    (12) block -> LBRACE statements . nortn RBRACE
    (16) nortn -> . empty
    (105) empty -> .

    RETURN          shift and go to state 102
    RBRACE          reduce using rule 105 (empty -> .)

    nortn                          shift and go to state 101
    empty                          shift and go to state 70

state 70

    (16) nortn -> empty .

    RBRACE          reduce using rule 16 (nortn -> empty .)


state 71

    (18) statements -> statement .
    (19) statements -> statement . statements
    (18) statements -> . statement
    (19) statements -> . statement statements
    (20) statement -> . condition
    (21) statement -> . assignment
    (22) statement -> . while
    (23) statement -> . for
    (24) statement -> . dowhile
    (25) statement -> . comment
    (26) statement -> . print
    (27) statement -> . var
    (28) statement -> . funcall
    (45) condition -> . IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> . IF LPAREN expression RPAREN gotof blocknortn updatejump
    (70) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (71) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (43) while -> . WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile
    (39) for -> . LPAREN assignment expression SEMI expression RPAREN blocknortn
    (40) dowhile -> . DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot
    (38) comment -> . COMMENT ID
    (29) print -> . PRINT LPAREN expression RPAREN SEMI
    (30) print -> . PRINT LPAREN STRING_CONS RPAREN SEMI
    (31) print -> . PRINT LPAREN ID RPAREN SEMI
    (50) var -> . VAR type var1 SEMI
    (32) funcall -> . ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI
    (33) funcall -> . ID pushid RPAREN LPAREN assignvalues SEMI

    RETURN          reduce using rule 18 (statements -> statement .)
    RBRACE          reduce using rule 18 (statements -> statement .)
    IF              shift and go to state 66
    ID              shift and go to state 84
    WHILE           shift and go to state 81
    LPAREN          shift and go to state 74
    DO              shift and go to state 82
    COMMENT         shift and go to state 77
    PRINT           shift and go to state 83
    VAR             shift and go to state 14

    while                          shift and go to state 76
    funcall                        shift and go to state 78
    comment                        shift and go to state 64
    dowhile                        shift and go to state 80
    assignment                     shift and go to state 68
    statements                     shift and go to state 103
    statement                      shift and go to state 71
    print                          shift and go to state 72
    for                            shift and go to state 73
    condition                      shift and go to state 79
    var                            shift and go to state 75

state 72

    (26) statement -> print .

    IF              reduce using rule 26 (statement -> print .)
    ID              reduce using rule 26 (statement -> print .)
    WHILE           reduce using rule 26 (statement -> print .)
    LPAREN          reduce using rule 26 (statement -> print .)
    DO              reduce using rule 26 (statement -> print .)
    COMMENT         reduce using rule 26 (statement -> print .)
    PRINT           reduce using rule 26 (statement -> print .)
    VAR             reduce using rule 26 (statement -> print .)
    RETURN          reduce using rule 26 (statement -> print .)
    RBRACE          reduce using rule 26 (statement -> print .)


state 73

    (23) statement -> for .

    IF              reduce using rule 23 (statement -> for .)
    ID              reduce using rule 23 (statement -> for .)
    WHILE           reduce using rule 23 (statement -> for .)
    LPAREN          reduce using rule 23 (statement -> for .)
    DO              reduce using rule 23 (statement -> for .)
    COMMENT         reduce using rule 23 (statement -> for .)
    PRINT           reduce using rule 23 (statement -> for .)
    VAR             reduce using rule 23 (statement -> for .)
    RETURN          reduce using rule 23 (statement -> for .)
    RBRACE          reduce using rule 23 (statement -> for .)


state 74

    (39) for -> LPAREN . assignment expression SEMI expression RPAREN blocknortn
    (70) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (71) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell

    ID              shift and go to state 104

    assignment                     shift and go to state 105

state 75

    (27) statement -> var .

    IF              reduce using rule 27 (statement -> var .)
    ID              reduce using rule 27 (statement -> var .)
    WHILE           reduce using rule 27 (statement -> var .)
    LPAREN          reduce using rule 27 (statement -> var .)
    DO              reduce using rule 27 (statement -> var .)
    COMMENT         reduce using rule 27 (statement -> var .)
    PRINT           reduce using rule 27 (statement -> var .)
    VAR             reduce using rule 27 (statement -> var .)
    RETURN          reduce using rule 27 (statement -> var .)
    RBRACE          reduce using rule 27 (statement -> var .)


state 76

    (22) statement -> while .

    IF              reduce using rule 22 (statement -> while .)
    ID              reduce using rule 22 (statement -> while .)
    WHILE           reduce using rule 22 (statement -> while .)
    LPAREN          reduce using rule 22 (statement -> while .)
    DO              reduce using rule 22 (statement -> while .)
    COMMENT         reduce using rule 22 (statement -> while .)
    PRINT           reduce using rule 22 (statement -> while .)
    VAR             reduce using rule 22 (statement -> while .)
    RETURN          reduce using rule 22 (statement -> while .)
    RBRACE          reduce using rule 22 (statement -> while .)


state 77

    (38) comment -> COMMENT . ID

    ID              shift and go to state 106


state 78

    (28) statement -> funcall .

    IF              reduce using rule 28 (statement -> funcall .)
    ID              reduce using rule 28 (statement -> funcall .)
    WHILE           reduce using rule 28 (statement -> funcall .)
    LPAREN          reduce using rule 28 (statement -> funcall .)
    DO              reduce using rule 28 (statement -> funcall .)
    COMMENT         reduce using rule 28 (statement -> funcall .)
    PRINT           reduce using rule 28 (statement -> funcall .)
    VAR             reduce using rule 28 (statement -> funcall .)
    RETURN          reduce using rule 28 (statement -> funcall .)
    RBRACE          reduce using rule 28 (statement -> funcall .)


state 79

    (20) statement -> condition .

    IF              reduce using rule 20 (statement -> condition .)
    ID              reduce using rule 20 (statement -> condition .)
    WHILE           reduce using rule 20 (statement -> condition .)
    LPAREN          reduce using rule 20 (statement -> condition .)
    DO              reduce using rule 20 (statement -> condition .)
    COMMENT         reduce using rule 20 (statement -> condition .)
    PRINT           reduce using rule 20 (statement -> condition .)
    VAR             reduce using rule 20 (statement -> condition .)
    RETURN          reduce using rule 20 (statement -> condition .)
    RBRACE          reduce using rule 20 (statement -> condition .)


state 80

    (24) statement -> dowhile .

    IF              reduce using rule 24 (statement -> dowhile .)
    ID              reduce using rule 24 (statement -> dowhile .)
    WHILE           reduce using rule 24 (statement -> dowhile .)
    LPAREN          reduce using rule 24 (statement -> dowhile .)
    DO              reduce using rule 24 (statement -> dowhile .)
    COMMENT         reduce using rule 24 (statement -> dowhile .)
    PRINT           reduce using rule 24 (statement -> dowhile .)
    VAR             reduce using rule 24 (statement -> dowhile .)
    RETURN          reduce using rule 24 (statement -> dowhile .)
    RBRACE          reduce using rule 24 (statement -> dowhile .)


state 81

    (43) while -> WHILE . pushjump LPAREN expression RPAREN gotof blocknortn gotowhile
    (41) pushjump -> . empty
    (105) empty -> .

    LPAREN          reduce using rule 105 (empty -> .)

    pushjump                       shift and go to state 107
    empty                          shift and go to state 108

state 82

    (40) dowhile -> DO . pushjump blocknortn WHILE LPAREN expression RPAREN gotot
    (41) pushjump -> . empty
    (105) empty -> .

    LBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 108
    pushjump                       shift and go to state 109

state 83

    (29) print -> PRINT . LPAREN expression RPAREN SEMI
    (30) print -> PRINT . LPAREN STRING_CONS RPAREN SEMI
    (31) print -> PRINT . LPAREN ID RPAREN SEMI

    LPAREN          shift and go to state 110


state 84

    (70) assignment -> ID . pushid EQUALS expression SEMI updatevar
    (71) assignment -> ID . pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (32) funcall -> ID . pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI
    (33) funcall -> ID . pushid RPAREN LPAREN assignvalues SEMI
    (102) pushid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    EQUALS          reduce using rule 105 (empty -> .)
    LBRACK          reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushid                         shift and go to state 111
    pushtype                       shift and go to state 36

state 85

    (53) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK . allocatevar COMMA var1
    (54) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK . allocatevar
    (62) allocatevar -> . empty
    (105) empty -> .

    COMMA           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)

    empty                          shift and go to state 46
    allocatevar                    shift and go to state 112

state 86

    (9) parameter -> type ID pushid COMMA parameter .

    RPAREN          reduce using rule 9 (parameter -> type ID pushid COMMA parameter .)


state 87

    (13) block -> LBRACE nortn RBRACE .

    BOOLEAN         reduce using rule 13 (block -> LBRACE nortn RBRACE .)
    INTEGER         reduce using rule 13 (block -> LBRACE nortn RBRACE .)
    DECIMAL         reduce using rule 13 (block -> LBRACE nortn RBRACE .)
    STRING          reduce using rule 13 (block -> LBRACE nortn RBRACE .)
    FRACTION        reduce using rule 13 (block -> LBRACE nortn RBRACE .)
    VOID            reduce using rule 13 (block -> LBRACE nortn RBRACE .)
    $end            reduce using rule 13 (block -> LBRACE nortn RBRACE .)


state 88

    (45) condition -> IF LPAREN . expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> IF LPAREN . expression RPAREN gotof blocknortn updatejump
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 113
    exp                            shift and go to state 97

state 89

    (100) exp -> LPAREN . exp RPAREN
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 114

state 90

    (95) exp -> FRACTION_CONS . settypefrac pushcons
    (57) settypefrac -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    settypefrac                    shift and go to state 115
    empty                          shift and go to state 19

state 91

    (98) exp -> FALSE . settypebool pushcons
    (59) settypebool -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 25
    settypebool                    shift and go to state 116

state 92

    (96) exp -> DECIMAL_CONS . settypedec pushcons
    (56) settypedec -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 16
    settypedec                     shift and go to state 117

state 93

    (94) exp -> STRING_CONS . settypestring pushcons
    (58) settypestring -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    settypestring                  shift and go to state 118
    empty                          shift and go to state 24

state 94

    (99) exp -> EXMARK . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 119

state 95

    (11) block -> LBRACE RETURN expression . SEMI savereturn RBRACE

    SEMI            shift and go to state 120


state 96

    (92) exp -> LBRACK . exp RBRACK
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 121

state 97

    (74) expression -> exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    RBRACK          reduce using rule 74 (expression -> exp .)
    RPAREN          reduce using rule 74 (expression -> exp .)
    SEMI            reduce using rule 74 (expression -> exp .)
    COMMA           reduce using rule 74 (expression -> exp .)
    OR              shift and go to state 122
    AND             shift and go to state 131
    SAME            shift and go to state 129
    DIF             shift and go to state 134
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133


state 98

    (93) exp -> INTEGER_CONS . settypeint pushcons
    (55) settypeint -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    settypeint                     shift and go to state 137
    empty                          shift and go to state 22

state 99

    (97) exp -> TRUE . settypebool pushcons
    (59) settypebool -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 25
    settypebool                    shift and go to state 138

state 100

    (90) exp -> ID . pushdeclaredid
    (91) exp -> ID . LBRACK expression RBRACK pushdeclaredid
    (103) pushdeclaredid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    LBRACK          shift and go to state 141
    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushtype                       shift and go to state 140
    pushdeclaredid                 shift and go to state 139

state 101

    (12) block -> LBRACE statements nortn . RBRACE

    RBRACE          shift and go to state 142


state 102

    (10) block -> LBRACE statements RETURN . expression SEMI savereturn RBRACE
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 143
    exp                            shift and go to state 97

state 103

    (19) statements -> statement statements .

    RETURN          reduce using rule 19 (statements -> statement statements .)
    RBRACE          reduce using rule 19 (statements -> statement statements .)


state 104

    (70) assignment -> ID . pushid EQUALS expression SEMI updatevar
    (71) assignment -> ID . pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (102) pushid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    EQUALS          reduce using rule 105 (empty -> .)
    LBRACK          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushid                         shift and go to state 144
    pushtype                       shift and go to state 36

state 105

    (39) for -> LPAREN assignment . expression SEMI expression RPAREN blocknortn
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 145
    exp                            shift and go to state 97

state 106

    (38) comment -> COMMENT ID .

    IF              reduce using rule 38 (comment -> COMMENT ID .)
    ID              reduce using rule 38 (comment -> COMMENT ID .)
    WHILE           reduce using rule 38 (comment -> COMMENT ID .)
    LPAREN          reduce using rule 38 (comment -> COMMENT ID .)
    DO              reduce using rule 38 (comment -> COMMENT ID .)
    COMMENT         reduce using rule 38 (comment -> COMMENT ID .)
    PRINT           reduce using rule 38 (comment -> COMMENT ID .)
    VAR             reduce using rule 38 (comment -> COMMENT ID .)
    RETURN          reduce using rule 38 (comment -> COMMENT ID .)
    RBRACE          reduce using rule 38 (comment -> COMMENT ID .)


state 107

    (43) while -> WHILE pushjump . LPAREN expression RPAREN gotof blocknortn gotowhile

    LPAREN          shift and go to state 146


state 108

    (41) pushjump -> empty .

    LPAREN          reduce using rule 41 (pushjump -> empty .)
    LBRACE          reduce using rule 41 (pushjump -> empty .)


state 109

    (40) dowhile -> DO pushjump . blocknortn WHILE LPAREN expression RPAREN gotot
    (14) blocknortn -> . LBRACE statements RBRACE
    (15) blocknortn -> . LBRACE RBRACE

    LBRACE          shift and go to state 148

    blocknortn                     shift and go to state 147

state 110

    (29) print -> PRINT LPAREN . expression RPAREN SEMI
    (30) print -> PRINT LPAREN . STRING_CONS RPAREN SEMI
    (31) print -> PRINT LPAREN . ID RPAREN SEMI
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    STRING_CONS     shift and go to state 149
    ID              shift and go to state 151
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 150
    exp                            shift and go to state 97

state 111

    (70) assignment -> ID pushid . EQUALS expression SEMI updatevar
    (71) assignment -> ID pushid . LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (32) funcall -> ID pushid . LPAREN startcount expression exparam RPAREN assignvalues SEMI
    (33) funcall -> ID pushid . RPAREN LPAREN assignvalues SEMI

    EQUALS          shift and go to state 153
    LBRACK          shift and go to state 152
    LPAREN          shift and go to state 155
    RPAREN          shift and go to state 154


state 112

    (53) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar . COMMA var1
    (54) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar .

    COMMA           shift and go to state 156
    SEMI            reduce using rule 54 (var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar .)


state 113

    (45) condition -> IF LPAREN expression . RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> IF LPAREN expression . RPAREN gotof blocknortn updatejump

    RPAREN          shift and go to state 157


state 114

    (100) exp -> LPAREN exp . RPAREN
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    RPAREN          shift and go to state 158
    OR              shift and go to state 122
    AND             shift and go to state 131
    SAME            shift and go to state 129
    DIF             shift and go to state 134
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133


state 115

    (95) exp -> FRACTION_CONS settypefrac . pushcons
    (104) pushcons -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushcons                       shift and go to state 159
    pushtype                       shift and go to state 160

state 116

    (98) exp -> FALSE settypebool . pushcons
    (104) pushcons -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushcons                       shift and go to state 161
    pushtype                       shift and go to state 160

state 117

    (96) exp -> DECIMAL_CONS settypedec . pushcons
    (104) pushcons -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushtype                       shift and go to state 160
    pushcons                       shift and go to state 162

state 118

    (94) exp -> STRING_CONS settypestring . pushcons
    (104) pushcons -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushcons                       shift and go to state 163
    pushtype                       shift and go to state 160

state 119

    (99) exp -> EXMARK exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 99 (exp -> EXMARK exp .)
    AND             reduce using rule 99 (exp -> EXMARK exp .)
    DIF             reduce using rule 99 (exp -> EXMARK exp .)
    SEMI            reduce using rule 99 (exp -> EXMARK exp .)
    RPAREN          reduce using rule 99 (exp -> EXMARK exp .)
    RBRACK          reduce using rule 99 (exp -> EXMARK exp .)
    COMMA           reduce using rule 99 (exp -> EXMARK exp .)
    SAME            shift and go to state 129
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! SAME            [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! GE              [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! LE              [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! NE              [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! GT              [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! LT              [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! PLUS            [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! MINUS           [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! MODULO          [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! DIVIDE          [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! TIMES           [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! POWER           [ reduce using rule 99 (exp -> EXMARK exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! DIF             [ shift and go to state 134 ]


state 120

    (11) block -> LBRACE RETURN expression SEMI . savereturn RBRACE
    (17) savereturn -> . empty
    (105) empty -> .

    RBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 164
    savereturn                     shift and go to state 165

state 121

    (92) exp -> LBRACK exp . RBRACK
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    RBRACK          shift and go to state 166
    OR              shift and go to state 122
    AND             shift and go to state 131
    SAME            shift and go to state 129
    DIF             shift and go to state 134
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133


state 122

    (75) exp -> exp OR . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 167

state 123

    (80) exp -> exp LE . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 168

state 124

    (87) exp -> exp DIVIDE . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 169

state 125

    (85) exp -> exp MINUS . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 170

state 126

    (79) exp -> exp GE . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 171

state 127

    (83) exp -> exp LT . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 172

state 128

    (84) exp -> exp PLUS . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 173

state 129

    (77) exp -> exp SAME . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 174

state 130

    (81) exp -> exp NE . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 175

state 131

    (76) exp -> exp AND . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 176

state 132

    (86) exp -> exp MODULO . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 177

state 133

    (89) exp -> exp POWER . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 178

state 134

    (78) exp -> exp DIF . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 179

state 135

    (88) exp -> exp TIMES . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 180

state 136

    (82) exp -> exp GT . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    exp                            shift and go to state 181

state 137

    (93) exp -> INTEGER_CONS settypeint . pushcons
    (104) pushcons -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushcons                       shift and go to state 182
    pushtype                       shift and go to state 160

state 138

    (97) exp -> TRUE settypebool . pushcons
    (104) pushcons -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushcons                       shift and go to state 183
    pushtype                       shift and go to state 160

state 139

    (90) exp -> ID pushdeclaredid .

    OR              reduce using rule 90 (exp -> ID pushdeclaredid .)
    AND             reduce using rule 90 (exp -> ID pushdeclaredid .)
    SAME            reduce using rule 90 (exp -> ID pushdeclaredid .)
    DIF             reduce using rule 90 (exp -> ID pushdeclaredid .)
    GE              reduce using rule 90 (exp -> ID pushdeclaredid .)
    LE              reduce using rule 90 (exp -> ID pushdeclaredid .)
    NE              reduce using rule 90 (exp -> ID pushdeclaredid .)
    GT              reduce using rule 90 (exp -> ID pushdeclaredid .)
    LT              reduce using rule 90 (exp -> ID pushdeclaredid .)
    PLUS            reduce using rule 90 (exp -> ID pushdeclaredid .)
    MINUS           reduce using rule 90 (exp -> ID pushdeclaredid .)
    MODULO          reduce using rule 90 (exp -> ID pushdeclaredid .)
    DIVIDE          reduce using rule 90 (exp -> ID pushdeclaredid .)
    TIMES           reduce using rule 90 (exp -> ID pushdeclaredid .)
    POWER           reduce using rule 90 (exp -> ID pushdeclaredid .)
    SEMI            reduce using rule 90 (exp -> ID pushdeclaredid .)
    RPAREN          reduce using rule 90 (exp -> ID pushdeclaredid .)
    RBRACK          reduce using rule 90 (exp -> ID pushdeclaredid .)
    COMMA           reduce using rule 90 (exp -> ID pushdeclaredid .)


state 140

    (103) pushdeclaredid -> pushtype .

    OR              reduce using rule 103 (pushdeclaredid -> pushtype .)
    AND             reduce using rule 103 (pushdeclaredid -> pushtype .)
    SAME            reduce using rule 103 (pushdeclaredid -> pushtype .)
    DIF             reduce using rule 103 (pushdeclaredid -> pushtype .)
    GE              reduce using rule 103 (pushdeclaredid -> pushtype .)
    LE              reduce using rule 103 (pushdeclaredid -> pushtype .)
    NE              reduce using rule 103 (pushdeclaredid -> pushtype .)
    GT              reduce using rule 103 (pushdeclaredid -> pushtype .)
    LT              reduce using rule 103 (pushdeclaredid -> pushtype .)
    PLUS            reduce using rule 103 (pushdeclaredid -> pushtype .)
    MINUS           reduce using rule 103 (pushdeclaredid -> pushtype .)
    MODULO          reduce using rule 103 (pushdeclaredid -> pushtype .)
    DIVIDE          reduce using rule 103 (pushdeclaredid -> pushtype .)
    TIMES           reduce using rule 103 (pushdeclaredid -> pushtype .)
    POWER           reduce using rule 103 (pushdeclaredid -> pushtype .)
    SEMI            reduce using rule 103 (pushdeclaredid -> pushtype .)
    RPAREN          reduce using rule 103 (pushdeclaredid -> pushtype .)
    RBRACK          reduce using rule 103 (pushdeclaredid -> pushtype .)
    COMMA           reduce using rule 103 (pushdeclaredid -> pushtype .)


state 141

    (91) exp -> ID LBRACK . expression RBRACK pushdeclaredid
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 184
    exp                            shift and go to state 97

state 142

    (12) block -> LBRACE statements nortn RBRACE .

    BOOLEAN         reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)
    INTEGER         reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)
    DECIMAL         reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)
    STRING          reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)
    FRACTION        reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)
    VOID            reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)
    $end            reduce using rule 12 (block -> LBRACE statements nortn RBRACE .)


state 143

    (10) block -> LBRACE statements RETURN expression . SEMI savereturn RBRACE

    SEMI            shift and go to state 185


state 144

    (70) assignment -> ID pushid . EQUALS expression SEMI updatevar
    (71) assignment -> ID pushid . LBRACK expression RBRACK EQUALS expression SEMI updatecell

    EQUALS          shift and go to state 153
    LBRACK          shift and go to state 152


state 145

    (39) for -> LPAREN assignment expression . SEMI expression RPAREN blocknortn

    SEMI            shift and go to state 186


state 146

    (43) while -> WHILE pushjump LPAREN . expression RPAREN gotof blocknortn gotowhile
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 187
    exp                            shift and go to state 97

state 147

    (40) dowhile -> DO pushjump blocknortn . WHILE LPAREN expression RPAREN gotot

    WHILE           shift and go to state 188


state 148

    (14) blocknortn -> LBRACE . statements RBRACE
    (15) blocknortn -> LBRACE . RBRACE
    (18) statements -> . statement
    (19) statements -> . statement statements
    (20) statement -> . condition
    (21) statement -> . assignment
    (22) statement -> . while
    (23) statement -> . for
    (24) statement -> . dowhile
    (25) statement -> . comment
    (26) statement -> . print
    (27) statement -> . var
    (28) statement -> . funcall
    (45) condition -> . IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> . IF LPAREN expression RPAREN gotof blocknortn updatejump
    (70) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (71) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (43) while -> . WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile
    (39) for -> . LPAREN assignment expression SEMI expression RPAREN blocknortn
    (40) dowhile -> . DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot
    (38) comment -> . COMMENT ID
    (29) print -> . PRINT LPAREN expression RPAREN SEMI
    (30) print -> . PRINT LPAREN STRING_CONS RPAREN SEMI
    (31) print -> . PRINT LPAREN ID RPAREN SEMI
    (50) var -> . VAR type var1 SEMI
    (32) funcall -> . ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI
    (33) funcall -> . ID pushid RPAREN LPAREN assignvalues SEMI

    RBRACE          shift and go to state 190
    IF              shift and go to state 66
    ID              shift and go to state 84
    WHILE           shift and go to state 81
    LPAREN          shift and go to state 74
    DO              shift and go to state 82
    COMMENT         shift and go to state 77
    PRINT           shift and go to state 83
    VAR             shift and go to state 14

    while                          shift and go to state 76
    funcall                        shift and go to state 78
    comment                        shift and go to state 64
    dowhile                        shift and go to state 80
    assignment                     shift and go to state 68
    statements                     shift and go to state 189
    statement                      shift and go to state 71
    print                          shift and go to state 72
    for                            shift and go to state 73
    condition                      shift and go to state 79
    var                            shift and go to state 75

state 149

    (30) print -> PRINT LPAREN STRING_CONS . RPAREN SEMI
    (94) exp -> STRING_CONS . settypestring pushcons
    (58) settypestring -> . empty
    (105) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 191
    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)

  ! RPAREN          [ reduce using rule 105 (empty -> .) ]

    settypestring                  shift and go to state 118
    empty                          shift and go to state 24

state 150

    (29) print -> PRINT LPAREN expression . RPAREN SEMI

    RPAREN          shift and go to state 192


state 151

    (31) print -> PRINT LPAREN ID . RPAREN SEMI
    (90) exp -> ID . pushdeclaredid
    (91) exp -> ID . LBRACK expression RBRACK pushdeclaredid
    (103) pushdeclaredid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 193
    LBRACK          shift and go to state 141
    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)

  ! RPAREN          [ reduce using rule 105 (empty -> .) ]

    empty                          shift and go to state 35
    pushtype                       shift and go to state 140
    pushdeclaredid                 shift and go to state 139

state 152

    (71) assignment -> ID pushid LBRACK . expression RBRACK EQUALS expression SEMI updatecell
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 194
    exp                            shift and go to state 97

state 153

    (70) assignment -> ID pushid EQUALS . expression SEMI updatevar
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 195
    exp                            shift and go to state 97

state 154

    (33) funcall -> ID pushid RPAREN . LPAREN assignvalues SEMI

    LPAREN          shift and go to state 196


state 155

    (32) funcall -> ID pushid LPAREN . startcount expression exparam RPAREN assignvalues SEMI
    (34) startcount -> . empty
    (105) empty -> .

    ID              reduce using rule 105 (empty -> .)
    LBRACK          reduce using rule 105 (empty -> .)
    INTEGER_CONS    reduce using rule 105 (empty -> .)
    STRING_CONS     reduce using rule 105 (empty -> .)
    FRACTION_CONS   reduce using rule 105 (empty -> .)
    DECIMAL_CONS    reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    EXMARK          reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 197
    startcount                     shift and go to state 198

state 156

    (53) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA . var1
    (51) var1 -> . ID pushid savevar allocatevar
    (52) var1 -> . ID pushid savevar allocatevar COMMA var1
    (53) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (54) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 33

    var1                           shift and go to state 199

state 157

    (45) condition -> IF LPAREN expression RPAREN . gotof blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> IF LPAREN expression RPAREN . gotof blocknortn updatejump
    (48) gotof -> . empty
    (105) empty -> .

    LBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 200
    gotof                          shift and go to state 201

state 158

    (100) exp -> LPAREN exp RPAREN .

    OR              reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    SAME            reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    DIF             reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    NE              reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    RBRACK          reduce using rule 100 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 100 (exp -> LPAREN exp RPAREN .)


state 159

    (95) exp -> FRACTION_CONS settypefrac pushcons .

    OR              reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    AND             reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    SAME            reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    DIF             reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    GE              reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    LE              reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    NE              reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    GT              reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    LT              reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    PLUS            reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    MINUS           reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    MODULO          reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    DIVIDE          reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    TIMES           reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    POWER           reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    SEMI            reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    RPAREN          reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    RBRACK          reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)
    COMMA           reduce using rule 95 (exp -> FRACTION_CONS settypefrac pushcons .)


state 160

    (104) pushcons -> pushtype .

    OR              reduce using rule 104 (pushcons -> pushtype .)
    AND             reduce using rule 104 (pushcons -> pushtype .)
    SAME            reduce using rule 104 (pushcons -> pushtype .)
    DIF             reduce using rule 104 (pushcons -> pushtype .)
    GE              reduce using rule 104 (pushcons -> pushtype .)
    LE              reduce using rule 104 (pushcons -> pushtype .)
    NE              reduce using rule 104 (pushcons -> pushtype .)
    GT              reduce using rule 104 (pushcons -> pushtype .)
    LT              reduce using rule 104 (pushcons -> pushtype .)
    PLUS            reduce using rule 104 (pushcons -> pushtype .)
    MINUS           reduce using rule 104 (pushcons -> pushtype .)
    MODULO          reduce using rule 104 (pushcons -> pushtype .)
    DIVIDE          reduce using rule 104 (pushcons -> pushtype .)
    TIMES           reduce using rule 104 (pushcons -> pushtype .)
    POWER           reduce using rule 104 (pushcons -> pushtype .)
    SEMI            reduce using rule 104 (pushcons -> pushtype .)
    RPAREN          reduce using rule 104 (pushcons -> pushtype .)
    RBRACK          reduce using rule 104 (pushcons -> pushtype .)
    COMMA           reduce using rule 104 (pushcons -> pushtype .)


state 161

    (98) exp -> FALSE settypebool pushcons .

    OR              reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    AND             reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    SAME            reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    DIF             reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    GE              reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    LE              reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    NE              reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    GT              reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    LT              reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    PLUS            reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    MINUS           reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    MODULO          reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    DIVIDE          reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    TIMES           reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    POWER           reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    SEMI            reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    RPAREN          reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    RBRACK          reduce using rule 98 (exp -> FALSE settypebool pushcons .)
    COMMA           reduce using rule 98 (exp -> FALSE settypebool pushcons .)


state 162

    (96) exp -> DECIMAL_CONS settypedec pushcons .

    OR              reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    AND             reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    SAME            reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    DIF             reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    GE              reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    LE              reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    NE              reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    GT              reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    LT              reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    PLUS            reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    MINUS           reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    MODULO          reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    DIVIDE          reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    TIMES           reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    POWER           reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    SEMI            reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    RPAREN          reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    RBRACK          reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)
    COMMA           reduce using rule 96 (exp -> DECIMAL_CONS settypedec pushcons .)


state 163

    (94) exp -> STRING_CONS settypestring pushcons .

    OR              reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    AND             reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    SAME            reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    DIF             reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    GE              reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    LE              reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    NE              reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    GT              reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    LT              reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    PLUS            reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    MINUS           reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    MODULO          reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    DIVIDE          reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    TIMES           reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    POWER           reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    SEMI            reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    RPAREN          reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    RBRACK          reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)
    COMMA           reduce using rule 94 (exp -> STRING_CONS settypestring pushcons .)


state 164

    (17) savereturn -> empty .

    RBRACE          reduce using rule 17 (savereturn -> empty .)


state 165

    (11) block -> LBRACE RETURN expression SEMI savereturn . RBRACE

    RBRACE          shift and go to state 202


state 166

    (92) exp -> LBRACK exp RBRACK .

    OR              reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    AND             reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    SAME            reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    DIF             reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    GE              reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    LE              reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    NE              reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    GT              reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    LT              reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    PLUS            reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    MINUS           reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    MODULO          reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    DIVIDE          reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    TIMES           reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    POWER           reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    SEMI            reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    RPAREN          reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    RBRACK          reduce using rule 92 (exp -> LBRACK exp RBRACK .)
    COMMA           reduce using rule 92 (exp -> LBRACK exp RBRACK .)


state 167

    (75) exp -> exp OR exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 75 (exp -> exp OR exp .)
    DIF             reduce using rule 75 (exp -> exp OR exp .)
    SEMI            reduce using rule 75 (exp -> exp OR exp .)
    RPAREN          reduce using rule 75 (exp -> exp OR exp .)
    RBRACK          reduce using rule 75 (exp -> exp OR exp .)
    COMMA           reduce using rule 75 (exp -> exp OR exp .)
    AND             shift and go to state 131
    SAME            shift and go to state 129
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! AND             [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! SAME            [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! GE              [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! LE              [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! NE              [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! PLUS            [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! MODULO          [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 75 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! DIF             [ shift and go to state 134 ]


state 168

    (80) exp -> exp LE exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 80 (exp -> exp LE exp .)
    AND             reduce using rule 80 (exp -> exp LE exp .)
    SAME            reduce using rule 80 (exp -> exp LE exp .)
    DIF             reduce using rule 80 (exp -> exp LE exp .)
    GE              reduce using rule 80 (exp -> exp LE exp .)
    LE              reduce using rule 80 (exp -> exp LE exp .)
    NE              reduce using rule 80 (exp -> exp LE exp .)
    GT              reduce using rule 80 (exp -> exp LE exp .)
    LT              reduce using rule 80 (exp -> exp LE exp .)
    SEMI            reduce using rule 80 (exp -> exp LE exp .)
    RPAREN          reduce using rule 80 (exp -> exp LE exp .)
    RBRACK          reduce using rule 80 (exp -> exp LE exp .)
    COMMA           reduce using rule 80 (exp -> exp LE exp .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! PLUS            [ reduce using rule 80 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 80 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 80 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 80 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 80 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 80 (exp -> exp LE exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]


state 169

    (87) exp -> exp DIVIDE exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 87 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 87 (exp -> exp DIVIDE exp .)
    SAME            reduce using rule 87 (exp -> exp DIVIDE exp .)
    DIF             reduce using rule 87 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 87 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 87 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 87 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 87 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 87 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 87 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 87 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 87 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 87 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 87 (exp -> exp DIVIDE exp .)
    SEMI            reduce using rule 87 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 87 (exp -> exp DIVIDE exp .)
    RBRACK          reduce using rule 87 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 87 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 133

  ! POWER           [ reduce using rule 87 (exp -> exp DIVIDE exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 125 ]
  ! MODULO          [ shift and go to state 132 ]
  ! DIVIDE          [ shift and go to state 124 ]
  ! TIMES           [ shift and go to state 135 ]


state 170

    (85) exp -> exp MINUS exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 85 (exp -> exp MINUS exp .)
    AND             reduce using rule 85 (exp -> exp MINUS exp .)
    SAME            reduce using rule 85 (exp -> exp MINUS exp .)
    DIF             reduce using rule 85 (exp -> exp MINUS exp .)
    GE              reduce using rule 85 (exp -> exp MINUS exp .)
    LE              reduce using rule 85 (exp -> exp MINUS exp .)
    NE              reduce using rule 85 (exp -> exp MINUS exp .)
    GT              reduce using rule 85 (exp -> exp MINUS exp .)
    LT              reduce using rule 85 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 85 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 85 (exp -> exp MINUS exp .)
    SEMI            reduce using rule 85 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 85 (exp -> exp MINUS exp .)
    RBRACK          reduce using rule 85 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 85 (exp -> exp MINUS exp .)
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! MODULO          [ reduce using rule 85 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 85 (exp -> exp MINUS exp .) ]
  ! TIMES           [ reduce using rule 85 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 85 (exp -> exp MINUS exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 125 ]


state 171

    (79) exp -> exp GE exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 79 (exp -> exp GE exp .)
    AND             reduce using rule 79 (exp -> exp GE exp .)
    SAME            reduce using rule 79 (exp -> exp GE exp .)
    DIF             reduce using rule 79 (exp -> exp GE exp .)
    GE              reduce using rule 79 (exp -> exp GE exp .)
    LE              reduce using rule 79 (exp -> exp GE exp .)
    NE              reduce using rule 79 (exp -> exp GE exp .)
    GT              reduce using rule 79 (exp -> exp GE exp .)
    LT              reduce using rule 79 (exp -> exp GE exp .)
    SEMI            reduce using rule 79 (exp -> exp GE exp .)
    RPAREN          reduce using rule 79 (exp -> exp GE exp .)
    RBRACK          reduce using rule 79 (exp -> exp GE exp .)
    COMMA           reduce using rule 79 (exp -> exp GE exp .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! PLUS            [ reduce using rule 79 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 79 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 79 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 79 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 79 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 79 (exp -> exp GE exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]


state 172

    (83) exp -> exp LT exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 83 (exp -> exp LT exp .)
    AND             reduce using rule 83 (exp -> exp LT exp .)
    SAME            reduce using rule 83 (exp -> exp LT exp .)
    DIF             reduce using rule 83 (exp -> exp LT exp .)
    GE              reduce using rule 83 (exp -> exp LT exp .)
    LE              reduce using rule 83 (exp -> exp LT exp .)
    NE              reduce using rule 83 (exp -> exp LT exp .)
    GT              reduce using rule 83 (exp -> exp LT exp .)
    LT              reduce using rule 83 (exp -> exp LT exp .)
    SEMI            reduce using rule 83 (exp -> exp LT exp .)
    RPAREN          reduce using rule 83 (exp -> exp LT exp .)
    RBRACK          reduce using rule 83 (exp -> exp LT exp .)
    COMMA           reduce using rule 83 (exp -> exp LT exp .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! PLUS            [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]


state 173

    (84) exp -> exp PLUS exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 84 (exp -> exp PLUS exp .)
    AND             reduce using rule 84 (exp -> exp PLUS exp .)
    SAME            reduce using rule 84 (exp -> exp PLUS exp .)
    DIF             reduce using rule 84 (exp -> exp PLUS exp .)
    GE              reduce using rule 84 (exp -> exp PLUS exp .)
    LE              reduce using rule 84 (exp -> exp PLUS exp .)
    NE              reduce using rule 84 (exp -> exp PLUS exp .)
    GT              reduce using rule 84 (exp -> exp PLUS exp .)
    LT              reduce using rule 84 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 84 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 84 (exp -> exp PLUS exp .)
    SEMI            reduce using rule 84 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 84 (exp -> exp PLUS exp .)
    RBRACK          reduce using rule 84 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 84 (exp -> exp PLUS exp .)
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! MODULO          [ reduce using rule 84 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 84 (exp -> exp PLUS exp .) ]
  ! TIMES           [ reduce using rule 84 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 84 (exp -> exp PLUS exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 125 ]


state 174

    (77) exp -> exp SAME exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 77 (exp -> exp SAME exp .)
    AND             reduce using rule 77 (exp -> exp SAME exp .)
    SAME            reduce using rule 77 (exp -> exp SAME exp .)
    DIF             reduce using rule 77 (exp -> exp SAME exp .)
    GE              reduce using rule 77 (exp -> exp SAME exp .)
    LE              reduce using rule 77 (exp -> exp SAME exp .)
    NE              reduce using rule 77 (exp -> exp SAME exp .)
    GT              reduce using rule 77 (exp -> exp SAME exp .)
    LT              reduce using rule 77 (exp -> exp SAME exp .)
    SEMI            reduce using rule 77 (exp -> exp SAME exp .)
    RPAREN          reduce using rule 77 (exp -> exp SAME exp .)
    RBRACK          reduce using rule 77 (exp -> exp SAME exp .)
    COMMA           reduce using rule 77 (exp -> exp SAME exp .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! PLUS            [ reduce using rule 77 (exp -> exp SAME exp .) ]
  ! MINUS           [ reduce using rule 77 (exp -> exp SAME exp .) ]
  ! MODULO          [ reduce using rule 77 (exp -> exp SAME exp .) ]
  ! DIVIDE          [ reduce using rule 77 (exp -> exp SAME exp .) ]
  ! TIMES           [ reduce using rule 77 (exp -> exp SAME exp .) ]
  ! POWER           [ reduce using rule 77 (exp -> exp SAME exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]


state 175

    (81) exp -> exp NE exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 81 (exp -> exp NE exp .)
    AND             reduce using rule 81 (exp -> exp NE exp .)
    SAME            reduce using rule 81 (exp -> exp NE exp .)
    DIF             reduce using rule 81 (exp -> exp NE exp .)
    GE              reduce using rule 81 (exp -> exp NE exp .)
    LE              reduce using rule 81 (exp -> exp NE exp .)
    NE              reduce using rule 81 (exp -> exp NE exp .)
    GT              reduce using rule 81 (exp -> exp NE exp .)
    LT              reduce using rule 81 (exp -> exp NE exp .)
    SEMI            reduce using rule 81 (exp -> exp NE exp .)
    RPAREN          reduce using rule 81 (exp -> exp NE exp .)
    RBRACK          reduce using rule 81 (exp -> exp NE exp .)
    COMMA           reduce using rule 81 (exp -> exp NE exp .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! PLUS            [ reduce using rule 81 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 81 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 81 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 81 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 81 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 81 (exp -> exp NE exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]


state 176

    (76) exp -> exp AND exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 76 (exp -> exp AND exp .)
    AND             reduce using rule 76 (exp -> exp AND exp .)
    DIF             reduce using rule 76 (exp -> exp AND exp .)
    SEMI            reduce using rule 76 (exp -> exp AND exp .)
    RPAREN          reduce using rule 76 (exp -> exp AND exp .)
    RBRACK          reduce using rule 76 (exp -> exp AND exp .)
    COMMA           reduce using rule 76 (exp -> exp AND exp .)
    SAME            shift and go to state 129
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! SAME            [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! GE              [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! LE              [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! NE              [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! PLUS            [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! MODULO          [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 76 (exp -> exp AND exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! DIF             [ shift and go to state 134 ]


state 177

    (86) exp -> exp MODULO exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 86 (exp -> exp MODULO exp .)
    AND             reduce using rule 86 (exp -> exp MODULO exp .)
    SAME            reduce using rule 86 (exp -> exp MODULO exp .)
    DIF             reduce using rule 86 (exp -> exp MODULO exp .)
    GE              reduce using rule 86 (exp -> exp MODULO exp .)
    LE              reduce using rule 86 (exp -> exp MODULO exp .)
    NE              reduce using rule 86 (exp -> exp MODULO exp .)
    GT              reduce using rule 86 (exp -> exp MODULO exp .)
    LT              reduce using rule 86 (exp -> exp MODULO exp .)
    PLUS            reduce using rule 86 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 86 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 86 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 86 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 86 (exp -> exp MODULO exp .)
    SEMI            reduce using rule 86 (exp -> exp MODULO exp .)
    RPAREN          reduce using rule 86 (exp -> exp MODULO exp .)
    RBRACK          reduce using rule 86 (exp -> exp MODULO exp .)
    COMMA           reduce using rule 86 (exp -> exp MODULO exp .)
    POWER           shift and go to state 133

  ! POWER           [ reduce using rule 86 (exp -> exp MODULO exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 125 ]
  ! MODULO          [ shift and go to state 132 ]
  ! DIVIDE          [ shift and go to state 124 ]
  ! TIMES           [ shift and go to state 135 ]


state 178

    (89) exp -> exp POWER exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 89 (exp -> exp POWER exp .)
    AND             reduce using rule 89 (exp -> exp POWER exp .)
    SAME            reduce using rule 89 (exp -> exp POWER exp .)
    DIF             reduce using rule 89 (exp -> exp POWER exp .)
    GE              reduce using rule 89 (exp -> exp POWER exp .)
    LE              reduce using rule 89 (exp -> exp POWER exp .)
    NE              reduce using rule 89 (exp -> exp POWER exp .)
    GT              reduce using rule 89 (exp -> exp POWER exp .)
    LT              reduce using rule 89 (exp -> exp POWER exp .)
    PLUS            reduce using rule 89 (exp -> exp POWER exp .)
    MINUS           reduce using rule 89 (exp -> exp POWER exp .)
    MODULO          reduce using rule 89 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 89 (exp -> exp POWER exp .)
    TIMES           reduce using rule 89 (exp -> exp POWER exp .)
    POWER           reduce using rule 89 (exp -> exp POWER exp .)
    SEMI            reduce using rule 89 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 89 (exp -> exp POWER exp .)
    RBRACK          reduce using rule 89 (exp -> exp POWER exp .)
    COMMA           reduce using rule 89 (exp -> exp POWER exp .)

  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 125 ]
  ! MODULO          [ shift and go to state 132 ]
  ! DIVIDE          [ shift and go to state 124 ]
  ! TIMES           [ shift and go to state 135 ]
  ! POWER           [ shift and go to state 133 ]


state 179

    (78) exp -> exp DIF exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for DIF resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    SEMI            reduce using rule 78 (exp -> exp DIF exp .)
    RPAREN          reduce using rule 78 (exp -> exp DIF exp .)
    RBRACK          reduce using rule 78 (exp -> exp DIF exp .)
    COMMA           reduce using rule 78 (exp -> exp DIF exp .)
    OR              shift and go to state 122
    AND             shift and go to state 131
    SAME            shift and go to state 129
    DIF             shift and go to state 134
    GE              shift and go to state 126
    LE              shift and go to state 123
    NE              shift and go to state 130
    GT              shift and go to state 136
    LT              shift and go to state 127
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! OR              [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! AND             [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! SAME            [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! DIF             [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! GE              [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! LE              [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! NE              [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! GT              [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! LT              [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! PLUS            [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! MINUS           [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! MODULO          [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! DIVIDE          [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! TIMES           [ reduce using rule 78 (exp -> exp DIF exp .) ]
  ! POWER           [ reduce using rule 78 (exp -> exp DIF exp .) ]


state 180

    (88) exp -> exp TIMES exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 88 (exp -> exp TIMES exp .)
    AND             reduce using rule 88 (exp -> exp TIMES exp .)
    SAME            reduce using rule 88 (exp -> exp TIMES exp .)
    DIF             reduce using rule 88 (exp -> exp TIMES exp .)
    GE              reduce using rule 88 (exp -> exp TIMES exp .)
    LE              reduce using rule 88 (exp -> exp TIMES exp .)
    NE              reduce using rule 88 (exp -> exp TIMES exp .)
    GT              reduce using rule 88 (exp -> exp TIMES exp .)
    LT              reduce using rule 88 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 88 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 88 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 88 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 88 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 88 (exp -> exp TIMES exp .)
    SEMI            reduce using rule 88 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 88 (exp -> exp TIMES exp .)
    RBRACK          reduce using rule 88 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 88 (exp -> exp TIMES exp .)
    POWER           shift and go to state 133

  ! POWER           [ reduce using rule 88 (exp -> exp TIMES exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 125 ]
  ! MODULO          [ shift and go to state 132 ]
  ! DIVIDE          [ shift and go to state 124 ]
  ! TIMES           [ shift and go to state 135 ]


state 181

    (82) exp -> exp GT exp .
    (75) exp -> exp . OR exp
    (76) exp -> exp . AND exp
    (77) exp -> exp . SAME exp
    (78) exp -> exp . DIF exp
    (79) exp -> exp . GE exp
    (80) exp -> exp . LE exp
    (81) exp -> exp . NE exp
    (82) exp -> exp . GT exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . PLUS exp
    (85) exp -> exp . MINUS exp
    (86) exp -> exp . MODULO exp
    (87) exp -> exp . DIVIDE exp
    (88) exp -> exp . TIMES exp
    (89) exp -> exp . POWER exp

    OR              reduce using rule 82 (exp -> exp GT exp .)
    AND             reduce using rule 82 (exp -> exp GT exp .)
    SAME            reduce using rule 82 (exp -> exp GT exp .)
    DIF             reduce using rule 82 (exp -> exp GT exp .)
    GE              reduce using rule 82 (exp -> exp GT exp .)
    LE              reduce using rule 82 (exp -> exp GT exp .)
    NE              reduce using rule 82 (exp -> exp GT exp .)
    GT              reduce using rule 82 (exp -> exp GT exp .)
    LT              reduce using rule 82 (exp -> exp GT exp .)
    SEMI            reduce using rule 82 (exp -> exp GT exp .)
    RPAREN          reduce using rule 82 (exp -> exp GT exp .)
    RBRACK          reduce using rule 82 (exp -> exp GT exp .)
    COMMA           reduce using rule 82 (exp -> exp GT exp .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 125
    MODULO          shift and go to state 132
    DIVIDE          shift and go to state 124
    TIMES           shift and go to state 135
    POWER           shift and go to state 133

  ! PLUS            [ reduce using rule 82 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 82 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 82 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 82 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 82 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 82 (exp -> exp GT exp .) ]
  ! OR              [ shift and go to state 122 ]
  ! AND             [ shift and go to state 131 ]
  ! SAME            [ shift and go to state 129 ]
  ! DIF             [ shift and go to state 134 ]
  ! GE              [ shift and go to state 126 ]
  ! LE              [ shift and go to state 123 ]
  ! NE              [ shift and go to state 130 ]
  ! GT              [ shift and go to state 136 ]
  ! LT              [ shift and go to state 127 ]


state 182

    (93) exp -> INTEGER_CONS settypeint pushcons .

    OR              reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    AND             reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    SAME            reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    DIF             reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    GE              reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    LE              reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    NE              reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    GT              reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    LT              reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    PLUS            reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    MINUS           reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    MODULO          reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    DIVIDE          reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    TIMES           reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    POWER           reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    SEMI            reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    RPAREN          reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    RBRACK          reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)
    COMMA           reduce using rule 93 (exp -> INTEGER_CONS settypeint pushcons .)


state 183

    (97) exp -> TRUE settypebool pushcons .

    OR              reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    AND             reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    SAME            reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    DIF             reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    GE              reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    LE              reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    NE              reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    GT              reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    LT              reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    PLUS            reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    MINUS           reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    MODULO          reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    DIVIDE          reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    TIMES           reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    POWER           reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    SEMI            reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    RPAREN          reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    RBRACK          reduce using rule 97 (exp -> TRUE settypebool pushcons .)
    COMMA           reduce using rule 97 (exp -> TRUE settypebool pushcons .)


state 184

    (91) exp -> ID LBRACK expression . RBRACK pushdeclaredid

    RBRACK          shift and go to state 203


state 185

    (10) block -> LBRACE statements RETURN expression SEMI . savereturn RBRACE
    (17) savereturn -> . empty
    (105) empty -> .

    RBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 164
    savereturn                     shift and go to state 204

state 186

    (39) for -> LPAREN assignment expression SEMI . expression RPAREN blocknortn
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 205
    exp                            shift and go to state 97

state 187

    (43) while -> WHILE pushjump LPAREN expression . RPAREN gotof blocknortn gotowhile

    RPAREN          shift and go to state 206


state 188

    (40) dowhile -> DO pushjump blocknortn WHILE . LPAREN expression RPAREN gotot

    LPAREN          shift and go to state 207


state 189

    (14) blocknortn -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 208


state 190

    (15) blocknortn -> LBRACE RBRACE .

    WHILE           reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    IF              reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    ID              reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    LPAREN          reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    DO              reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    COMMENT         reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    PRINT           reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    VAR             reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    RETURN          reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    RBRACE          reduce using rule 15 (blocknortn -> LBRACE RBRACE .)
    ELSE            reduce using rule 15 (blocknortn -> LBRACE RBRACE .)


state 191

    (30) print -> PRINT LPAREN STRING_CONS RPAREN . SEMI

    SEMI            shift and go to state 209


state 192

    (29) print -> PRINT LPAREN expression RPAREN . SEMI

    SEMI            shift and go to state 210


state 193

    (31) print -> PRINT LPAREN ID RPAREN . SEMI

    SEMI            shift and go to state 211


state 194

    (71) assignment -> ID pushid LBRACK expression . RBRACK EQUALS expression SEMI updatecell

    RBRACK          shift and go to state 212


state 195

    (70) assignment -> ID pushid EQUALS expression . SEMI updatevar

    SEMI            shift and go to state 213


state 196

    (33) funcall -> ID pushid RPAREN LPAREN . assignvalues SEMI
    (37) assignvalues -> . empty
    (105) empty -> .

    SEMI            reduce using rule 105 (empty -> .)

    empty                          shift and go to state 214
    assignvalues                   shift and go to state 215

state 197

    (34) startcount -> empty .

    ID              reduce using rule 34 (startcount -> empty .)
    LBRACK          reduce using rule 34 (startcount -> empty .)
    INTEGER_CONS    reduce using rule 34 (startcount -> empty .)
    STRING_CONS     reduce using rule 34 (startcount -> empty .)
    FRACTION_CONS   reduce using rule 34 (startcount -> empty .)
    DECIMAL_CONS    reduce using rule 34 (startcount -> empty .)
    TRUE            reduce using rule 34 (startcount -> empty .)
    FALSE           reduce using rule 34 (startcount -> empty .)
    EXMARK          reduce using rule 34 (startcount -> empty .)
    LPAREN          reduce using rule 34 (startcount -> empty .)


state 198

    (32) funcall -> ID pushid LPAREN startcount . expression exparam RPAREN assignvalues SEMI
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 216
    exp                            shift and go to state 97

state 199

    (53) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1 .

    SEMI            reduce using rule 53 (var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1 .)


state 200

    (48) gotof -> empty .

    LBRACE          reduce using rule 48 (gotof -> empty .)


state 201

    (45) condition -> IF LPAREN expression RPAREN gotof . blocknortn ELSE gotoif blocknortn updatejump
    (46) condition -> IF LPAREN expression RPAREN gotof . blocknortn updatejump
    (14) blocknortn -> . LBRACE statements RBRACE
    (15) blocknortn -> . LBRACE RBRACE

    LBRACE          shift and go to state 148

    blocknortn                     shift and go to state 217

state 202

    (11) block -> LBRACE RETURN expression SEMI savereturn RBRACE .

    BOOLEAN         reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)
    INTEGER         reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)
    DECIMAL         reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)
    STRING          reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)
    FRACTION        reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)
    VOID            reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)
    $end            reduce using rule 11 (block -> LBRACE RETURN expression SEMI savereturn RBRACE .)


state 203

    (91) exp -> ID LBRACK expression RBRACK . pushdeclaredid
    (103) pushdeclaredid -> . pushtype
    (101) pushtype -> . empty
    (105) empty -> .

    OR              reduce using rule 105 (empty -> .)
    AND             reduce using rule 105 (empty -> .)
    SAME            reduce using rule 105 (empty -> .)
    DIF             reduce using rule 105 (empty -> .)
    GE              reduce using rule 105 (empty -> .)
    LE              reduce using rule 105 (empty -> .)
    NE              reduce using rule 105 (empty -> .)
    GT              reduce using rule 105 (empty -> .)
    LT              reduce using rule 105 (empty -> .)
    PLUS            reduce using rule 105 (empty -> .)
    MINUS           reduce using rule 105 (empty -> .)
    MODULO          reduce using rule 105 (empty -> .)
    DIVIDE          reduce using rule 105 (empty -> .)
    TIMES           reduce using rule 105 (empty -> .)
    POWER           reduce using rule 105 (empty -> .)
    SEMI            reduce using rule 105 (empty -> .)
    RPAREN          reduce using rule 105 (empty -> .)
    RBRACK          reduce using rule 105 (empty -> .)
    COMMA           reduce using rule 105 (empty -> .)

    empty                          shift and go to state 35
    pushtype                       shift and go to state 140
    pushdeclaredid                 shift and go to state 218

state 204

    (10) block -> LBRACE statements RETURN expression SEMI savereturn . RBRACE

    RBRACE          shift and go to state 219


state 205

    (39) for -> LPAREN assignment expression SEMI expression . RPAREN blocknortn

    RPAREN          shift and go to state 220


state 206

    (43) while -> WHILE pushjump LPAREN expression RPAREN . gotof blocknortn gotowhile
    (48) gotof -> . empty
    (105) empty -> .

    LBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 200
    gotof                          shift and go to state 221

state 207

    (40) dowhile -> DO pushjump blocknortn WHILE LPAREN . expression RPAREN gotot
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 222
    exp                            shift and go to state 97

state 208

    (14) blocknortn -> LBRACE statements RBRACE .

    WHILE           reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    IF              reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    ID              reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    LPAREN          reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    DO              reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    COMMENT         reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    PRINT           reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    VAR             reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 14 (blocknortn -> LBRACE statements RBRACE .)


state 209

    (30) print -> PRINT LPAREN STRING_CONS RPAREN SEMI .

    IF              reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    ID              reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    WHILE           reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    LPAREN          reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    DO              reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    COMMENT         reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    PRINT           reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    VAR             reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    RETURN          reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)
    RBRACE          reduce using rule 30 (print -> PRINT LPAREN STRING_CONS RPAREN SEMI .)


state 210

    (29) print -> PRINT LPAREN expression RPAREN SEMI .

    IF              reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    ID              reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    WHILE           reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    LPAREN          reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    DO              reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    COMMENT         reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    PRINT           reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    VAR             reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    RETURN          reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)
    RBRACE          reduce using rule 29 (print -> PRINT LPAREN expression RPAREN SEMI .)


state 211

    (31) print -> PRINT LPAREN ID RPAREN SEMI .

    IF              reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    ID              reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    WHILE           reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    LPAREN          reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    DO              reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    COMMENT         reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    PRINT           reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    VAR             reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    RETURN          reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)
    RBRACE          reduce using rule 31 (print -> PRINT LPAREN ID RPAREN SEMI .)


state 212

    (71) assignment -> ID pushid LBRACK expression RBRACK . EQUALS expression SEMI updatecell

    EQUALS          shift and go to state 223


state 213

    (70) assignment -> ID pushid EQUALS expression SEMI . updatevar
    (73) updatevar -> . empty
    (105) empty -> .

    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)
    COMMENT         reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    VAR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RBRACE          reduce using rule 105 (empty -> .)
    LBRACK          reduce using rule 105 (empty -> .)
    INTEGER_CONS    reduce using rule 105 (empty -> .)
    STRING_CONS     reduce using rule 105 (empty -> .)
    FRACTION_CONS   reduce using rule 105 (empty -> .)
    DECIMAL_CONS    reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    EXMARK          reduce using rule 105 (empty -> .)

    updatevar                      shift and go to state 225
    empty                          shift and go to state 224

state 214

    (37) assignvalues -> empty .

    SEMI            reduce using rule 37 (assignvalues -> empty .)


state 215

    (33) funcall -> ID pushid RPAREN LPAREN assignvalues . SEMI

    SEMI            shift and go to state 226


state 216

    (32) funcall -> ID pushid LPAREN startcount expression . exparam RPAREN assignvalues SEMI
    (35) exparam -> . COMMA expression exparam
    (36) exparam -> . COMMA expression

    COMMA           shift and go to state 227

    exparam                        shift and go to state 228

state 217

    (45) condition -> IF LPAREN expression RPAREN gotof blocknortn . ELSE gotoif blocknortn updatejump
    (46) condition -> IF LPAREN expression RPAREN gotof blocknortn . updatejump
    (49) updatejump -> . empty
    (105) empty -> .

    ELSE            shift and go to state 230
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)
    COMMENT         reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    VAR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 229
    updatejump                     shift and go to state 231

state 218

    (91) exp -> ID LBRACK expression RBRACK pushdeclaredid .

    OR              reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    AND             reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    SAME            reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    DIF             reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    GE              reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    LE              reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    NE              reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    GT              reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    LT              reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    PLUS            reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    MINUS           reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    MODULO          reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    DIVIDE          reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    TIMES           reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    POWER           reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    SEMI            reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    RPAREN          reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    RBRACK          reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)
    COMMA           reduce using rule 91 (exp -> ID LBRACK expression RBRACK pushdeclaredid .)


state 219

    (10) block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .

    BOOLEAN         reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)
    INTEGER         reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)
    DECIMAL         reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)
    STRING          reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)
    FRACTION        reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)
    VOID            reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)
    $end            reduce using rule 10 (block -> LBRACE statements RETURN expression SEMI savereturn RBRACE .)


state 220

    (39) for -> LPAREN assignment expression SEMI expression RPAREN . blocknortn
    (14) blocknortn -> . LBRACE statements RBRACE
    (15) blocknortn -> . LBRACE RBRACE

    LBRACE          shift and go to state 148

    blocknortn                     shift and go to state 232

state 221

    (43) while -> WHILE pushjump LPAREN expression RPAREN gotof . blocknortn gotowhile
    (14) blocknortn -> . LBRACE statements RBRACE
    (15) blocknortn -> . LBRACE RBRACE

    LBRACE          shift and go to state 148

    blocknortn                     shift and go to state 233

state 222

    (40) dowhile -> DO pushjump blocknortn WHILE LPAREN expression . RPAREN gotot

    RPAREN          shift and go to state 234


state 223

    (71) assignment -> ID pushid LBRACK expression RBRACK EQUALS . expression SEMI updatecell
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 235
    exp                            shift and go to state 97

state 224

    (73) updatevar -> empty .

    IF              reduce using rule 73 (updatevar -> empty .)
    ID              reduce using rule 73 (updatevar -> empty .)
    WHILE           reduce using rule 73 (updatevar -> empty .)
    LPAREN          reduce using rule 73 (updatevar -> empty .)
    DO              reduce using rule 73 (updatevar -> empty .)
    COMMENT         reduce using rule 73 (updatevar -> empty .)
    PRINT           reduce using rule 73 (updatevar -> empty .)
    VAR             reduce using rule 73 (updatevar -> empty .)
    RETURN          reduce using rule 73 (updatevar -> empty .)
    RBRACE          reduce using rule 73 (updatevar -> empty .)
    LBRACK          reduce using rule 73 (updatevar -> empty .)
    INTEGER_CONS    reduce using rule 73 (updatevar -> empty .)
    STRING_CONS     reduce using rule 73 (updatevar -> empty .)
    FRACTION_CONS   reduce using rule 73 (updatevar -> empty .)
    DECIMAL_CONS    reduce using rule 73 (updatevar -> empty .)
    TRUE            reduce using rule 73 (updatevar -> empty .)
    FALSE           reduce using rule 73 (updatevar -> empty .)
    EXMARK          reduce using rule 73 (updatevar -> empty .)


state 225

    (70) assignment -> ID pushid EQUALS expression SEMI updatevar .

    IF              reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    ID              reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    WHILE           reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    LPAREN          reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    DO              reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    COMMENT         reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    PRINT           reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    VAR             reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    RETURN          reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    RBRACE          reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    LBRACK          reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    INTEGER_CONS    reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    STRING_CONS     reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    FRACTION_CONS   reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    DECIMAL_CONS    reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    TRUE            reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    FALSE           reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    EXMARK          reduce using rule 70 (assignment -> ID pushid EQUALS expression SEMI updatevar .)


state 226

    (33) funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .

    IF              reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    ID              reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    WHILE           reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    LPAREN          reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    DO              reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    COMMENT         reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    PRINT           reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    VAR             reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    RETURN          reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)
    RBRACE          reduce using rule 33 (funcall -> ID pushid RPAREN LPAREN assignvalues SEMI .)


state 227

    (35) exparam -> COMMA . expression exparam
    (36) exparam -> COMMA . expression
    (74) expression -> . exp
    (75) exp -> . exp OR exp
    (76) exp -> . exp AND exp
    (77) exp -> . exp SAME exp
    (78) exp -> . exp DIF exp
    (79) exp -> . exp GE exp
    (80) exp -> . exp LE exp
    (81) exp -> . exp NE exp
    (82) exp -> . exp GT exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp PLUS exp
    (85) exp -> . exp MINUS exp
    (86) exp -> . exp MODULO exp
    (87) exp -> . exp DIVIDE exp
    (88) exp -> . exp TIMES exp
    (89) exp -> . exp POWER exp
    (90) exp -> . ID pushdeclaredid
    (91) exp -> . ID LBRACK expression RBRACK pushdeclaredid
    (92) exp -> . LBRACK exp RBRACK
    (93) exp -> . INTEGER_CONS settypeint pushcons
    (94) exp -> . STRING_CONS settypestring pushcons
    (95) exp -> . FRACTION_CONS settypefrac pushcons
    (96) exp -> . DECIMAL_CONS settypedec pushcons
    (97) exp -> . TRUE settypebool pushcons
    (98) exp -> . FALSE settypebool pushcons
    (99) exp -> . EXMARK exp
    (100) exp -> . LPAREN exp RPAREN

    ID              shift and go to state 100
    LBRACK          shift and go to state 96
    INTEGER_CONS    shift and go to state 98
    STRING_CONS     shift and go to state 93
    FRACTION_CONS   shift and go to state 90
    DECIMAL_CONS    shift and go to state 92
    TRUE            shift and go to state 99
    FALSE           shift and go to state 91
    EXMARK          shift and go to state 94
    LPAREN          shift and go to state 89

    expression                     shift and go to state 236
    exp                            shift and go to state 97

state 228

    (32) funcall -> ID pushid LPAREN startcount expression exparam . RPAREN assignvalues SEMI

    RPAREN          shift and go to state 237


state 229

    (49) updatejump -> empty .

    IF              reduce using rule 49 (updatejump -> empty .)
    ID              reduce using rule 49 (updatejump -> empty .)
    WHILE           reduce using rule 49 (updatejump -> empty .)
    LPAREN          reduce using rule 49 (updatejump -> empty .)
    DO              reduce using rule 49 (updatejump -> empty .)
    COMMENT         reduce using rule 49 (updatejump -> empty .)
    PRINT           reduce using rule 49 (updatejump -> empty .)
    VAR             reduce using rule 49 (updatejump -> empty .)
    RETURN          reduce using rule 49 (updatejump -> empty .)
    RBRACE          reduce using rule 49 (updatejump -> empty .)


state 230

    (45) condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE . gotoif blocknortn updatejump
    (47) gotoif -> . empty
    (105) empty -> .

    LBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 238
    gotoif                         shift and go to state 239

state 231

    (46) condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .

    IF              reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    ID              reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    WHILE           reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    LPAREN          reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    DO              reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    COMMENT         reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    PRINT           reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    VAR             reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    RETURN          reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)
    RBRACE          reduce using rule 46 (condition -> IF LPAREN expression RPAREN gotof blocknortn updatejump .)


state 232

    (39) for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .

    IF              reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    ID              reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    WHILE           reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    LPAREN          reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    DO              reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    COMMENT         reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    PRINT           reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    VAR             reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    RETURN          reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)
    RBRACE          reduce using rule 39 (for -> LPAREN assignment expression SEMI expression RPAREN blocknortn .)


state 233

    (43) while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn . gotowhile
    (44) gotowhile -> . empty
    (105) empty -> .

    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)
    COMMENT         reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    VAR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RBRACE          reduce using rule 105 (empty -> .)

    gotowhile                      shift and go to state 240
    empty                          shift and go to state 241

state 234

    (40) dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN . gotot
    (42) gotot -> . empty
    (105) empty -> .

    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)
    COMMENT         reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    VAR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RBRACE          reduce using rule 105 (empty -> .)

    gotot                          shift and go to state 243
    empty                          shift and go to state 242

state 235

    (71) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression . SEMI updatecell

    SEMI            shift and go to state 244


state 236

    (35) exparam -> COMMA expression . exparam
    (36) exparam -> COMMA expression .
    (35) exparam -> . COMMA expression exparam
    (36) exparam -> . COMMA expression

    RPAREN          reduce using rule 36 (exparam -> COMMA expression .)
    COMMA           shift and go to state 227

    exparam                        shift and go to state 245

state 237

    (32) funcall -> ID pushid LPAREN startcount expression exparam RPAREN . assignvalues SEMI
    (37) assignvalues -> . empty
    (105) empty -> .

    SEMI            reduce using rule 105 (empty -> .)

    empty                          shift and go to state 214
    assignvalues                   shift and go to state 246

state 238

    (47) gotoif -> empty .

    LBRACE          reduce using rule 47 (gotoif -> empty .)


state 239

    (45) condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif . blocknortn updatejump
    (14) blocknortn -> . LBRACE statements RBRACE
    (15) blocknortn -> . LBRACE RBRACE

    LBRACE          shift and go to state 148

    blocknortn                     shift and go to state 247

state 240

    (43) while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .

    IF              reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    ID              reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    WHILE           reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    LPAREN          reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    DO              reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    COMMENT         reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    PRINT           reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    VAR             reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    RETURN          reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)
    RBRACE          reduce using rule 43 (while -> WHILE pushjump LPAREN expression RPAREN gotof blocknortn gotowhile .)


state 241

    (44) gotowhile -> empty .

    IF              reduce using rule 44 (gotowhile -> empty .)
    ID              reduce using rule 44 (gotowhile -> empty .)
    WHILE           reduce using rule 44 (gotowhile -> empty .)
    LPAREN          reduce using rule 44 (gotowhile -> empty .)
    DO              reduce using rule 44 (gotowhile -> empty .)
    COMMENT         reduce using rule 44 (gotowhile -> empty .)
    PRINT           reduce using rule 44 (gotowhile -> empty .)
    VAR             reduce using rule 44 (gotowhile -> empty .)
    RETURN          reduce using rule 44 (gotowhile -> empty .)
    RBRACE          reduce using rule 44 (gotowhile -> empty .)


state 242

    (42) gotot -> empty .

    IF              reduce using rule 42 (gotot -> empty .)
    ID              reduce using rule 42 (gotot -> empty .)
    WHILE           reduce using rule 42 (gotot -> empty .)
    LPAREN          reduce using rule 42 (gotot -> empty .)
    DO              reduce using rule 42 (gotot -> empty .)
    COMMENT         reduce using rule 42 (gotot -> empty .)
    PRINT           reduce using rule 42 (gotot -> empty .)
    VAR             reduce using rule 42 (gotot -> empty .)
    RETURN          reduce using rule 42 (gotot -> empty .)
    RBRACE          reduce using rule 42 (gotot -> empty .)


state 243

    (40) dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .

    IF              reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    ID              reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    WHILE           reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    LPAREN          reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    DO              reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    COMMENT         reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    PRINT           reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    VAR             reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    RETURN          reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)
    RBRACE          reduce using rule 40 (dowhile -> DO pushjump blocknortn WHILE LPAREN expression RPAREN gotot .)


state 244

    (71) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI . updatecell
    (72) updatecell -> . empty
    (105) empty -> .

    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)
    COMMENT         reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    VAR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RBRACE          reduce using rule 105 (empty -> .)
    LBRACK          reduce using rule 105 (empty -> .)
    INTEGER_CONS    reduce using rule 105 (empty -> .)
    STRING_CONS     reduce using rule 105 (empty -> .)
    FRACTION_CONS   reduce using rule 105 (empty -> .)
    DECIMAL_CONS    reduce using rule 105 (empty -> .)
    TRUE            reduce using rule 105 (empty -> .)
    FALSE           reduce using rule 105 (empty -> .)
    EXMARK          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 248
    updatecell                     shift and go to state 249

state 245

    (35) exparam -> COMMA expression exparam .

    RPAREN          reduce using rule 35 (exparam -> COMMA expression exparam .)


state 246

    (32) funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues . SEMI

    SEMI            shift and go to state 250


state 247

    (45) condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn . updatejump
    (49) updatejump -> . empty
    (105) empty -> .

    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    LPAREN          reduce using rule 105 (empty -> .)
    DO              reduce using rule 105 (empty -> .)
    COMMENT         reduce using rule 105 (empty -> .)
    PRINT           reduce using rule 105 (empty -> .)
    VAR             reduce using rule 105 (empty -> .)
    RETURN          reduce using rule 105 (empty -> .)
    RBRACE          reduce using rule 105 (empty -> .)

    empty                          shift and go to state 229
    updatejump                     shift and go to state 251

state 248

    (72) updatecell -> empty .

    IF              reduce using rule 72 (updatecell -> empty .)
    ID              reduce using rule 72 (updatecell -> empty .)
    WHILE           reduce using rule 72 (updatecell -> empty .)
    LPAREN          reduce using rule 72 (updatecell -> empty .)
    DO              reduce using rule 72 (updatecell -> empty .)
    COMMENT         reduce using rule 72 (updatecell -> empty .)
    PRINT           reduce using rule 72 (updatecell -> empty .)
    VAR             reduce using rule 72 (updatecell -> empty .)
    RETURN          reduce using rule 72 (updatecell -> empty .)
    RBRACE          reduce using rule 72 (updatecell -> empty .)
    LBRACK          reduce using rule 72 (updatecell -> empty .)
    INTEGER_CONS    reduce using rule 72 (updatecell -> empty .)
    STRING_CONS     reduce using rule 72 (updatecell -> empty .)
    FRACTION_CONS   reduce using rule 72 (updatecell -> empty .)
    DECIMAL_CONS    reduce using rule 72 (updatecell -> empty .)
    TRUE            reduce using rule 72 (updatecell -> empty .)
    FALSE           reduce using rule 72 (updatecell -> empty .)
    EXMARK          reduce using rule 72 (updatecell -> empty .)


state 249

    (71) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .

    IF              reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    ID              reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    WHILE           reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    LPAREN          reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    DO              reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    COMMENT         reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    PRINT           reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    VAR             reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    RETURN          reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    RBRACE          reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    LBRACK          reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    INTEGER_CONS    reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    STRING_CONS     reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    FRACTION_CONS   reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    DECIMAL_CONS    reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    TRUE            reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    FALSE           reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    EXMARK          reduce using rule 71 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)


state 250

    (32) funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .

    IF              reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    ID              reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    WHILE           reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    LPAREN          reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    DO              reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    COMMENT         reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    PRINT           reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    VAR             reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    RETURN          reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)
    RBRACE          reduce using rule 32 (funcall -> ID pushid LPAREN startcount expression exparam RPAREN assignvalues SEMI .)


state 251

    (45) condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .

    IF              reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    ID              reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    WHILE           reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    LPAREN          reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    DO              reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    COMMENT         reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    PRINT           reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    VAR             reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    RETURN          reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)
    RBRACE          reduce using rule 45 (condition -> IF LPAREN expression RPAREN gotof blocknortn ELSE gotoif blocknortn updatejump .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 149 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 179 resolved as shift
WARNING: shift/reduce conflict for AND in state 179 resolved as shift
WARNING: shift/reduce conflict for SAME in state 179 resolved as shift
WARNING: shift/reduce conflict for DIF in state 179 resolved as shift
WARNING: shift/reduce conflict for GE in state 179 resolved as shift
WARNING: shift/reduce conflict for LE in state 179 resolved as shift
WARNING: shift/reduce conflict for NE in state 179 resolved as shift
WARNING: shift/reduce conflict for GT in state 179 resolved as shift
WARNING: shift/reduce conflict for LT in state 179 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 179 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 179 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 179 resolved as shift
WARNING: shift/reduce conflict for POWER in state 179 resolved as shift

Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    FOR
    COMMENT
    RQUOTE
    COLON
    NEWLINE
    LQUOTE
    NOT

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMI gotomain program1
Rule 2     program -> PROGRAM ID SEMI gotomain var program1
Rule 3     gotomain -> empty
Rule 4     program1 -> function program1
Rule 5     program1 -> function
Rule 6     function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
Rule 7     function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
Rule 8     setcontext -> empty
Rule 9     endfunc -> empty
Rule 10    savefunc -> empty
Rule 11    parameter -> type ID pushid
Rule 12    parameter -> type ID pushid COMMA parameter
Rule 13    block -> LBRACE var vartoparam statements RBRACE deletelocal
Rule 14    block -> LBRACE var vartoparam RBRACE deletelocal
Rule 15    deletelocal -> empty
Rule 16    vartoparam -> empty
Rule 17    block -> LBRACE statements RBRACE
Rule 18    block -> LBRACE RBRACE
Rule 19    simpleblock -> LBRACE statements RBRACE
Rule 20    simpleblock -> LBRACE RBRACE
Rule 21    savereturn -> empty
Rule 22    statements -> statement
Rule 23    statements -> statement statements
Rule 24    statement -> condition
Rule 25    statement -> assignment
Rule 26    statement -> while
Rule 27    statement -> for
Rule 28    statement -> dowhile
Rule 29    statement -> print SEMI
Rule 30    statement -> funcall SEMI
Rule 31    statement -> return SEMI
Rule 32    statement -> input SEMI
Rule 33    input -> INPUT ID pushdeclaredid
Rule 34    return -> RETURN expression savereturn
Rule 35    return -> RETURN savereturn
Rule 36    print -> PRINT expression
Rule 37    funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
Rule 38    funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues
Rule 39    eragener -> empty
Rule 40    startcount -> empty
Rule 41    updatecount -> empty
Rule 42    exparam -> expression updatecount
Rule 43    exparam -> expression updatecount COMMA exparam
Rule 44    assignvalues -> empty
Rule 45    for -> LPAREN assignment expression SEMI expression RPAREN simpleblock
Rule 46    dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
Rule 47    pushjump -> empty
Rule 48    gotot -> empty
Rule 49    while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
Rule 50    gotowhile -> empty
Rule 51    condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
Rule 52    condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump
Rule 53    gotoif -> empty
Rule 54    gotof -> empty
Rule 55    updatejump -> empty
Rule 56    var -> VAR type var1 SEMI var
Rule 57    var -> VAR type var1 SEMI
Rule 58    var1 -> ID pushid savevar allocatevar
Rule 59    var1 -> ID pushid savevar allocatevar COMMA var1
Rule 60    var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
Rule 61    var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
Rule 62    settypeint -> empty
Rule 63    settypedec -> empty
Rule 64    settypefrac -> empty
Rule 65    settypestring -> empty
Rule 66    settypebool -> empty
Rule 67    settypevoid -> empty
Rule 68    savevar -> empty
Rule 69    allocatevar -> empty
Rule 70    updatesize -> empty
Rule 71    type -> BOOLEAN settypebool
Rule 72    type -> INTEGER settypeint
Rule 73    type -> DECIMAL settypedec
Rule 74    type -> STRING settypestring
Rule 75    type -> FRACTION settypefrac
Rule 76    type -> VOID settypevoid
Rule 77    assignment -> ID pushid EQUALS expression SEMI updatevar
Rule 78    assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
Rule 79    updatecell -> empty
Rule 80    updatevar -> empty
Rule 81    expression -> exp
Rule 82    exp -> exp OR exp
Rule 83    exp -> exp AND exp
Rule 84    exp -> exp SAME exp
Rule 85    exp -> exp DIF exp
Rule 86    exp -> exp GE exp
Rule 87    exp -> exp LE exp
Rule 88    exp -> exp NE exp
Rule 89    exp -> exp GT exp
Rule 90    exp -> exp LT exp
Rule 91    exp -> exp PLUS exp
Rule 92    exp -> exp MINUS exp
Rule 93    exp -> exp MODULO exp
Rule 94    exp -> exp DIVIDE exp
Rule 95    exp -> exp TIMES exp
Rule 96    exp -> exp POWER exp
Rule 97    exp -> ID pushdeclaredid
Rule 98    exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
Rule 99    exp -> LBRACK exp RBRACK
Rule 100   exp -> INTEGER_CONS settypeint pushcons
Rule 101   exp -> STRING_CONS settypestring pushcons
Rule 102   exp -> FRACTION_CONS settypefrac pushcons
Rule 103   exp -> DECIMAL_CONS settypedec pushcons
Rule 104   exp -> TRUE settypebool pushcons
Rule 105   exp -> FALSE settypebool pushcons
Rule 106   exp -> EXMARK exp
Rule 107   exp -> LPAREN exp RPAREN
Rule 108   exp -> funcall pushrtn
Rule 109   pushrtn -> empty
Rule 110   pushtype -> empty
Rule 111   pushid -> pushtype
Rule 112   pushdeclaredid -> pushtype
Rule 113   pushdeclaredarray -> pushtype
Rule 114   pushcons -> pushtype
Rule 115   empty -> <empty>

Terminals, with rules where they appear

AND                  : 83
BOOLEAN              : 71
CALL                 : 37 38
COLON                : 
COMMA                : 12 43 59 60
COMMENT              : 
DECIMAL              : 73
DECIMAL_CONS         : 103
DIF                  : 85
DIVIDE               : 94
DO                   : 46
ELSE                 : 51
EQUALS               : 77 78
EXMARK               : 106
FALSE                : 105
FOR                  : 
FRACTION             : 75
FRACTION_CONS        : 102
FUNCTION             : 6 7
GE                   : 86
GT                   : 89
ID                   : 1 2 6 7 11 12 33 37 38 58 59 60 61 77 78 97 98
IF                   : 51 52
INPUT                : 33
INTEGER              : 72
INTEGER_CONS         : 60 61 100
LBRACE               : 13 14 17 18 19 20
LBRACK               : 60 61 78 98 99
LE                   : 87
LPAREN               : 6 7 37 38 45 46 49 51 52 107
LQUOTE               : 
LT                   : 90
MINUS                : 92
MODULO               : 93
NE                   : 88
NEWLINE              : 
NOT                  : 
OR                   : 82
PLUS                 : 91
POWER                : 96
PRINT                : 36
PROGRAM              : 1 2
RBRACE               : 13 14 17 18 19 20
RBRACK               : 60 61 78 98 99
RETURN               : 34 35
RPAREN               : 6 7 37 38 45 46 49 51 52 107
RQUOTE               : 
SAME                 : 84
SEMI                 : 1 2 29 30 31 32 45 56 57 77 78
STRING               : 74
STRING_CONS          : 101
TIMES                : 95
TRUE                 : 104
VAR                  : 56 57
VOID                 : 76
WHILE                : 46 49
error                : 

Nonterminals, with rules where they appear

allocatevar          : 58 59 60 61
assignment           : 25 45
assignvalues         : 37 38
block                : 6 7
condition            : 24
deletelocal          : 13 14
dowhile              : 28
empty                : 3 8 9 10 15 16 21 39 40 41 44 47 48 50 53 54 55 62 63 64 65 66 67 68 69 70 79 80 109 110
endfunc              : 6 7
eragener             : 37 38
exp                  : 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 99 106 107
exparam              : 37 43
expression           : 34 36 42 43 45 45 46 49 51 52 77 78 78 98
for                  : 27
funcall              : 30 108
function             : 4 5
gotof                : 49 51 52
gotoif               : 51
gotomain             : 1 2
gotot                : 46
gotowhile            : 49
input                : 32
parameter            : 6 12
print                : 29
program              : 0
program1             : 1 2 4
pushcons             : 100 101 102 103 104 105
pushdeclaredarray    : 98
pushdeclaredid       : 33 97 98
pushid               : 6 7 11 12 37 38 58 59 60 61 77 78
pushjump             : 46 49
pushrtn              : 108
pushtype             : 111 112 113 114
return               : 31
savefunc             : 6 7
savereturn           : 34 35
savevar              : 58 59 60 61
setcontext           : 6 7
settypebool          : 71 104 105
settypedec           : 73 103
settypefrac          : 75 102
settypeint           : 72 100
settypestring        : 74 101
settypevoid          : 76
simpleblock          : 45 46 49 51 51 52
startcount           : 37
statement            : 22 23
statements           : 13 17 19 23
type                 : 6 7 11 12 56 57
updatecell           : 78
updatecount          : 42 43
updatejump           : 51 52
updatesize           : 60 61
updatevar            : 77
var                  : 2 13 14 56
var1                 : 56 57 59 60
vartoparam           : 13 14
while                : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMI gotomain program1
    (2) program -> . PROGRAM ID SEMI gotomain var program1

    PROGRAM         shift and go to state 1

    program                        shift and go to state 2

state 1

    (1) program -> PROGRAM . ID SEMI gotomain program1
    (2) program -> PROGRAM . ID SEMI gotomain var program1

    ID              shift and go to state 3


state 2

    (0) S' -> program .



state 3

    (1) program -> PROGRAM ID . SEMI gotomain program1
    (2) program -> PROGRAM ID . SEMI gotomain var program1

    SEMI            shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMI . gotomain program1
    (2) program -> PROGRAM ID SEMI . gotomain var program1
    (3) gotomain -> . empty
    (115) empty -> .

    VAR             reduce using rule 115 (empty -> .)
    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)

    gotomain                       shift and go to state 6
    empty                          shift and go to state 5

state 5

    (3) gotomain -> empty .

    VAR             reduce using rule 3 (gotomain -> empty .)
    BOOLEAN         reduce using rule 3 (gotomain -> empty .)
    INTEGER         reduce using rule 3 (gotomain -> empty .)
    DECIMAL         reduce using rule 3 (gotomain -> empty .)
    STRING          reduce using rule 3 (gotomain -> empty .)
    FRACTION        reduce using rule 3 (gotomain -> empty .)
    VOID            reduce using rule 3 (gotomain -> empty .)


state 6

    (1) program -> PROGRAM ID SEMI gotomain . program1
    (2) program -> PROGRAM ID SEMI gotomain . var program1
    (4) program1 -> . function program1
    (5) program1 -> . function
    (56) var -> . VAR type var1 SEMI var
    (57) var -> . VAR type var1 SEMI
    (6) function -> . type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> . type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    VAR             shift and go to state 11
    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 9
    DECIMAL         shift and go to state 7
    STRING          shift and go to state 16
    FRACTION        shift and go to state 10
    VOID            shift and go to state 15

    program1                       shift and go to state 12
    type                           shift and go to state 13
    function                       shift and go to state 8
    var                            shift and go to state 17

state 7

    (73) type -> DECIMAL . settypedec
    (63) settypedec -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    settypedec                     shift and go to state 18
    empty                          shift and go to state 19

state 8

    (4) program1 -> function . program1
    (5) program1 -> function .
    (4) program1 -> . function program1
    (5) program1 -> . function
    (6) function -> . type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> . type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    $end            reduce using rule 5 (program1 -> function .)
    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 9
    DECIMAL         shift and go to state 7
    STRING          shift and go to state 16
    FRACTION        shift and go to state 10
    VOID            shift and go to state 15

    program1                       shift and go to state 20
    type                           shift and go to state 13
    function                       shift and go to state 8

state 9

    (72) type -> INTEGER . settypeint
    (62) settypeint -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    settypeint                     shift and go to state 21
    empty                          shift and go to state 22

state 10

    (75) type -> FRACTION . settypefrac
    (64) settypefrac -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    settypefrac                    shift and go to state 23
    empty                          shift and go to state 24

state 11

    (56) var -> VAR . type var1 SEMI var
    (57) var -> VAR . type var1 SEMI
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 9
    DECIMAL         shift and go to state 7
    STRING          shift and go to state 16
    FRACTION        shift and go to state 10
    VOID            shift and go to state 15

    type                           shift and go to state 25

state 12

    (1) program -> PROGRAM ID SEMI gotomain program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMI gotomain program1 .)


state 13

    (6) function -> type . FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type . FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc

    FUNCTION        shift and go to state 26


state 14

    (71) type -> BOOLEAN . settypebool
    (66) settypebool -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    settypebool                    shift and go to state 27
    empty                          shift and go to state 28

state 15

    (76) type -> VOID . settypevoid
    (67) settypevoid -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    settypevoid                    shift and go to state 29
    empty                          shift and go to state 30

state 16

    (74) type -> STRING . settypestring
    (65) settypestring -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    settypestring                  shift and go to state 31
    empty                          shift and go to state 32

state 17

    (2) program -> PROGRAM ID SEMI gotomain var . program1
    (4) program1 -> . function program1
    (5) program1 -> . function
    (6) function -> . type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> . type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 9
    DECIMAL         shift and go to state 7
    STRING          shift and go to state 16
    FRACTION        shift and go to state 10
    VOID            shift and go to state 15

    program1                       shift and go to state 33
    type                           shift and go to state 13
    function                       shift and go to state 8

state 18

    (73) type -> DECIMAL settypedec .

    ID              reduce using rule 73 (type -> DECIMAL settypedec .)
    FUNCTION        reduce using rule 73 (type -> DECIMAL settypedec .)


state 19

    (63) settypedec -> empty .

    OR              reduce using rule 63 (settypedec -> empty .)
    AND             reduce using rule 63 (settypedec -> empty .)
    SAME            reduce using rule 63 (settypedec -> empty .)
    DIF             reduce using rule 63 (settypedec -> empty .)
    GE              reduce using rule 63 (settypedec -> empty .)
    LE              reduce using rule 63 (settypedec -> empty .)
    NE              reduce using rule 63 (settypedec -> empty .)
    GT              reduce using rule 63 (settypedec -> empty .)
    LT              reduce using rule 63 (settypedec -> empty .)
    PLUS            reduce using rule 63 (settypedec -> empty .)
    MINUS           reduce using rule 63 (settypedec -> empty .)
    MODULO          reduce using rule 63 (settypedec -> empty .)
    DIVIDE          reduce using rule 63 (settypedec -> empty .)
    TIMES           reduce using rule 63 (settypedec -> empty .)
    POWER           reduce using rule 63 (settypedec -> empty .)
    SEMI            reduce using rule 63 (settypedec -> empty .)
    RPAREN          reduce using rule 63 (settypedec -> empty .)
    RBRACK          reduce using rule 63 (settypedec -> empty .)
    COMMA           reduce using rule 63 (settypedec -> empty .)
    FUNCTION        reduce using rule 63 (settypedec -> empty .)
    ID              reduce using rule 63 (settypedec -> empty .)


state 20

    (4) program1 -> function program1 .

    $end            reduce using rule 4 (program1 -> function program1 .)


state 21

    (72) type -> INTEGER settypeint .

    ID              reduce using rule 72 (type -> INTEGER settypeint .)
    FUNCTION        reduce using rule 72 (type -> INTEGER settypeint .)


state 22

    (62) settypeint -> empty .

    OR              reduce using rule 62 (settypeint -> empty .)
    AND             reduce using rule 62 (settypeint -> empty .)
    SAME            reduce using rule 62 (settypeint -> empty .)
    DIF             reduce using rule 62 (settypeint -> empty .)
    GE              reduce using rule 62 (settypeint -> empty .)
    LE              reduce using rule 62 (settypeint -> empty .)
    NE              reduce using rule 62 (settypeint -> empty .)
    GT              reduce using rule 62 (settypeint -> empty .)
    LT              reduce using rule 62 (settypeint -> empty .)
    PLUS            reduce using rule 62 (settypeint -> empty .)
    MINUS           reduce using rule 62 (settypeint -> empty .)
    MODULO          reduce using rule 62 (settypeint -> empty .)
    DIVIDE          reduce using rule 62 (settypeint -> empty .)
    TIMES           reduce using rule 62 (settypeint -> empty .)
    POWER           reduce using rule 62 (settypeint -> empty .)
    SEMI            reduce using rule 62 (settypeint -> empty .)
    RPAREN          reduce using rule 62 (settypeint -> empty .)
    RBRACK          reduce using rule 62 (settypeint -> empty .)
    COMMA           reduce using rule 62 (settypeint -> empty .)
    FUNCTION        reduce using rule 62 (settypeint -> empty .)
    ID              reduce using rule 62 (settypeint -> empty .)


state 23

    (75) type -> FRACTION settypefrac .

    ID              reduce using rule 75 (type -> FRACTION settypefrac .)
    FUNCTION        reduce using rule 75 (type -> FRACTION settypefrac .)


state 24

    (64) settypefrac -> empty .

    FUNCTION        reduce using rule 64 (settypefrac -> empty .)
    ID              reduce using rule 64 (settypefrac -> empty .)
    OR              reduce using rule 64 (settypefrac -> empty .)
    AND             reduce using rule 64 (settypefrac -> empty .)
    SAME            reduce using rule 64 (settypefrac -> empty .)
    DIF             reduce using rule 64 (settypefrac -> empty .)
    GE              reduce using rule 64 (settypefrac -> empty .)
    LE              reduce using rule 64 (settypefrac -> empty .)
    NE              reduce using rule 64 (settypefrac -> empty .)
    GT              reduce using rule 64 (settypefrac -> empty .)
    LT              reduce using rule 64 (settypefrac -> empty .)
    PLUS            reduce using rule 64 (settypefrac -> empty .)
    MINUS           reduce using rule 64 (settypefrac -> empty .)
    MODULO          reduce using rule 64 (settypefrac -> empty .)
    DIVIDE          reduce using rule 64 (settypefrac -> empty .)
    TIMES           reduce using rule 64 (settypefrac -> empty .)
    POWER           reduce using rule 64 (settypefrac -> empty .)
    SEMI            reduce using rule 64 (settypefrac -> empty .)
    RPAREN          reduce using rule 64 (settypefrac -> empty .)
    RBRACK          reduce using rule 64 (settypefrac -> empty .)
    COMMA           reduce using rule 64 (settypefrac -> empty .)


state 25

    (56) var -> VAR type . var1 SEMI var
    (57) var -> VAR type . var1 SEMI
    (58) var1 -> . ID pushid savevar allocatevar
    (59) var1 -> . ID pushid savevar allocatevar COMMA var1
    (60) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 35

    var1                           shift and go to state 34

state 26

    (6) function -> type FUNCTION . ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION . ID pushid setcontext LPAREN RPAREN savefunc block endfunc

    ID              shift and go to state 36


state 27

    (71) type -> BOOLEAN settypebool .

    ID              reduce using rule 71 (type -> BOOLEAN settypebool .)
    FUNCTION        reduce using rule 71 (type -> BOOLEAN settypebool .)


state 28

    (66) settypebool -> empty .

    OR              reduce using rule 66 (settypebool -> empty .)
    AND             reduce using rule 66 (settypebool -> empty .)
    SAME            reduce using rule 66 (settypebool -> empty .)
    DIF             reduce using rule 66 (settypebool -> empty .)
    GE              reduce using rule 66 (settypebool -> empty .)
    LE              reduce using rule 66 (settypebool -> empty .)
    NE              reduce using rule 66 (settypebool -> empty .)
    GT              reduce using rule 66 (settypebool -> empty .)
    LT              reduce using rule 66 (settypebool -> empty .)
    PLUS            reduce using rule 66 (settypebool -> empty .)
    MINUS           reduce using rule 66 (settypebool -> empty .)
    MODULO          reduce using rule 66 (settypebool -> empty .)
    DIVIDE          reduce using rule 66 (settypebool -> empty .)
    TIMES           reduce using rule 66 (settypebool -> empty .)
    POWER           reduce using rule 66 (settypebool -> empty .)
    SEMI            reduce using rule 66 (settypebool -> empty .)
    RPAREN          reduce using rule 66 (settypebool -> empty .)
    RBRACK          reduce using rule 66 (settypebool -> empty .)
    COMMA           reduce using rule 66 (settypebool -> empty .)
    FUNCTION        reduce using rule 66 (settypebool -> empty .)
    ID              reduce using rule 66 (settypebool -> empty .)


state 29

    (76) type -> VOID settypevoid .

    ID              reduce using rule 76 (type -> VOID settypevoid .)
    FUNCTION        reduce using rule 76 (type -> VOID settypevoid .)


state 30

    (67) settypevoid -> empty .

    FUNCTION        reduce using rule 67 (settypevoid -> empty .)
    ID              reduce using rule 67 (settypevoid -> empty .)


state 31

    (74) type -> STRING settypestring .

    ID              reduce using rule 74 (type -> STRING settypestring .)
    FUNCTION        reduce using rule 74 (type -> STRING settypestring .)


state 32

    (65) settypestring -> empty .

    OR              reduce using rule 65 (settypestring -> empty .)
    AND             reduce using rule 65 (settypestring -> empty .)
    SAME            reduce using rule 65 (settypestring -> empty .)
    DIF             reduce using rule 65 (settypestring -> empty .)
    GE              reduce using rule 65 (settypestring -> empty .)
    LE              reduce using rule 65 (settypestring -> empty .)
    NE              reduce using rule 65 (settypestring -> empty .)
    GT              reduce using rule 65 (settypestring -> empty .)
    LT              reduce using rule 65 (settypestring -> empty .)
    PLUS            reduce using rule 65 (settypestring -> empty .)
    MINUS           reduce using rule 65 (settypestring -> empty .)
    MODULO          reduce using rule 65 (settypestring -> empty .)
    DIVIDE          reduce using rule 65 (settypestring -> empty .)
    TIMES           reduce using rule 65 (settypestring -> empty .)
    POWER           reduce using rule 65 (settypestring -> empty .)
    SEMI            reduce using rule 65 (settypestring -> empty .)
    RPAREN          reduce using rule 65 (settypestring -> empty .)
    RBRACK          reduce using rule 65 (settypestring -> empty .)
    COMMA           reduce using rule 65 (settypestring -> empty .)
    FUNCTION        reduce using rule 65 (settypestring -> empty .)
    ID              reduce using rule 65 (settypestring -> empty .)


state 33

    (2) program -> PROGRAM ID SEMI gotomain var program1 .

    $end            reduce using rule 2 (program -> PROGRAM ID SEMI gotomain var program1 .)


state 34

    (56) var -> VAR type var1 . SEMI var
    (57) var -> VAR type var1 . SEMI

    SEMI            shift and go to state 37


state 35

    (58) var1 -> ID . pushid savevar allocatevar
    (59) var1 -> ID . pushid savevar allocatevar COMMA var1
    (60) var1 -> ID . pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID . pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    pushid                         shift and go to state 40
    empty                          shift and go to state 38
    pushtype                       shift and go to state 39

state 36

    (6) function -> type FUNCTION ID . pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID . pushid setcontext LPAREN RPAREN savefunc block endfunc
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 38
    pushtype                       shift and go to state 39
    pushid                         shift and go to state 41

state 37

    (56) var -> VAR type var1 SEMI . var
    (57) var -> VAR type var1 SEMI .
    (56) var -> . VAR type var1 SEMI var
    (57) var -> . VAR type var1 SEMI

    BOOLEAN         reduce using rule 57 (var -> VAR type var1 SEMI .)
    INTEGER         reduce using rule 57 (var -> VAR type var1 SEMI .)
    DECIMAL         reduce using rule 57 (var -> VAR type var1 SEMI .)
    STRING          reduce using rule 57 (var -> VAR type var1 SEMI .)
    FRACTION        reduce using rule 57 (var -> VAR type var1 SEMI .)
    VOID            reduce using rule 57 (var -> VAR type var1 SEMI .)
    RBRACE          reduce using rule 57 (var -> VAR type var1 SEMI .)
    IF              reduce using rule 57 (var -> VAR type var1 SEMI .)
    ID              reduce using rule 57 (var -> VAR type var1 SEMI .)
    WHILE           reduce using rule 57 (var -> VAR type var1 SEMI .)
    LPAREN          reduce using rule 57 (var -> VAR type var1 SEMI .)
    DO              reduce using rule 57 (var -> VAR type var1 SEMI .)
    PRINT           reduce using rule 57 (var -> VAR type var1 SEMI .)
    CALL            reduce using rule 57 (var -> VAR type var1 SEMI .)
    RETURN          reduce using rule 57 (var -> VAR type var1 SEMI .)
    INPUT           reduce using rule 57 (var -> VAR type var1 SEMI .)
    VAR             shift and go to state 11

    var                            shift and go to state 42

state 38

    (110) pushtype -> empty .

    LBRACK          reduce using rule 110 (pushtype -> empty .)
    COMMA           reduce using rule 110 (pushtype -> empty .)
    SEMI            reduce using rule 110 (pushtype -> empty .)
    EQUALS          reduce using rule 110 (pushtype -> empty .)
    LPAREN          reduce using rule 110 (pushtype -> empty .)
    OR              reduce using rule 110 (pushtype -> empty .)
    AND             reduce using rule 110 (pushtype -> empty .)
    SAME            reduce using rule 110 (pushtype -> empty .)
    DIF             reduce using rule 110 (pushtype -> empty .)
    GE              reduce using rule 110 (pushtype -> empty .)
    LE              reduce using rule 110 (pushtype -> empty .)
    NE              reduce using rule 110 (pushtype -> empty .)
    GT              reduce using rule 110 (pushtype -> empty .)
    LT              reduce using rule 110 (pushtype -> empty .)
    PLUS            reduce using rule 110 (pushtype -> empty .)
    MINUS           reduce using rule 110 (pushtype -> empty .)
    MODULO          reduce using rule 110 (pushtype -> empty .)
    DIVIDE          reduce using rule 110 (pushtype -> empty .)
    TIMES           reduce using rule 110 (pushtype -> empty .)
    POWER           reduce using rule 110 (pushtype -> empty .)
    RPAREN          reduce using rule 110 (pushtype -> empty .)
    RBRACK          reduce using rule 110 (pushtype -> empty .)


state 39

    (111) pushid -> pushtype .

    LPAREN          reduce using rule 111 (pushid -> pushtype .)
    EQUALS          reduce using rule 111 (pushid -> pushtype .)
    LBRACK          reduce using rule 111 (pushid -> pushtype .)
    COMMA           reduce using rule 111 (pushid -> pushtype .)
    RPAREN          reduce using rule 111 (pushid -> pushtype .)
    SEMI            reduce using rule 111 (pushid -> pushtype .)


state 40

    (58) var1 -> ID pushid . savevar allocatevar
    (59) var1 -> ID pushid . savevar allocatevar COMMA var1
    (60) var1 -> ID pushid . savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid . savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (68) savevar -> . empty
    (115) empty -> .

    LBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 43
    savevar                        shift and go to state 44

state 41

    (6) function -> type FUNCTION ID pushid . setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID pushid . setcontext LPAREN RPAREN savefunc block endfunc
    (8) setcontext -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    setcontext                     shift and go to state 45
    empty                          shift and go to state 46

state 42

    (56) var -> VAR type var1 SEMI var .

    BOOLEAN         reduce using rule 56 (var -> VAR type var1 SEMI var .)
    INTEGER         reduce using rule 56 (var -> VAR type var1 SEMI var .)
    DECIMAL         reduce using rule 56 (var -> VAR type var1 SEMI var .)
    STRING          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    FRACTION        reduce using rule 56 (var -> VAR type var1 SEMI var .)
    VOID            reduce using rule 56 (var -> VAR type var1 SEMI var .)
    RBRACE          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    IF              reduce using rule 56 (var -> VAR type var1 SEMI var .)
    ID              reduce using rule 56 (var -> VAR type var1 SEMI var .)
    WHILE           reduce using rule 56 (var -> VAR type var1 SEMI var .)
    LPAREN          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    DO              reduce using rule 56 (var -> VAR type var1 SEMI var .)
    PRINT           reduce using rule 56 (var -> VAR type var1 SEMI var .)
    CALL            reduce using rule 56 (var -> VAR type var1 SEMI var .)
    RETURN          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    INPUT           reduce using rule 56 (var -> VAR type var1 SEMI var .)


state 43

    (68) savevar -> empty .

    LBRACK          reduce using rule 68 (savevar -> empty .)
    COMMA           reduce using rule 68 (savevar -> empty .)
    SEMI            reduce using rule 68 (savevar -> empty .)


state 44

    (58) var1 -> ID pushid savevar . allocatevar
    (59) var1 -> ID pushid savevar . allocatevar COMMA var1
    (60) var1 -> ID pushid savevar . LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar . LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (69) allocatevar -> . empty
    (115) empty -> .

    LBRACK          shift and go to state 48
    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 47
    allocatevar                    shift and go to state 49

state 45

    (6) function -> type FUNCTION ID pushid setcontext . LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID pushid setcontext . LPAREN RPAREN savefunc block endfunc

    LPAREN          shift and go to state 50


state 46

    (8) setcontext -> empty .

    LPAREN          reduce using rule 8 (setcontext -> empty .)


state 47

    (69) allocatevar -> empty .

    COMMA           reduce using rule 69 (allocatevar -> empty .)
    SEMI            reduce using rule 69 (allocatevar -> empty .)


state 48

    (60) var1 -> ID pushid savevar LBRACK . INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK . INTEGER_CONS updatesize RBRACK allocatevar

    INTEGER_CONS    shift and go to state 51


state 49

    (58) var1 -> ID pushid savevar allocatevar .
    (59) var1 -> ID pushid savevar allocatevar . COMMA var1

    SEMI            reduce using rule 58 (var1 -> ID pushid savevar allocatevar .)
    COMMA           shift and go to state 52


state 50

    (6) function -> type FUNCTION ID pushid setcontext LPAREN . parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID pushid setcontext LPAREN . RPAREN savefunc block endfunc
    (11) parameter -> . type ID pushid
    (12) parameter -> . type ID pushid COMMA parameter
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    RPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 9
    DECIMAL         shift and go to state 7
    STRING          shift and go to state 16
    FRACTION        shift and go to state 10
    VOID            shift and go to state 15

    parameter                      shift and go to state 53
    type                           shift and go to state 54

state 51

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS . updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS . updatesize RBRACK allocatevar
    (70) updatesize -> . empty
    (115) empty -> .

    RBRACK          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 56
    updatesize                     shift and go to state 57

state 52

    (59) var1 -> ID pushid savevar allocatevar COMMA . var1
    (58) var1 -> . ID pushid savevar allocatevar
    (59) var1 -> . ID pushid savevar allocatevar COMMA var1
    (60) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 35

    var1                           shift and go to state 58

state 53

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter . RPAREN savefunc block endfunc

    RPAREN          shift and go to state 59


state 54

    (11) parameter -> type . ID pushid
    (12) parameter -> type . ID pushid COMMA parameter

    ID              shift and go to state 60


state 55

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN . savefunc block endfunc
    (10) savefunc -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    savefunc                       shift and go to state 61
    empty                          shift and go to state 62

state 56

    (70) updatesize -> empty .

    RBRACK          reduce using rule 70 (updatesize -> empty .)


state 57

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize . RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize . RBRACK allocatevar

    RBRACK          shift and go to state 63


state 58

    (59) var1 -> ID pushid savevar allocatevar COMMA var1 .

    SEMI            reduce using rule 59 (var1 -> ID pushid savevar allocatevar COMMA var1 .)


state 59

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN . savefunc block endfunc
    (10) savefunc -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    savefunc                       shift and go to state 64
    empty                          shift and go to state 62

state 60

    (11) parameter -> type ID . pushid
    (12) parameter -> type ID . pushid COMMA parameter
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)

    pushtype                       shift and go to state 39
    empty                          shift and go to state 38
    pushid                         shift and go to state 65

state 61

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc . block endfunc
    (13) block -> . LBRACE var vartoparam statements RBRACE deletelocal
    (14) block -> . LBRACE var vartoparam RBRACE deletelocal
    (17) block -> . LBRACE statements RBRACE
    (18) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 66

    block                          shift and go to state 67

state 62

    (10) savefunc -> empty .

    LBRACE          reduce using rule 10 (savefunc -> empty .)


state 63

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK . allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK . allocatevar
    (69) allocatevar -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 47
    allocatevar                    shift and go to state 68

state 64

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc . block endfunc
    (13) block -> . LBRACE var vartoparam statements RBRACE deletelocal
    (14) block -> . LBRACE var vartoparam RBRACE deletelocal
    (17) block -> . LBRACE statements RBRACE
    (18) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 66

    block                          shift and go to state 69

state 65

    (11) parameter -> type ID pushid .
    (12) parameter -> type ID pushid . COMMA parameter

    RPAREN          reduce using rule 11 (parameter -> type ID pushid .)
    COMMA           shift and go to state 70


state 66

    (13) block -> LBRACE . var vartoparam statements RBRACE deletelocal
    (14) block -> LBRACE . var vartoparam RBRACE deletelocal
    (17) block -> LBRACE . statements RBRACE
    (18) block -> LBRACE . RBRACE
    (56) var -> . VAR type var1 SEMI var
    (57) var -> . VAR type var1 SEMI
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          shift and go to state 71
    VAR             shift and go to state 11
    IF              shift and go to state 89
    ID              shift and go to state 85
    WHILE           shift and go to state 84
    LPAREN          shift and go to state 87
    DO              shift and go to state 91
    PRINT           shift and go to state 86
    CALL            shift and go to state 81
    RETURN          shift and go to state 77
    INPUT           shift and go to state 83

    for                            shift and go to state 79
    statement                      shift and go to state 80
    statements                     shift and go to state 72
    condition                      shift and go to state 73
    print                          shift and go to state 74
    dowhile                        shift and go to state 76
    assignment                     shift and go to state 82
    input                          shift and go to state 88
    funcall                        shift and go to state 90
    return                         shift and go to state 75
    var                            shift and go to state 78
    while                          shift and go to state 92

state 67

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block . endfunc
    (9) endfunc -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    endfunc                        shift and go to state 93
    empty                          shift and go to state 94

state 68

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar . COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar .

    COMMA           shift and go to state 95
    SEMI            reduce using rule 61 (var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar .)


state 69

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block . endfunc
    (9) endfunc -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    endfunc                        shift and go to state 96
    empty                          shift and go to state 94

state 70

    (12) parameter -> type ID pushid COMMA . parameter
    (11) parameter -> . type ID pushid
    (12) parameter -> . type ID pushid COMMA parameter
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 9
    DECIMAL         shift and go to state 7
    STRING          shift and go to state 16
    FRACTION        shift and go to state 10
    VOID            shift and go to state 15

    parameter                      shift and go to state 97
    type                           shift and go to state 54

state 71

    (18) block -> LBRACE RBRACE .

    BOOLEAN         reduce using rule 18 (block -> LBRACE RBRACE .)
    INTEGER         reduce using rule 18 (block -> LBRACE RBRACE .)
    DECIMAL         reduce using rule 18 (block -> LBRACE RBRACE .)
    STRING          reduce using rule 18 (block -> LBRACE RBRACE .)
    FRACTION        reduce using rule 18 (block -> LBRACE RBRACE .)
    VOID            reduce using rule 18 (block -> LBRACE RBRACE .)
    $end            reduce using rule 18 (block -> LBRACE RBRACE .)


state 72

    (17) block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 98


state 73

    (24) statement -> condition .

    IF              reduce using rule 24 (statement -> condition .)
    ID              reduce using rule 24 (statement -> condition .)
    WHILE           reduce using rule 24 (statement -> condition .)
    LPAREN          reduce using rule 24 (statement -> condition .)
    DO              reduce using rule 24 (statement -> condition .)
    PRINT           reduce using rule 24 (statement -> condition .)
    CALL            reduce using rule 24 (statement -> condition .)
    RETURN          reduce using rule 24 (statement -> condition .)
    INPUT           reduce using rule 24 (statement -> condition .)
    RBRACE          reduce using rule 24 (statement -> condition .)


state 74

    (29) statement -> print . SEMI

    SEMI            shift and go to state 99


state 75

    (31) statement -> return . SEMI

    SEMI            shift and go to state 100


state 76

    (28) statement -> dowhile .

    IF              reduce using rule 28 (statement -> dowhile .)
    ID              reduce using rule 28 (statement -> dowhile .)
    WHILE           reduce using rule 28 (statement -> dowhile .)
    LPAREN          reduce using rule 28 (statement -> dowhile .)
    DO              reduce using rule 28 (statement -> dowhile .)
    PRINT           reduce using rule 28 (statement -> dowhile .)
    CALL            reduce using rule 28 (statement -> dowhile .)
    RETURN          reduce using rule 28 (statement -> dowhile .)
    INPUT           reduce using rule 28 (statement -> dowhile .)
    RBRACE          reduce using rule 28 (statement -> dowhile .)


state 77

    (34) return -> RETURN . expression savereturn
    (35) return -> RETURN . savereturn
    (81) expression -> . exp
    (21) savereturn -> . empty
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (115) empty -> .
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    SEMI            reduce using rule 115 (empty -> .)
    CALL            shift and go to state 81

    savereturn                     shift and go to state 109
    empty                          shift and go to state 110
    expression                     shift and go to state 104
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 78

    (13) block -> LBRACE var . vartoparam statements RBRACE deletelocal
    (14) block -> LBRACE var . vartoparam RBRACE deletelocal
    (16) vartoparam -> . empty
    (115) empty -> .

    RBRACE          reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 116
    vartoparam                     shift and go to state 117

state 79

    (27) statement -> for .

    IF              reduce using rule 27 (statement -> for .)
    ID              reduce using rule 27 (statement -> for .)
    WHILE           reduce using rule 27 (statement -> for .)
    LPAREN          reduce using rule 27 (statement -> for .)
    DO              reduce using rule 27 (statement -> for .)
    PRINT           reduce using rule 27 (statement -> for .)
    CALL            reduce using rule 27 (statement -> for .)
    RETURN          reduce using rule 27 (statement -> for .)
    INPUT           reduce using rule 27 (statement -> for .)
    RBRACE          reduce using rule 27 (statement -> for .)


state 80

    (22) statements -> statement .
    (23) statements -> statement . statements
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          reduce using rule 22 (statements -> statement .)
    IF              shift and go to state 89
    ID              shift and go to state 85
    WHILE           shift and go to state 84
    LPAREN          shift and go to state 87
    DO              shift and go to state 91
    PRINT           shift and go to state 86
    CALL            shift and go to state 81
    RETURN          shift and go to state 77
    INPUT           shift and go to state 83

    for                            shift and go to state 79
    statement                      shift and go to state 80
    statements                     shift and go to state 118
    condition                      shift and go to state 73
    print                          shift and go to state 74
    return                         shift and go to state 75
    dowhile                        shift and go to state 76
    assignment                     shift and go to state 82
    input                          shift and go to state 88
    funcall                        shift and go to state 90
    while                          shift and go to state 92

state 81

    (37) funcall -> CALL . ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL . ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 119


state 82

    (25) statement -> assignment .

    IF              reduce using rule 25 (statement -> assignment .)
    ID              reduce using rule 25 (statement -> assignment .)
    WHILE           reduce using rule 25 (statement -> assignment .)
    LPAREN          reduce using rule 25 (statement -> assignment .)
    DO              reduce using rule 25 (statement -> assignment .)
    PRINT           reduce using rule 25 (statement -> assignment .)
    CALL            reduce using rule 25 (statement -> assignment .)
    RETURN          reduce using rule 25 (statement -> assignment .)
    INPUT           reduce using rule 25 (statement -> assignment .)
    RBRACE          reduce using rule 25 (statement -> assignment .)


state 83

    (33) input -> INPUT . ID pushdeclaredid

    ID              shift and go to state 120


state 84

    (49) while -> WHILE . pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (47) pushjump -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    pushjump                       shift and go to state 121
    empty                          shift and go to state 122

state 85

    (77) assignment -> ID . pushid EQUALS expression SEMI updatevar
    (78) assignment -> ID . pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    EQUALS          reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)

    pushid                         shift and go to state 123
    empty                          shift and go to state 38
    pushtype                       shift and go to state 39

state 86

    (36) print -> PRINT . expression
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 124
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 87

    (45) for -> LPAREN . assignment expression SEMI expression RPAREN simpleblock
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell

    ID              shift and go to state 85

    assignment                     shift and go to state 125

state 88

    (32) statement -> input . SEMI

    SEMI            shift and go to state 126


state 89

    (51) condition -> IF . LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF . LPAREN expression RPAREN gotof simpleblock updatejump

    LPAREN          shift and go to state 127


state 90

    (30) statement -> funcall . SEMI

    SEMI            shift and go to state 128


state 91

    (46) dowhile -> DO . pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (47) pushjump -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    pushjump                       shift and go to state 129
    empty                          shift and go to state 122

state 92

    (26) statement -> while .

    IF              reduce using rule 26 (statement -> while .)
    ID              reduce using rule 26 (statement -> while .)
    WHILE           reduce using rule 26 (statement -> while .)
    LPAREN          reduce using rule 26 (statement -> while .)
    DO              reduce using rule 26 (statement -> while .)
    PRINT           reduce using rule 26 (statement -> while .)
    CALL            reduce using rule 26 (statement -> while .)
    RETURN          reduce using rule 26 (statement -> while .)
    INPUT           reduce using rule 26 (statement -> while .)
    RBRACE          reduce using rule 26 (statement -> while .)


state 93

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .

    BOOLEAN         reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    INTEGER         reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    DECIMAL         reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    STRING          reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    FRACTION        reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    VOID            reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    $end            reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)


state 94

    (9) endfunc -> empty .

    BOOLEAN         reduce using rule 9 (endfunc -> empty .)
    INTEGER         reduce using rule 9 (endfunc -> empty .)
    DECIMAL         reduce using rule 9 (endfunc -> empty .)
    STRING          reduce using rule 9 (endfunc -> empty .)
    FRACTION        reduce using rule 9 (endfunc -> empty .)
    VOID            reduce using rule 9 (endfunc -> empty .)
    $end            reduce using rule 9 (endfunc -> empty .)


state 95

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA . var1
    (58) var1 -> . ID pushid savevar allocatevar
    (59) var1 -> . ID pushid savevar allocatevar COMMA var1
    (60) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 35

    var1                           shift and go to state 130

state 96

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .

    BOOLEAN         reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    INTEGER         reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    DECIMAL         reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    STRING          reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    FRACTION        reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    VOID            reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    $end            reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)


state 97

    (12) parameter -> type ID pushid COMMA parameter .

    RPAREN          reduce using rule 12 (parameter -> type ID pushid COMMA parameter .)


state 98

    (17) block -> LBRACE statements RBRACE .

    BOOLEAN         reduce using rule 17 (block -> LBRACE statements RBRACE .)
    INTEGER         reduce using rule 17 (block -> LBRACE statements RBRACE .)
    DECIMAL         reduce using rule 17 (block -> LBRACE statements RBRACE .)
    STRING          reduce using rule 17 (block -> LBRACE statements RBRACE .)
    FRACTION        reduce using rule 17 (block -> LBRACE statements RBRACE .)
    VOID            reduce using rule 17 (block -> LBRACE statements RBRACE .)
    $end            reduce using rule 17 (block -> LBRACE statements RBRACE .)


state 99

    (29) statement -> print SEMI .

    IF              reduce using rule 29 (statement -> print SEMI .)
    ID              reduce using rule 29 (statement -> print SEMI .)
    WHILE           reduce using rule 29 (statement -> print SEMI .)
    LPAREN          reduce using rule 29 (statement -> print SEMI .)
    DO              reduce using rule 29 (statement -> print SEMI .)
    PRINT           reduce using rule 29 (statement -> print SEMI .)
    CALL            reduce using rule 29 (statement -> print SEMI .)
    RETURN          reduce using rule 29 (statement -> print SEMI .)
    INPUT           reduce using rule 29 (statement -> print SEMI .)
    RBRACE          reduce using rule 29 (statement -> print SEMI .)


state 100

    (31) statement -> return SEMI .

    IF              reduce using rule 31 (statement -> return SEMI .)
    ID              reduce using rule 31 (statement -> return SEMI .)
    WHILE           reduce using rule 31 (statement -> return SEMI .)
    LPAREN          reduce using rule 31 (statement -> return SEMI .)
    DO              reduce using rule 31 (statement -> return SEMI .)
    PRINT           reduce using rule 31 (statement -> return SEMI .)
    CALL            reduce using rule 31 (statement -> return SEMI .)
    RETURN          reduce using rule 31 (statement -> return SEMI .)
    INPUT           reduce using rule 31 (statement -> return SEMI .)
    RBRACE          reduce using rule 31 (statement -> return SEMI .)


state 101

    (81) expression -> exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    SEMI            reduce using rule 81 (expression -> exp .)
    RBRACK          reduce using rule 81 (expression -> exp .)
    RPAREN          reduce using rule 81 (expression -> exp .)
    COMMA           reduce using rule 81 (expression -> exp .)
    OR              shift and go to state 138
    AND             shift and go to state 133
    SAME            shift and go to state 132
    DIF             shift and go to state 142
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131


state 102

    (97) exp -> ID . pushdeclaredid
    (98) exp -> ID . pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (112) pushdeclaredid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LBRACK          reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushdeclaredid                 shift and go to state 146
    empty                          shift and go to state 38
    pushtype                       shift and go to state 147

state 103

    (107) exp -> LPAREN . exp RPAREN
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 148
    funcall                        shift and go to state 115

state 104

    (34) return -> RETURN expression . savereturn
    (21) savereturn -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)

    savereturn                     shift and go to state 149
    empty                          shift and go to state 110

state 105

    (105) exp -> FALSE . settypebool pushcons
    (66) settypebool -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    settypebool                    shift and go to state 150
    empty                          shift and go to state 28

state 106

    (104) exp -> TRUE . settypebool pushcons
    (66) settypebool -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    settypebool                    shift and go to state 151
    empty                          shift and go to state 28

state 107

    (102) exp -> FRACTION_CONS . settypefrac pushcons
    (64) settypefrac -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    settypefrac                    shift and go to state 152
    empty                          shift and go to state 24

state 108

    (99) exp -> LBRACK . exp RBRACK
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 153
    funcall                        shift and go to state 115

state 109

    (35) return -> RETURN savereturn .

    SEMI            reduce using rule 35 (return -> RETURN savereturn .)


state 110

    (21) savereturn -> empty .

    SEMI            reduce using rule 21 (savereturn -> empty .)


state 111

    (106) exp -> EXMARK . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 154
    funcall                        shift and go to state 115

state 112

    (101) exp -> STRING_CONS . settypestring pushcons
    (65) settypestring -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    settypestring                  shift and go to state 155
    empty                          shift and go to state 32

state 113

    (103) exp -> DECIMAL_CONS . settypedec pushcons
    (63) settypedec -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    settypedec                     shift and go to state 156
    empty                          shift and go to state 19

state 114

    (100) exp -> INTEGER_CONS . settypeint pushcons
    (62) settypeint -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    settypeint                     shift and go to state 157
    empty                          shift and go to state 22

state 115

    (108) exp -> funcall . pushrtn
    (109) pushrtn -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushrtn                        shift and go to state 158
    empty                          shift and go to state 159

state 116

    (16) vartoparam -> empty .

    RBRACE          reduce using rule 16 (vartoparam -> empty .)
    IF              reduce using rule 16 (vartoparam -> empty .)
    ID              reduce using rule 16 (vartoparam -> empty .)
    WHILE           reduce using rule 16 (vartoparam -> empty .)
    LPAREN          reduce using rule 16 (vartoparam -> empty .)
    DO              reduce using rule 16 (vartoparam -> empty .)
    PRINT           reduce using rule 16 (vartoparam -> empty .)
    CALL            reduce using rule 16 (vartoparam -> empty .)
    RETURN          reduce using rule 16 (vartoparam -> empty .)
    INPUT           reduce using rule 16 (vartoparam -> empty .)


state 117

    (13) block -> LBRACE var vartoparam . statements RBRACE deletelocal
    (14) block -> LBRACE var vartoparam . RBRACE deletelocal
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          shift and go to state 160
    IF              shift and go to state 89
    ID              shift and go to state 85
    WHILE           shift and go to state 84
    LPAREN          shift and go to state 87
    DO              shift and go to state 91
    PRINT           shift and go to state 86
    CALL            shift and go to state 81
    RETURN          shift and go to state 77
    INPUT           shift and go to state 83

    for                            shift and go to state 79
    statement                      shift and go to state 80
    statements                     shift and go to state 161
    condition                      shift and go to state 73
    print                          shift and go to state 74
    dowhile                        shift and go to state 76
    assignment                     shift and go to state 82
    input                          shift and go to state 88
    funcall                        shift and go to state 90
    return                         shift and go to state 75
    while                          shift and go to state 92

state 118

    (23) statements -> statement statements .

    RBRACE          reduce using rule 23 (statements -> statement statements .)


state 119

    (37) funcall -> CALL ID . pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID . pushid LPAREN eragener RPAREN assignvalues
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 38
    pushid                         shift and go to state 162
    pushtype                       shift and go to state 39

state 120

    (33) input -> INPUT ID . pushdeclaredid
    (112) pushdeclaredid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)

    pushdeclaredid                 shift and go to state 163
    empty                          shift and go to state 38
    pushtype                       shift and go to state 147

state 121

    (49) while -> WHILE pushjump . LPAREN expression RPAREN gotof simpleblock gotowhile

    LPAREN          shift and go to state 164


state 122

    (47) pushjump -> empty .

    LPAREN          reduce using rule 47 (pushjump -> empty .)
    LBRACE          reduce using rule 47 (pushjump -> empty .)


state 123

    (77) assignment -> ID pushid . EQUALS expression SEMI updatevar
    (78) assignment -> ID pushid . LBRACK expression RBRACK EQUALS expression SEMI updatecell

    EQUALS          shift and go to state 166
    LBRACK          shift and go to state 165


state 124

    (36) print -> PRINT expression .

    SEMI            reduce using rule 36 (print -> PRINT expression .)


state 125

    (45) for -> LPAREN assignment . expression SEMI expression RPAREN simpleblock
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 167
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 126

    (32) statement -> input SEMI .

    IF              reduce using rule 32 (statement -> input SEMI .)
    ID              reduce using rule 32 (statement -> input SEMI .)
    WHILE           reduce using rule 32 (statement -> input SEMI .)
    LPAREN          reduce using rule 32 (statement -> input SEMI .)
    DO              reduce using rule 32 (statement -> input SEMI .)
    PRINT           reduce using rule 32 (statement -> input SEMI .)
    CALL            reduce using rule 32 (statement -> input SEMI .)
    RETURN          reduce using rule 32 (statement -> input SEMI .)
    INPUT           reduce using rule 32 (statement -> input SEMI .)
    RBRACE          reduce using rule 32 (statement -> input SEMI .)


state 127

    (51) condition -> IF LPAREN . expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN . expression RPAREN gotof simpleblock updatejump
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 168
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 128

    (30) statement -> funcall SEMI .

    IF              reduce using rule 30 (statement -> funcall SEMI .)
    ID              reduce using rule 30 (statement -> funcall SEMI .)
    WHILE           reduce using rule 30 (statement -> funcall SEMI .)
    LPAREN          reduce using rule 30 (statement -> funcall SEMI .)
    DO              reduce using rule 30 (statement -> funcall SEMI .)
    PRINT           reduce using rule 30 (statement -> funcall SEMI .)
    CALL            reduce using rule 30 (statement -> funcall SEMI .)
    RETURN          reduce using rule 30 (statement -> funcall SEMI .)
    INPUT           reduce using rule 30 (statement -> funcall SEMI .)
    RBRACE          reduce using rule 30 (statement -> funcall SEMI .)


state 129

    (46) dowhile -> DO pushjump . simpleblock WHILE LPAREN expression RPAREN gotot
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 170

    simpleblock                    shift and go to state 169

state 130

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1 .

    SEMI            reduce using rule 60 (var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1 .)


state 131

    (96) exp -> exp POWER . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 171
    funcall                        shift and go to state 115

state 132

    (84) exp -> exp SAME . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 172
    funcall                        shift and go to state 115

state 133

    (83) exp -> exp AND . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 173
    funcall                        shift and go to state 115

state 134

    (91) exp -> exp PLUS . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 174
    funcall                        shift and go to state 115

state 135

    (86) exp -> exp GE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 175
    funcall                        shift and go to state 115

state 136

    (93) exp -> exp MODULO . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 176
    funcall                        shift and go to state 115

state 137

    (89) exp -> exp GT . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 177
    funcall                        shift and go to state 115

state 138

    (82) exp -> exp OR . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 178
    funcall                        shift and go to state 115

state 139

    (94) exp -> exp DIVIDE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 179
    funcall                        shift and go to state 115

state 140

    (87) exp -> exp LE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 180
    funcall                        shift and go to state 115

state 141

    (90) exp -> exp LT . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 181
    funcall                        shift and go to state 115

state 142

    (85) exp -> exp DIF . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 182
    funcall                        shift and go to state 115

state 143

    (95) exp -> exp TIMES . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 183
    funcall                        shift and go to state 115

state 144

    (88) exp -> exp NE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 184
    funcall                        shift and go to state 115

state 145

    (92) exp -> exp MINUS . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    exp                            shift and go to state 185
    funcall                        shift and go to state 115

state 146

    (97) exp -> ID pushdeclaredid .
    (98) exp -> ID pushdeclaredid . LBRACK expression RBRACK pushdeclaredarray

    OR              reduce using rule 97 (exp -> ID pushdeclaredid .)
    AND             reduce using rule 97 (exp -> ID pushdeclaredid .)
    SAME            reduce using rule 97 (exp -> ID pushdeclaredid .)
    DIF             reduce using rule 97 (exp -> ID pushdeclaredid .)
    GE              reduce using rule 97 (exp -> ID pushdeclaredid .)
    LE              reduce using rule 97 (exp -> ID pushdeclaredid .)
    NE              reduce using rule 97 (exp -> ID pushdeclaredid .)
    GT              reduce using rule 97 (exp -> ID pushdeclaredid .)
    LT              reduce using rule 97 (exp -> ID pushdeclaredid .)
    PLUS            reduce using rule 97 (exp -> ID pushdeclaredid .)
    MINUS           reduce using rule 97 (exp -> ID pushdeclaredid .)
    MODULO          reduce using rule 97 (exp -> ID pushdeclaredid .)
    DIVIDE          reduce using rule 97 (exp -> ID pushdeclaredid .)
    TIMES           reduce using rule 97 (exp -> ID pushdeclaredid .)
    POWER           reduce using rule 97 (exp -> ID pushdeclaredid .)
    SEMI            reduce using rule 97 (exp -> ID pushdeclaredid .)
    RPAREN          reduce using rule 97 (exp -> ID pushdeclaredid .)
    RBRACK          reduce using rule 97 (exp -> ID pushdeclaredid .)
    COMMA           reduce using rule 97 (exp -> ID pushdeclaredid .)
    LBRACK          shift and go to state 186


state 147

    (112) pushdeclaredid -> pushtype .

    LBRACK          reduce using rule 112 (pushdeclaredid -> pushtype .)
    OR              reduce using rule 112 (pushdeclaredid -> pushtype .)
    AND             reduce using rule 112 (pushdeclaredid -> pushtype .)
    SAME            reduce using rule 112 (pushdeclaredid -> pushtype .)
    DIF             reduce using rule 112 (pushdeclaredid -> pushtype .)
    GE              reduce using rule 112 (pushdeclaredid -> pushtype .)
    LE              reduce using rule 112 (pushdeclaredid -> pushtype .)
    NE              reduce using rule 112 (pushdeclaredid -> pushtype .)
    GT              reduce using rule 112 (pushdeclaredid -> pushtype .)
    LT              reduce using rule 112 (pushdeclaredid -> pushtype .)
    PLUS            reduce using rule 112 (pushdeclaredid -> pushtype .)
    MINUS           reduce using rule 112 (pushdeclaredid -> pushtype .)
    MODULO          reduce using rule 112 (pushdeclaredid -> pushtype .)
    DIVIDE          reduce using rule 112 (pushdeclaredid -> pushtype .)
    TIMES           reduce using rule 112 (pushdeclaredid -> pushtype .)
    POWER           reduce using rule 112 (pushdeclaredid -> pushtype .)
    SEMI            reduce using rule 112 (pushdeclaredid -> pushtype .)
    RPAREN          reduce using rule 112 (pushdeclaredid -> pushtype .)
    RBRACK          reduce using rule 112 (pushdeclaredid -> pushtype .)
    COMMA           reduce using rule 112 (pushdeclaredid -> pushtype .)


state 148

    (107) exp -> LPAREN exp . RPAREN
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    RPAREN          shift and go to state 187
    OR              shift and go to state 138
    AND             shift and go to state 133
    SAME            shift and go to state 132
    DIF             shift and go to state 142
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131


state 149

    (34) return -> RETURN expression savereturn .

    SEMI            reduce using rule 34 (return -> RETURN expression savereturn .)


state 150

    (105) exp -> FALSE settypebool . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 188
    empty                          shift and go to state 38
    pushtype                       shift and go to state 189

state 151

    (104) exp -> TRUE settypebool . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 190
    empty                          shift and go to state 38
    pushtype                       shift and go to state 189

state 152

    (102) exp -> FRACTION_CONS settypefrac . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 191
    empty                          shift and go to state 38
    pushtype                       shift and go to state 189

state 153

    (99) exp -> LBRACK exp . RBRACK
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    RBRACK          shift and go to state 192
    OR              shift and go to state 138
    AND             shift and go to state 133
    SAME            shift and go to state 132
    DIF             shift and go to state 142
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131


state 154

    (106) exp -> EXMARK exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 106 (exp -> EXMARK exp .)
    AND             reduce using rule 106 (exp -> EXMARK exp .)
    DIF             reduce using rule 106 (exp -> EXMARK exp .)
    SEMI            reduce using rule 106 (exp -> EXMARK exp .)
    RPAREN          reduce using rule 106 (exp -> EXMARK exp .)
    RBRACK          reduce using rule 106 (exp -> EXMARK exp .)
    COMMA           reduce using rule 106 (exp -> EXMARK exp .)
    SAME            shift and go to state 132
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! SAME            [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! GE              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! LE              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! NE              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! GT              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! LT              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! PLUS            [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! MINUS           [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! MODULO          [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! DIVIDE          [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! TIMES           [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! POWER           [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! DIF             [ shift and go to state 142 ]


state 155

    (101) exp -> STRING_CONS settypestring . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushtype                       shift and go to state 189
    empty                          shift and go to state 38
    pushcons                       shift and go to state 193

state 156

    (103) exp -> DECIMAL_CONS settypedec . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 194
    empty                          shift and go to state 38
    pushtype                       shift and go to state 189

state 157

    (100) exp -> INTEGER_CONS settypeint . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 195
    empty                          shift and go to state 38
    pushtype                       shift and go to state 189

state 158

    (108) exp -> funcall pushrtn .

    OR              reduce using rule 108 (exp -> funcall pushrtn .)
    AND             reduce using rule 108 (exp -> funcall pushrtn .)
    SAME            reduce using rule 108 (exp -> funcall pushrtn .)
    DIF             reduce using rule 108 (exp -> funcall pushrtn .)
    GE              reduce using rule 108 (exp -> funcall pushrtn .)
    LE              reduce using rule 108 (exp -> funcall pushrtn .)
    NE              reduce using rule 108 (exp -> funcall pushrtn .)
    GT              reduce using rule 108 (exp -> funcall pushrtn .)
    LT              reduce using rule 108 (exp -> funcall pushrtn .)
    PLUS            reduce using rule 108 (exp -> funcall pushrtn .)
    MINUS           reduce using rule 108 (exp -> funcall pushrtn .)
    MODULO          reduce using rule 108 (exp -> funcall pushrtn .)
    DIVIDE          reduce using rule 108 (exp -> funcall pushrtn .)
    TIMES           reduce using rule 108 (exp -> funcall pushrtn .)
    POWER           reduce using rule 108 (exp -> funcall pushrtn .)
    SEMI            reduce using rule 108 (exp -> funcall pushrtn .)
    RPAREN          reduce using rule 108 (exp -> funcall pushrtn .)
    RBRACK          reduce using rule 108 (exp -> funcall pushrtn .)
    COMMA           reduce using rule 108 (exp -> funcall pushrtn .)


state 159

    (109) pushrtn -> empty .

    OR              reduce using rule 109 (pushrtn -> empty .)
    AND             reduce using rule 109 (pushrtn -> empty .)
    SAME            reduce using rule 109 (pushrtn -> empty .)
    DIF             reduce using rule 109 (pushrtn -> empty .)
    GE              reduce using rule 109 (pushrtn -> empty .)
    LE              reduce using rule 109 (pushrtn -> empty .)
    NE              reduce using rule 109 (pushrtn -> empty .)
    GT              reduce using rule 109 (pushrtn -> empty .)
    LT              reduce using rule 109 (pushrtn -> empty .)
    PLUS            reduce using rule 109 (pushrtn -> empty .)
    MINUS           reduce using rule 109 (pushrtn -> empty .)
    MODULO          reduce using rule 109 (pushrtn -> empty .)
    DIVIDE          reduce using rule 109 (pushrtn -> empty .)
    TIMES           reduce using rule 109 (pushrtn -> empty .)
    POWER           reduce using rule 109 (pushrtn -> empty .)
    SEMI            reduce using rule 109 (pushrtn -> empty .)
    RPAREN          reduce using rule 109 (pushrtn -> empty .)
    RBRACK          reduce using rule 109 (pushrtn -> empty .)
    COMMA           reduce using rule 109 (pushrtn -> empty .)


state 160

    (14) block -> LBRACE var vartoparam RBRACE . deletelocal
    (15) deletelocal -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    deletelocal                    shift and go to state 196
    empty                          shift and go to state 197

state 161

    (13) block -> LBRACE var vartoparam statements . RBRACE deletelocal

    RBRACE          shift and go to state 198


state 162

    (37) funcall -> CALL ID pushid . LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID pushid . LPAREN eragener RPAREN assignvalues

    LPAREN          shift and go to state 199


state 163

    (33) input -> INPUT ID pushdeclaredid .

    SEMI            reduce using rule 33 (input -> INPUT ID pushdeclaredid .)


state 164

    (49) while -> WHILE pushjump LPAREN . expression RPAREN gotof simpleblock gotowhile
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 200
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 165

    (78) assignment -> ID pushid LBRACK . expression RBRACK EQUALS expression SEMI updatecell
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 201
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 166

    (77) assignment -> ID pushid EQUALS . expression SEMI updatevar
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 202
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 167

    (45) for -> LPAREN assignment expression . SEMI expression RPAREN simpleblock

    SEMI            shift and go to state 203


state 168

    (51) condition -> IF LPAREN expression . RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression . RPAREN gotof simpleblock updatejump

    RPAREN          shift and go to state 204


state 169

    (46) dowhile -> DO pushjump simpleblock . WHILE LPAREN expression RPAREN gotot

    WHILE           shift and go to state 205


state 170

    (19) simpleblock -> LBRACE . statements RBRACE
    (20) simpleblock -> LBRACE . RBRACE
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          shift and go to state 206
    IF              shift and go to state 89
    ID              shift and go to state 85
    WHILE           shift and go to state 84
    LPAREN          shift and go to state 87
    DO              shift and go to state 91
    PRINT           shift and go to state 86
    CALL            shift and go to state 81
    RETURN          shift and go to state 77
    INPUT           shift and go to state 83

    for                            shift and go to state 79
    statement                      shift and go to state 80
    statements                     shift and go to state 207
    condition                      shift and go to state 73
    print                          shift and go to state 74
    return                         shift and go to state 75
    dowhile                        shift and go to state 76
    assignment                     shift and go to state 82
    input                          shift and go to state 88
    funcall                        shift and go to state 90
    while                          shift and go to state 92

state 171

    (96) exp -> exp POWER exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 96 (exp -> exp POWER exp .)
    AND             reduce using rule 96 (exp -> exp POWER exp .)
    SAME            reduce using rule 96 (exp -> exp POWER exp .)
    DIF             reduce using rule 96 (exp -> exp POWER exp .)
    GE              reduce using rule 96 (exp -> exp POWER exp .)
    LE              reduce using rule 96 (exp -> exp POWER exp .)
    NE              reduce using rule 96 (exp -> exp POWER exp .)
    GT              reduce using rule 96 (exp -> exp POWER exp .)
    LT              reduce using rule 96 (exp -> exp POWER exp .)
    PLUS            reduce using rule 96 (exp -> exp POWER exp .)
    MINUS           reduce using rule 96 (exp -> exp POWER exp .)
    MODULO          reduce using rule 96 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 96 (exp -> exp POWER exp .)
    TIMES           reduce using rule 96 (exp -> exp POWER exp .)
    POWER           reduce using rule 96 (exp -> exp POWER exp .)
    SEMI            reduce using rule 96 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 96 (exp -> exp POWER exp .)
    RBRACK          reduce using rule 96 (exp -> exp POWER exp .)
    COMMA           reduce using rule 96 (exp -> exp POWER exp .)

  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]
  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 145 ]
  ! MODULO          [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 143 ]
  ! POWER           [ shift and go to state 131 ]


state 172

    (84) exp -> exp SAME exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 84 (exp -> exp SAME exp .)
    AND             reduce using rule 84 (exp -> exp SAME exp .)
    SAME            reduce using rule 84 (exp -> exp SAME exp .)
    DIF             reduce using rule 84 (exp -> exp SAME exp .)
    GE              reduce using rule 84 (exp -> exp SAME exp .)
    LE              reduce using rule 84 (exp -> exp SAME exp .)
    NE              reduce using rule 84 (exp -> exp SAME exp .)
    GT              reduce using rule 84 (exp -> exp SAME exp .)
    LT              reduce using rule 84 (exp -> exp SAME exp .)
    SEMI            reduce using rule 84 (exp -> exp SAME exp .)
    RPAREN          reduce using rule 84 (exp -> exp SAME exp .)
    RBRACK          reduce using rule 84 (exp -> exp SAME exp .)
    COMMA           reduce using rule 84 (exp -> exp SAME exp .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! PLUS            [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! MINUS           [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! MODULO          [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! DIVIDE          [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! TIMES           [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! POWER           [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]


state 173

    (83) exp -> exp AND exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 83 (exp -> exp AND exp .)
    AND             reduce using rule 83 (exp -> exp AND exp .)
    DIF             reduce using rule 83 (exp -> exp AND exp .)
    SEMI            reduce using rule 83 (exp -> exp AND exp .)
    RPAREN          reduce using rule 83 (exp -> exp AND exp .)
    RBRACK          reduce using rule 83 (exp -> exp AND exp .)
    COMMA           reduce using rule 83 (exp -> exp AND exp .)
    SAME            shift and go to state 132
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! SAME            [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! GE              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! LE              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! NE              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! PLUS            [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! MODULO          [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! DIF             [ shift and go to state 142 ]


state 174

    (91) exp -> exp PLUS exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 91 (exp -> exp PLUS exp .)
    AND             reduce using rule 91 (exp -> exp PLUS exp .)
    SAME            reduce using rule 91 (exp -> exp PLUS exp .)
    DIF             reduce using rule 91 (exp -> exp PLUS exp .)
    GE              reduce using rule 91 (exp -> exp PLUS exp .)
    LE              reduce using rule 91 (exp -> exp PLUS exp .)
    NE              reduce using rule 91 (exp -> exp PLUS exp .)
    GT              reduce using rule 91 (exp -> exp PLUS exp .)
    LT              reduce using rule 91 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 91 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 91 (exp -> exp PLUS exp .)
    SEMI            reduce using rule 91 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 91 (exp -> exp PLUS exp .)
    RBRACK          reduce using rule 91 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 91 (exp -> exp PLUS exp .)
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! MODULO          [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! TIMES           [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]
  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 145 ]


state 175

    (86) exp -> exp GE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 86 (exp -> exp GE exp .)
    AND             reduce using rule 86 (exp -> exp GE exp .)
    SAME            reduce using rule 86 (exp -> exp GE exp .)
    DIF             reduce using rule 86 (exp -> exp GE exp .)
    GE              reduce using rule 86 (exp -> exp GE exp .)
    LE              reduce using rule 86 (exp -> exp GE exp .)
    NE              reduce using rule 86 (exp -> exp GE exp .)
    GT              reduce using rule 86 (exp -> exp GE exp .)
    LT              reduce using rule 86 (exp -> exp GE exp .)
    SEMI            reduce using rule 86 (exp -> exp GE exp .)
    RPAREN          reduce using rule 86 (exp -> exp GE exp .)
    RBRACK          reduce using rule 86 (exp -> exp GE exp .)
    COMMA           reduce using rule 86 (exp -> exp GE exp .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! PLUS            [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]


state 176

    (93) exp -> exp MODULO exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 93 (exp -> exp MODULO exp .)
    AND             reduce using rule 93 (exp -> exp MODULO exp .)
    SAME            reduce using rule 93 (exp -> exp MODULO exp .)
    DIF             reduce using rule 93 (exp -> exp MODULO exp .)
    GE              reduce using rule 93 (exp -> exp MODULO exp .)
    LE              reduce using rule 93 (exp -> exp MODULO exp .)
    NE              reduce using rule 93 (exp -> exp MODULO exp .)
    GT              reduce using rule 93 (exp -> exp MODULO exp .)
    LT              reduce using rule 93 (exp -> exp MODULO exp .)
    PLUS            reduce using rule 93 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 93 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 93 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 93 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 93 (exp -> exp MODULO exp .)
    SEMI            reduce using rule 93 (exp -> exp MODULO exp .)
    RPAREN          reduce using rule 93 (exp -> exp MODULO exp .)
    RBRACK          reduce using rule 93 (exp -> exp MODULO exp .)
    COMMA           reduce using rule 93 (exp -> exp MODULO exp .)
    POWER           shift and go to state 131

  ! POWER           [ reduce using rule 93 (exp -> exp MODULO exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]
  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 145 ]
  ! MODULO          [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 143 ]


state 177

    (89) exp -> exp GT exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 89 (exp -> exp GT exp .)
    AND             reduce using rule 89 (exp -> exp GT exp .)
    SAME            reduce using rule 89 (exp -> exp GT exp .)
    DIF             reduce using rule 89 (exp -> exp GT exp .)
    GE              reduce using rule 89 (exp -> exp GT exp .)
    LE              reduce using rule 89 (exp -> exp GT exp .)
    NE              reduce using rule 89 (exp -> exp GT exp .)
    GT              reduce using rule 89 (exp -> exp GT exp .)
    LT              reduce using rule 89 (exp -> exp GT exp .)
    SEMI            reduce using rule 89 (exp -> exp GT exp .)
    RPAREN          reduce using rule 89 (exp -> exp GT exp .)
    RBRACK          reduce using rule 89 (exp -> exp GT exp .)
    COMMA           reduce using rule 89 (exp -> exp GT exp .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! PLUS            [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]


state 178

    (82) exp -> exp OR exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 82 (exp -> exp OR exp .)
    DIF             reduce using rule 82 (exp -> exp OR exp .)
    SEMI            reduce using rule 82 (exp -> exp OR exp .)
    RPAREN          reduce using rule 82 (exp -> exp OR exp .)
    RBRACK          reduce using rule 82 (exp -> exp OR exp .)
    COMMA           reduce using rule 82 (exp -> exp OR exp .)
    AND             shift and go to state 133
    SAME            shift and go to state 132
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! AND             [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! SAME            [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! GE              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! LE              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! NE              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! PLUS            [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! MODULO          [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! DIF             [ shift and go to state 142 ]


state 179

    (94) exp -> exp DIVIDE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 94 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 94 (exp -> exp DIVIDE exp .)
    SAME            reduce using rule 94 (exp -> exp DIVIDE exp .)
    DIF             reduce using rule 94 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 94 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 94 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 94 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 94 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 94 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 94 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 94 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 94 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 94 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 94 (exp -> exp DIVIDE exp .)
    SEMI            reduce using rule 94 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 94 (exp -> exp DIVIDE exp .)
    RBRACK          reduce using rule 94 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 94 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 131

  ! POWER           [ reduce using rule 94 (exp -> exp DIVIDE exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]
  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 145 ]
  ! MODULO          [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 143 ]


state 180

    (87) exp -> exp LE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 87 (exp -> exp LE exp .)
    AND             reduce using rule 87 (exp -> exp LE exp .)
    SAME            reduce using rule 87 (exp -> exp LE exp .)
    DIF             reduce using rule 87 (exp -> exp LE exp .)
    GE              reduce using rule 87 (exp -> exp LE exp .)
    LE              reduce using rule 87 (exp -> exp LE exp .)
    NE              reduce using rule 87 (exp -> exp LE exp .)
    GT              reduce using rule 87 (exp -> exp LE exp .)
    LT              reduce using rule 87 (exp -> exp LE exp .)
    SEMI            reduce using rule 87 (exp -> exp LE exp .)
    RPAREN          reduce using rule 87 (exp -> exp LE exp .)
    RBRACK          reduce using rule 87 (exp -> exp LE exp .)
    COMMA           reduce using rule 87 (exp -> exp LE exp .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! PLUS            [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]


state 181

    (90) exp -> exp LT exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 90 (exp -> exp LT exp .)
    AND             reduce using rule 90 (exp -> exp LT exp .)
    SAME            reduce using rule 90 (exp -> exp LT exp .)
    DIF             reduce using rule 90 (exp -> exp LT exp .)
    GE              reduce using rule 90 (exp -> exp LT exp .)
    LE              reduce using rule 90 (exp -> exp LT exp .)
    NE              reduce using rule 90 (exp -> exp LT exp .)
    GT              reduce using rule 90 (exp -> exp LT exp .)
    LT              reduce using rule 90 (exp -> exp LT exp .)
    SEMI            reduce using rule 90 (exp -> exp LT exp .)
    RPAREN          reduce using rule 90 (exp -> exp LT exp .)
    RBRACK          reduce using rule 90 (exp -> exp LT exp .)
    COMMA           reduce using rule 90 (exp -> exp LT exp .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! PLUS            [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]


state 182

    (85) exp -> exp DIF exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for DIF resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    SEMI            reduce using rule 85 (exp -> exp DIF exp .)
    RPAREN          reduce using rule 85 (exp -> exp DIF exp .)
    RBRACK          reduce using rule 85 (exp -> exp DIF exp .)
    COMMA           reduce using rule 85 (exp -> exp DIF exp .)
    OR              shift and go to state 138
    AND             shift and go to state 133
    SAME            shift and go to state 132
    DIF             shift and go to state 142
    GE              shift and go to state 135
    LE              shift and go to state 140
    NE              shift and go to state 144
    GT              shift and go to state 137
    LT              shift and go to state 141
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! OR              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! AND             [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! SAME            [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! DIF             [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! GE              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! LE              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! NE              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! GT              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! LT              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! PLUS            [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! MINUS           [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! MODULO          [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! DIVIDE          [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! TIMES           [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! POWER           [ reduce using rule 85 (exp -> exp DIF exp .) ]


state 183

    (95) exp -> exp TIMES exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 95 (exp -> exp TIMES exp .)
    AND             reduce using rule 95 (exp -> exp TIMES exp .)
    SAME            reduce using rule 95 (exp -> exp TIMES exp .)
    DIF             reduce using rule 95 (exp -> exp TIMES exp .)
    GE              reduce using rule 95 (exp -> exp TIMES exp .)
    LE              reduce using rule 95 (exp -> exp TIMES exp .)
    NE              reduce using rule 95 (exp -> exp TIMES exp .)
    GT              reduce using rule 95 (exp -> exp TIMES exp .)
    LT              reduce using rule 95 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 95 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 95 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 95 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 95 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 95 (exp -> exp TIMES exp .)
    SEMI            reduce using rule 95 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 95 (exp -> exp TIMES exp .)
    RBRACK          reduce using rule 95 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 95 (exp -> exp TIMES exp .)
    POWER           shift and go to state 131

  ! POWER           [ reduce using rule 95 (exp -> exp TIMES exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]
  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 145 ]
  ! MODULO          [ shift and go to state 136 ]
  ! DIVIDE          [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 143 ]


state 184

    (88) exp -> exp NE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 88 (exp -> exp NE exp .)
    AND             reduce using rule 88 (exp -> exp NE exp .)
    SAME            reduce using rule 88 (exp -> exp NE exp .)
    DIF             reduce using rule 88 (exp -> exp NE exp .)
    GE              reduce using rule 88 (exp -> exp NE exp .)
    LE              reduce using rule 88 (exp -> exp NE exp .)
    NE              reduce using rule 88 (exp -> exp NE exp .)
    GT              reduce using rule 88 (exp -> exp NE exp .)
    LT              reduce using rule 88 (exp -> exp NE exp .)
    SEMI            reduce using rule 88 (exp -> exp NE exp .)
    RPAREN          reduce using rule 88 (exp -> exp NE exp .)
    RBRACK          reduce using rule 88 (exp -> exp NE exp .)
    COMMA           reduce using rule 88 (exp -> exp NE exp .)
    PLUS            shift and go to state 134
    MINUS           shift and go to state 145
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! PLUS            [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]


state 185

    (92) exp -> exp MINUS exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 92 (exp -> exp MINUS exp .)
    AND             reduce using rule 92 (exp -> exp MINUS exp .)
    SAME            reduce using rule 92 (exp -> exp MINUS exp .)
    DIF             reduce using rule 92 (exp -> exp MINUS exp .)
    GE              reduce using rule 92 (exp -> exp MINUS exp .)
    LE              reduce using rule 92 (exp -> exp MINUS exp .)
    NE              reduce using rule 92 (exp -> exp MINUS exp .)
    GT              reduce using rule 92 (exp -> exp MINUS exp .)
    LT              reduce using rule 92 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 92 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 92 (exp -> exp MINUS exp .)
    SEMI            reduce using rule 92 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 92 (exp -> exp MINUS exp .)
    RBRACK          reduce using rule 92 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 92 (exp -> exp MINUS exp .)
    MODULO          shift and go to state 136
    DIVIDE          shift and go to state 139
    TIMES           shift and go to state 143
    POWER           shift and go to state 131

  ! MODULO          [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! TIMES           [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! OR              [ shift and go to state 138 ]
  ! AND             [ shift and go to state 133 ]
  ! SAME            [ shift and go to state 132 ]
  ! DIF             [ shift and go to state 142 ]
  ! GE              [ shift and go to state 135 ]
  ! LE              [ shift and go to state 140 ]
  ! NE              [ shift and go to state 144 ]
  ! GT              [ shift and go to state 137 ]
  ! LT              [ shift and go to state 141 ]
  ! PLUS            [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 145 ]


state 186

    (98) exp -> ID pushdeclaredid LBRACK . expression RBRACK pushdeclaredarray
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 208
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 187

    (107) exp -> LPAREN exp RPAREN .

    OR              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    SAME            reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    DIF             reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    NE              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    RBRACK          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 107 (exp -> LPAREN exp RPAREN .)


state 188

    (105) exp -> FALSE settypebool pushcons .

    OR              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    AND             reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    SAME            reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    DIF             reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    GE              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    LE              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    NE              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    GT              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    LT              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    PLUS            reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    MINUS           reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    MODULO          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    DIVIDE          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    TIMES           reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    POWER           reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    SEMI            reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    RPAREN          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    RBRACK          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    COMMA           reduce using rule 105 (exp -> FALSE settypebool pushcons .)


state 189

    (114) pushcons -> pushtype .

    OR              reduce using rule 114 (pushcons -> pushtype .)
    AND             reduce using rule 114 (pushcons -> pushtype .)
    SAME            reduce using rule 114 (pushcons -> pushtype .)
    DIF             reduce using rule 114 (pushcons -> pushtype .)
    GE              reduce using rule 114 (pushcons -> pushtype .)
    LE              reduce using rule 114 (pushcons -> pushtype .)
    NE              reduce using rule 114 (pushcons -> pushtype .)
    GT              reduce using rule 114 (pushcons -> pushtype .)
    LT              reduce using rule 114 (pushcons -> pushtype .)
    PLUS            reduce using rule 114 (pushcons -> pushtype .)
    MINUS           reduce using rule 114 (pushcons -> pushtype .)
    MODULO          reduce using rule 114 (pushcons -> pushtype .)
    DIVIDE          reduce using rule 114 (pushcons -> pushtype .)
    TIMES           reduce using rule 114 (pushcons -> pushtype .)
    POWER           reduce using rule 114 (pushcons -> pushtype .)
    SEMI            reduce using rule 114 (pushcons -> pushtype .)
    RPAREN          reduce using rule 114 (pushcons -> pushtype .)
    RBRACK          reduce using rule 114 (pushcons -> pushtype .)
    COMMA           reduce using rule 114 (pushcons -> pushtype .)


state 190

    (104) exp -> TRUE settypebool pushcons .

    OR              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    AND             reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    SAME            reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    DIF             reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    GE              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    LE              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    NE              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    GT              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    LT              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    PLUS            reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    MINUS           reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    MODULO          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    DIVIDE          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    TIMES           reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    POWER           reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    SEMI            reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    RPAREN          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    RBRACK          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    COMMA           reduce using rule 104 (exp -> TRUE settypebool pushcons .)


state 191

    (102) exp -> FRACTION_CONS settypefrac pushcons .

    OR              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    AND             reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    SAME            reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    DIF             reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    GE              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    LE              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    NE              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    GT              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    LT              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    PLUS            reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    MINUS           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    MODULO          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    DIVIDE          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    TIMES           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    POWER           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    SEMI            reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    RPAREN          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    RBRACK          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    COMMA           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)


state 192

    (99) exp -> LBRACK exp RBRACK .

    OR              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    AND             reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    SAME            reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    DIF             reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    GE              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    LE              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    NE              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    GT              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    LT              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    PLUS            reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    MINUS           reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    MODULO          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    DIVIDE          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    TIMES           reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    POWER           reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    SEMI            reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    RPAREN          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    RBRACK          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    COMMA           reduce using rule 99 (exp -> LBRACK exp RBRACK .)


state 193

    (101) exp -> STRING_CONS settypestring pushcons .

    OR              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    AND             reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    SAME            reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    DIF             reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    GE              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    LE              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    NE              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    GT              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    LT              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    PLUS            reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    MINUS           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    MODULO          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    DIVIDE          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    TIMES           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    POWER           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    SEMI            reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    RPAREN          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    RBRACK          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    COMMA           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)


state 194

    (103) exp -> DECIMAL_CONS settypedec pushcons .

    OR              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    AND             reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    SAME            reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    DIF             reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    GE              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    LE              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    NE              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    GT              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    LT              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    PLUS            reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    MINUS           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    MODULO          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    DIVIDE          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    TIMES           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    POWER           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    SEMI            reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    RPAREN          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    RBRACK          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    COMMA           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)


state 195

    (100) exp -> INTEGER_CONS settypeint pushcons .

    OR              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    AND             reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    SAME            reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    DIF             reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    GE              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    LE              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    NE              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    GT              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    LT              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    PLUS            reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    MINUS           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    MODULO          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    DIVIDE          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    TIMES           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    POWER           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    SEMI            reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    RPAREN          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    RBRACK          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    COMMA           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)


state 196

    (14) block -> LBRACE var vartoparam RBRACE deletelocal .

    BOOLEAN         reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    INTEGER         reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    DECIMAL         reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    STRING          reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    FRACTION        reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    VOID            reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    $end            reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)


state 197

    (15) deletelocal -> empty .

    BOOLEAN         reduce using rule 15 (deletelocal -> empty .)
    INTEGER         reduce using rule 15 (deletelocal -> empty .)
    DECIMAL         reduce using rule 15 (deletelocal -> empty .)
    STRING          reduce using rule 15 (deletelocal -> empty .)
    FRACTION        reduce using rule 15 (deletelocal -> empty .)
    VOID            reduce using rule 15 (deletelocal -> empty .)
    $end            reduce using rule 15 (deletelocal -> empty .)


state 198

    (13) block -> LBRACE var vartoparam statements RBRACE . deletelocal
    (15) deletelocal -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    deletelocal                    shift and go to state 209
    empty                          shift and go to state 197

state 199

    (37) funcall -> CALL ID pushid LPAREN . eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID pushid LPAREN . eragener RPAREN assignvalues
    (39) eragener -> . empty
    (115) empty -> .

    RPAREN          reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 211
    eragener                       shift and go to state 210

state 200

    (49) while -> WHILE pushjump LPAREN expression . RPAREN gotof simpleblock gotowhile

    RPAREN          shift and go to state 212


state 201

    (78) assignment -> ID pushid LBRACK expression . RBRACK EQUALS expression SEMI updatecell

    RBRACK          shift and go to state 213


state 202

    (77) assignment -> ID pushid EQUALS expression . SEMI updatevar

    SEMI            shift and go to state 214


state 203

    (45) for -> LPAREN assignment expression SEMI . expression RPAREN simpleblock
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 215
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 204

    (51) condition -> IF LPAREN expression RPAREN . gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression RPAREN . gotof simpleblock updatejump
    (54) gotof -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    gotof                          shift and go to state 216
    empty                          shift and go to state 217

state 205

    (46) dowhile -> DO pushjump simpleblock WHILE . LPAREN expression RPAREN gotot

    LPAREN          shift and go to state 218


state 206

    (20) simpleblock -> LBRACE RBRACE .

    WHILE           reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    ELSE            reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    IF              reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    ID              reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    LPAREN          reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    DO              reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    PRINT           reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    CALL            reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    RETURN          reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    INPUT           reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    RBRACE          reduce using rule 20 (simpleblock -> LBRACE RBRACE .)


state 207

    (19) simpleblock -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 219


state 208

    (98) exp -> ID pushdeclaredid LBRACK expression . RBRACK pushdeclaredarray

    RBRACK          shift and go to state 220


state 209

    (13) block -> LBRACE var vartoparam statements RBRACE deletelocal .

    BOOLEAN         reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    INTEGER         reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    DECIMAL         reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    STRING          reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    FRACTION        reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    VOID            reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    $end            reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)


state 210

    (37) funcall -> CALL ID pushid LPAREN eragener . startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID pushid LPAREN eragener . RPAREN assignvalues
    (40) startcount -> . empty
    (115) empty -> .

    RPAREN          shift and go to state 223
    ID              reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)

    startcount                     shift and go to state 221
    empty                          shift and go to state 222

state 211

    (39) eragener -> empty .

    RPAREN          reduce using rule 39 (eragener -> empty .)
    ID              reduce using rule 39 (eragener -> empty .)
    LBRACK          reduce using rule 39 (eragener -> empty .)
    INTEGER_CONS    reduce using rule 39 (eragener -> empty .)
    STRING_CONS     reduce using rule 39 (eragener -> empty .)
    FRACTION_CONS   reduce using rule 39 (eragener -> empty .)
    DECIMAL_CONS    reduce using rule 39 (eragener -> empty .)
    TRUE            reduce using rule 39 (eragener -> empty .)
    FALSE           reduce using rule 39 (eragener -> empty .)
    EXMARK          reduce using rule 39 (eragener -> empty .)
    LPAREN          reduce using rule 39 (eragener -> empty .)
    CALL            reduce using rule 39 (eragener -> empty .)


state 212

    (49) while -> WHILE pushjump LPAREN expression RPAREN . gotof simpleblock gotowhile
    (54) gotof -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    gotof                          shift and go to state 224
    empty                          shift and go to state 217

state 213

    (78) assignment -> ID pushid LBRACK expression RBRACK . EQUALS expression SEMI updatecell

    EQUALS          shift and go to state 225


state 214

    (77) assignment -> ID pushid EQUALS expression SEMI . updatevar
    (80) updatevar -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 226
    updatevar                      shift and go to state 227

state 215

    (45) for -> LPAREN assignment expression SEMI expression . RPAREN simpleblock

    RPAREN          shift and go to state 228


state 216

    (51) condition -> IF LPAREN expression RPAREN gotof . simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression RPAREN gotof . simpleblock updatejump
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 170

    simpleblock                    shift and go to state 229

state 217

    (54) gotof -> empty .

    LBRACE          reduce using rule 54 (gotof -> empty .)


state 218

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN . expression RPAREN gotot
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 230
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 219

    (19) simpleblock -> LBRACE statements RBRACE .

    WHILE           reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    IF              reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    ID              reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    LPAREN          reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    DO              reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    PRINT           reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    CALL            reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    INPUT           reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)


state 220

    (98) exp -> ID pushdeclaredid LBRACK expression RBRACK . pushdeclaredarray
    (113) pushdeclaredarray -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 38
    pushdeclaredarray              shift and go to state 231
    pushtype                       shift and go to state 232

state 221

    (37) funcall -> CALL ID pushid LPAREN eragener startcount . exparam RPAREN assignvalues
    (42) exparam -> . expression updatecount
    (43) exparam -> . expression updatecount COMMA exparam
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 233
    exp                            shift and go to state 101
    exparam                        shift and go to state 234
    funcall                        shift and go to state 115

state 222

    (40) startcount -> empty .

    ID              reduce using rule 40 (startcount -> empty .)
    LBRACK          reduce using rule 40 (startcount -> empty .)
    INTEGER_CONS    reduce using rule 40 (startcount -> empty .)
    STRING_CONS     reduce using rule 40 (startcount -> empty .)
    FRACTION_CONS   reduce using rule 40 (startcount -> empty .)
    DECIMAL_CONS    reduce using rule 40 (startcount -> empty .)
    TRUE            reduce using rule 40 (startcount -> empty .)
    FALSE           reduce using rule 40 (startcount -> empty .)
    EXMARK          reduce using rule 40 (startcount -> empty .)
    LPAREN          reduce using rule 40 (startcount -> empty .)
    CALL            reduce using rule 40 (startcount -> empty .)


state 223

    (38) funcall -> CALL ID pushid LPAREN eragener RPAREN . assignvalues
    (44) assignvalues -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 236
    assignvalues                   shift and go to state 235

state 224

    (49) while -> WHILE pushjump LPAREN expression RPAREN gotof . simpleblock gotowhile
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 170

    simpleblock                    shift and go to state 237

state 225

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS . expression SEMI updatecell
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 238
    exp                            shift and go to state 101
    funcall                        shift and go to state 115

state 226

    (80) updatevar -> empty .

    IF              reduce using rule 80 (updatevar -> empty .)
    ID              reduce using rule 80 (updatevar -> empty .)
    WHILE           reduce using rule 80 (updatevar -> empty .)
    LPAREN          reduce using rule 80 (updatevar -> empty .)
    DO              reduce using rule 80 (updatevar -> empty .)
    PRINT           reduce using rule 80 (updatevar -> empty .)
    CALL            reduce using rule 80 (updatevar -> empty .)
    RETURN          reduce using rule 80 (updatevar -> empty .)
    INPUT           reduce using rule 80 (updatevar -> empty .)
    RBRACE          reduce using rule 80 (updatevar -> empty .)
    LBRACK          reduce using rule 80 (updatevar -> empty .)
    INTEGER_CONS    reduce using rule 80 (updatevar -> empty .)
    STRING_CONS     reduce using rule 80 (updatevar -> empty .)
    FRACTION_CONS   reduce using rule 80 (updatevar -> empty .)
    DECIMAL_CONS    reduce using rule 80 (updatevar -> empty .)
    TRUE            reduce using rule 80 (updatevar -> empty .)
    FALSE           reduce using rule 80 (updatevar -> empty .)
    EXMARK          reduce using rule 80 (updatevar -> empty .)


state 227

    (77) assignment -> ID pushid EQUALS expression SEMI updatevar .

    ID              reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    LBRACK          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    INTEGER_CONS    reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    STRING_CONS     reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    FRACTION_CONS   reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    DECIMAL_CONS    reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    TRUE            reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    FALSE           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    EXMARK          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    LPAREN          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    CALL            reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    IF              reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    WHILE           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    DO              reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    PRINT           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    RETURN          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    INPUT           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    RBRACE          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)


state 228

    (45) for -> LPAREN assignment expression SEMI expression RPAREN . simpleblock
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 170

    simpleblock                    shift and go to state 239

state 229

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock . ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression RPAREN gotof simpleblock . updatejump
    (55) updatejump -> . empty
    (115) empty -> .

    ELSE            shift and go to state 242
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    updatejump                     shift and go to state 240
    empty                          shift and go to state 241

state 230

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN expression . RPAREN gotot

    RPAREN          shift and go to state 243


state 231

    (98) exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .

    OR              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    AND             reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    SAME            reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    DIF             reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    GE              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    LE              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    NE              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    GT              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    LT              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    PLUS            reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    MINUS           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    MODULO          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    DIVIDE          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    TIMES           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    POWER           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    SEMI            reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    RPAREN          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    RBRACK          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    COMMA           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)


state 232

    (113) pushdeclaredarray -> pushtype .

    OR              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    AND             reduce using rule 113 (pushdeclaredarray -> pushtype .)
    SAME            reduce using rule 113 (pushdeclaredarray -> pushtype .)
    DIF             reduce using rule 113 (pushdeclaredarray -> pushtype .)
    GE              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    LE              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    NE              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    GT              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    LT              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    PLUS            reduce using rule 113 (pushdeclaredarray -> pushtype .)
    MINUS           reduce using rule 113 (pushdeclaredarray -> pushtype .)
    MODULO          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    DIVIDE          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    TIMES           reduce using rule 113 (pushdeclaredarray -> pushtype .)
    POWER           reduce using rule 113 (pushdeclaredarray -> pushtype .)
    SEMI            reduce using rule 113 (pushdeclaredarray -> pushtype .)
    RPAREN          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    RBRACK          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    COMMA           reduce using rule 113 (pushdeclaredarray -> pushtype .)


state 233

    (42) exparam -> expression . updatecount
    (43) exparam -> expression . updatecount COMMA exparam
    (41) updatecount -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)

    updatecount                    shift and go to state 244
    empty                          shift and go to state 245

state 234

    (37) funcall -> CALL ID pushid LPAREN eragener startcount exparam . RPAREN assignvalues

    RPAREN          shift and go to state 246


state 235

    (38) funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .

    OR              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    AND             reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    SAME            reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    DIF             reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    GE              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    LE              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    NE              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    GT              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    LT              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    PLUS            reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    MINUS           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    MODULO          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    DIVIDE          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    TIMES           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    POWER           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    SEMI            reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    RPAREN          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    RBRACK          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    COMMA           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)


state 236

    (44) assignvalues -> empty .

    SEMI            reduce using rule 44 (assignvalues -> empty .)
    OR              reduce using rule 44 (assignvalues -> empty .)
    AND             reduce using rule 44 (assignvalues -> empty .)
    SAME            reduce using rule 44 (assignvalues -> empty .)
    DIF             reduce using rule 44 (assignvalues -> empty .)
    GE              reduce using rule 44 (assignvalues -> empty .)
    LE              reduce using rule 44 (assignvalues -> empty .)
    NE              reduce using rule 44 (assignvalues -> empty .)
    GT              reduce using rule 44 (assignvalues -> empty .)
    LT              reduce using rule 44 (assignvalues -> empty .)
    PLUS            reduce using rule 44 (assignvalues -> empty .)
    MINUS           reduce using rule 44 (assignvalues -> empty .)
    MODULO          reduce using rule 44 (assignvalues -> empty .)
    DIVIDE          reduce using rule 44 (assignvalues -> empty .)
    TIMES           reduce using rule 44 (assignvalues -> empty .)
    POWER           reduce using rule 44 (assignvalues -> empty .)
    RPAREN          reduce using rule 44 (assignvalues -> empty .)
    RBRACK          reduce using rule 44 (assignvalues -> empty .)
    COMMA           reduce using rule 44 (assignvalues -> empty .)


state 237

    (49) while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock . gotowhile
    (50) gotowhile -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 247
    gotowhile                      shift and go to state 248

state 238

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression . SEMI updatecell

    SEMI            shift and go to state 249


state 239

    (45) for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .

    IF              reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    ID              reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    WHILE           reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    LPAREN          reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    DO              reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    PRINT           reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    CALL            reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    RETURN          reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    INPUT           reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    RBRACE          reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)


state 240

    (52) condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .

    IF              reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    ID              reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    WHILE           reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    LPAREN          reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    DO              reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    PRINT           reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    CALL            reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    RETURN          reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    INPUT           reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    RBRACE          reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)


state 241

    (55) updatejump -> empty .

    IF              reduce using rule 55 (updatejump -> empty .)
    ID              reduce using rule 55 (updatejump -> empty .)
    WHILE           reduce using rule 55 (updatejump -> empty .)
    LPAREN          reduce using rule 55 (updatejump -> empty .)
    DO              reduce using rule 55 (updatejump -> empty .)
    PRINT           reduce using rule 55 (updatejump -> empty .)
    CALL            reduce using rule 55 (updatejump -> empty .)
    RETURN          reduce using rule 55 (updatejump -> empty .)
    INPUT           reduce using rule 55 (updatejump -> empty .)
    RBRACE          reduce using rule 55 (updatejump -> empty .)


state 242

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE . gotoif simpleblock updatejump
    (53) gotoif -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 250
    gotoif                         shift and go to state 251

state 243

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN . gotot
    (48) gotot -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    gotot                          shift and go to state 252
    empty                          shift and go to state 253

state 244

    (42) exparam -> expression updatecount .
    (43) exparam -> expression updatecount . COMMA exparam

    RPAREN          reduce using rule 42 (exparam -> expression updatecount .)
    COMMA           shift and go to state 254


state 245

    (41) updatecount -> empty .

    COMMA           reduce using rule 41 (updatecount -> empty .)
    RPAREN          reduce using rule 41 (updatecount -> empty .)


state 246

    (37) funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN . assignvalues
    (44) assignvalues -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 236
    assignvalues                   shift and go to state 255

state 247

    (50) gotowhile -> empty .

    IF              reduce using rule 50 (gotowhile -> empty .)
    ID              reduce using rule 50 (gotowhile -> empty .)
    WHILE           reduce using rule 50 (gotowhile -> empty .)
    LPAREN          reduce using rule 50 (gotowhile -> empty .)
    DO              reduce using rule 50 (gotowhile -> empty .)
    PRINT           reduce using rule 50 (gotowhile -> empty .)
    CALL            reduce using rule 50 (gotowhile -> empty .)
    RETURN          reduce using rule 50 (gotowhile -> empty .)
    INPUT           reduce using rule 50 (gotowhile -> empty .)
    RBRACE          reduce using rule 50 (gotowhile -> empty .)


state 248

    (49) while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .

    IF              reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    ID              reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    WHILE           reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    LPAREN          reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    DO              reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    PRINT           reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    CALL            reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    RETURN          reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    INPUT           reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    RBRACE          reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)


state 249

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI . updatecell
    (79) updatecell -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 256
    updatecell                     shift and go to state 257

state 250

    (53) gotoif -> empty .

    LBRACE          reduce using rule 53 (gotoif -> empty .)


state 251

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif . simpleblock updatejump
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 170

    simpleblock                    shift and go to state 258

state 252

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .

    IF              reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    ID              reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    WHILE           reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    LPAREN          reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    DO              reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    PRINT           reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    CALL            reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    RETURN          reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    INPUT           reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    RBRACE          reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)


state 253

    (48) gotot -> empty .

    IF              reduce using rule 48 (gotot -> empty .)
    ID              reduce using rule 48 (gotot -> empty .)
    WHILE           reduce using rule 48 (gotot -> empty .)
    LPAREN          reduce using rule 48 (gotot -> empty .)
    DO              reduce using rule 48 (gotot -> empty .)
    PRINT           reduce using rule 48 (gotot -> empty .)
    CALL            reduce using rule 48 (gotot -> empty .)
    RETURN          reduce using rule 48 (gotot -> empty .)
    INPUT           reduce using rule 48 (gotot -> empty .)
    RBRACE          reduce using rule 48 (gotot -> empty .)


state 254

    (43) exparam -> expression updatecount COMMA . exparam
    (42) exparam -> . expression updatecount
    (43) exparam -> . expression updatecount COMMA exparam
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 102
    LBRACK          shift and go to state 108
    INTEGER_CONS    shift and go to state 114
    STRING_CONS     shift and go to state 112
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 113
    TRUE            shift and go to state 106
    FALSE           shift and go to state 105
    EXMARK          shift and go to state 111
    LPAREN          shift and go to state 103
    CALL            shift and go to state 81

    expression                     shift and go to state 233
    exp                            shift and go to state 101
    exparam                        shift and go to state 259
    funcall                        shift and go to state 115

state 255

    (37) funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .

    OR              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    AND             reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    SAME            reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    DIF             reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    GE              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    LE              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    NE              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    GT              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    LT              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    PLUS            reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    MINUS           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    MODULO          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    DIVIDE          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    TIMES           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    POWER           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    SEMI            reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    RPAREN          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    RBRACK          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    COMMA           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)


state 256

    (79) updatecell -> empty .

    IF              reduce using rule 79 (updatecell -> empty .)
    ID              reduce using rule 79 (updatecell -> empty .)
    WHILE           reduce using rule 79 (updatecell -> empty .)
    LPAREN          reduce using rule 79 (updatecell -> empty .)
    DO              reduce using rule 79 (updatecell -> empty .)
    PRINT           reduce using rule 79 (updatecell -> empty .)
    CALL            reduce using rule 79 (updatecell -> empty .)
    RETURN          reduce using rule 79 (updatecell -> empty .)
    INPUT           reduce using rule 79 (updatecell -> empty .)
    RBRACE          reduce using rule 79 (updatecell -> empty .)
    LBRACK          reduce using rule 79 (updatecell -> empty .)
    INTEGER_CONS    reduce using rule 79 (updatecell -> empty .)
    STRING_CONS     reduce using rule 79 (updatecell -> empty .)
    FRACTION_CONS   reduce using rule 79 (updatecell -> empty .)
    DECIMAL_CONS    reduce using rule 79 (updatecell -> empty .)
    TRUE            reduce using rule 79 (updatecell -> empty .)
    FALSE           reduce using rule 79 (updatecell -> empty .)
    EXMARK          reduce using rule 79 (updatecell -> empty .)


state 257

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .

    ID              reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    LBRACK          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    INTEGER_CONS    reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    STRING_CONS     reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    FRACTION_CONS   reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    DECIMAL_CONS    reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    TRUE            reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    FALSE           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    EXMARK          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    LPAREN          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    CALL            reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    IF              reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    WHILE           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    DO              reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    PRINT           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    RETURN          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    INPUT           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    RBRACE          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)


state 258

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock . updatejump
    (55) updatejump -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    updatejump                     shift and go to state 260
    empty                          shift and go to state 241

state 259

    (43) exparam -> expression updatecount COMMA exparam .

    RPAREN          reduce using rule 43 (exparam -> expression updatecount COMMA exparam .)


state 260

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .

    IF              reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    ID              reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    WHILE           reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    LPAREN          reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    DO              reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    PRINT           reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    CALL            reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    RETURN          reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    INPUT           reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    RBRACE          reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OR in state 182 resolved as shift
WARNING: shift/reduce conflict for AND in state 182 resolved as shift
WARNING: shift/reduce conflict for SAME in state 182 resolved as shift
WARNING: shift/reduce conflict for DIF in state 182 resolved as shift
WARNING: shift/reduce conflict for GE in state 182 resolved as shift
WARNING: shift/reduce conflict for LE in state 182 resolved as shift
WARNING: shift/reduce conflict for NE in state 182 resolved as shift
WARNING: shift/reduce conflict for GT in state 182 resolved as shift
WARNING: shift/reduce conflict for LT in state 182 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 182 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 182 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 182 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 182 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 182 resolved as shift
WARNING: shift/reduce conflict for POWER in state 182 resolved as shift

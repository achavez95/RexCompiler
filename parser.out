Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE
    FOR
    NOT
    LQUOTE
    RQUOTE
    COMMENT
    COLON

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMI gotomain program1
Rule 2     program -> PROGRAM ID SEMI gotomain var program1
Rule 3     gotomain -> empty
Rule 4     program1 -> function program1
Rule 5     program1 -> function
Rule 6     function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
Rule 7     function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
Rule 8     setcontext -> empty
Rule 9     endfunc -> empty
Rule 10    savefunc -> empty
Rule 11    parameter -> type ID pushid
Rule 12    parameter -> type ID pushid COMMA parameter
Rule 13    block -> LBRACE var vartoparam statements RBRACE deletelocal
Rule 14    block -> LBRACE var vartoparam RBRACE deletelocal
Rule 15    deletelocal -> empty
Rule 16    vartoparam -> empty
Rule 17    block -> LBRACE statements RBRACE
Rule 18    block -> LBRACE RBRACE
Rule 19    simpleblock -> LBRACE statements RBRACE
Rule 20    simpleblock -> LBRACE RBRACE
Rule 21    savereturn -> empty
Rule 22    statements -> statement
Rule 23    statements -> statement statements
Rule 24    statement -> condition
Rule 25    statement -> assignment
Rule 26    statement -> while
Rule 27    statement -> for
Rule 28    statement -> dowhile
Rule 29    statement -> print SEMI
Rule 30    statement -> funcall SEMI
Rule 31    statement -> return SEMI
Rule 32    statement -> input SEMI
Rule 33    input -> INPUT ID pushdeclaredid
Rule 34    return -> RETURN expression savereturn
Rule 35    return -> RETURN savereturn
Rule 36    print -> PRINT expression
Rule 37    funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
Rule 38    funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues
Rule 39    eragener -> empty
Rule 40    startcount -> empty
Rule 41    updatecount -> empty
Rule 42    exparam -> expression updatecount
Rule 43    exparam -> expression updatecount COMMA exparam
Rule 44    assignvalues -> empty
Rule 45    for -> LPAREN assignment expression SEMI expression RPAREN simpleblock
Rule 46    dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
Rule 47    pushjump -> empty
Rule 48    gotot -> empty
Rule 49    while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
Rule 50    gotowhile -> empty
Rule 51    condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
Rule 52    condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump
Rule 53    gotoif -> empty
Rule 54    gotof -> empty
Rule 55    updatejump -> empty
Rule 56    var -> VAR type var1 SEMI var
Rule 57    var -> VAR type var1 SEMI
Rule 58    var1 -> ID pushid savevar allocatevar
Rule 59    var1 -> ID pushid savevar allocatevar COMMA var1
Rule 60    var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
Rule 61    var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
Rule 62    settypeint -> empty
Rule 63    settypedec -> empty
Rule 64    settypefrac -> empty
Rule 65    settypestring -> empty
Rule 66    settypebool -> empty
Rule 67    settypevoid -> empty
Rule 68    savevar -> empty
Rule 69    allocatevar -> empty
Rule 70    updatesize -> empty
Rule 71    type -> BOOLEAN settypebool
Rule 72    type -> INTEGER settypeint
Rule 73    type -> DECIMAL settypedec
Rule 74    type -> STRING settypestring
Rule 75    type -> FRACTION settypefrac
Rule 76    type -> VOID settypevoid
Rule 77    assignment -> ID pushid EQUALS expression SEMI updatevar
Rule 78    assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
Rule 79    updatecell -> empty
Rule 80    updatevar -> empty
Rule 81    expression -> exp
Rule 82    exp -> exp OR exp
Rule 83    exp -> exp AND exp
Rule 84    exp -> exp SAME exp
Rule 85    exp -> exp DIF exp
Rule 86    exp -> exp GE exp
Rule 87    exp -> exp LE exp
Rule 88    exp -> exp NE exp
Rule 89    exp -> exp GT exp
Rule 90    exp -> exp LT exp
Rule 91    exp -> exp PLUS exp
Rule 92    exp -> exp MINUS exp
Rule 93    exp -> exp MODULO exp
Rule 94    exp -> exp DIVIDE exp
Rule 95    exp -> exp TIMES exp
Rule 96    exp -> exp POWER exp
Rule 97    exp -> ID pushdeclaredid
Rule 98    exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
Rule 99    exp -> LBRACK exp RBRACK
Rule 100   exp -> INTEGER_CONS settypeint pushcons
Rule 101   exp -> STRING_CONS settypestring pushcons
Rule 102   exp -> FRACTION_CONS settypefrac pushcons
Rule 103   exp -> DECIMAL_CONS settypedec pushcons
Rule 104   exp -> TRUE settypebool pushcons
Rule 105   exp -> FALSE settypebool pushcons
Rule 106   exp -> EXMARK exp
Rule 107   exp -> LPAREN exp RPAREN
Rule 108   exp -> funcall pushrtn
Rule 109   pushrtn -> empty
Rule 110   pushtype -> empty
Rule 111   pushid -> pushtype
Rule 112   pushdeclaredid -> pushtype
Rule 113   pushdeclaredarray -> pushtype
Rule 114   pushcons -> pushtype
Rule 115   empty -> <empty>

Terminals, with rules where they appear

AND                  : 83
BOOLEAN              : 71
CALL                 : 37 38
COLON                : 
COMMA                : 12 43 59 60
COMMENT              : 
DECIMAL              : 73
DECIMAL_CONS         : 103
DIF                  : 85
DIVIDE               : 94
DO                   : 46
ELSE                 : 51
EQUALS               : 77 78
EXMARK               : 106
FALSE                : 105
FOR                  : 
FRACTION             : 75
FRACTION_CONS        : 102
FUNCTION             : 6 7
GE                   : 86
GT                   : 89
ID                   : 1 2 6 7 11 12 33 37 38 58 59 60 61 77 78 97 98
IF                   : 51 52
INPUT                : 33
INTEGER              : 72
INTEGER_CONS         : 60 61 100
LBRACE               : 13 14 17 18 19 20
LBRACK               : 60 61 78 98 99
LE                   : 87
LPAREN               : 6 7 37 38 45 46 49 51 52 107
LQUOTE               : 
LT                   : 90
MINUS                : 92
MODULO               : 93
NE                   : 88
NEWLINE              : 
NOT                  : 
OR                   : 82
PLUS                 : 91
POWER                : 96
PRINT                : 36
PROGRAM              : 1 2
RBRACE               : 13 14 17 18 19 20
RBRACK               : 60 61 78 98 99
RETURN               : 34 35
RPAREN               : 6 7 37 38 45 46 49 51 52 107
RQUOTE               : 
SAME                 : 84
SEMI                 : 1 2 29 30 31 32 45 56 57 77 78
STRING               : 74
STRING_CONS          : 101
TIMES                : 95
TRUE                 : 104
VAR                  : 56 57
VOID                 : 76
WHILE                : 46 49
error                : 

Nonterminals, with rules where they appear

allocatevar          : 58 59 60 61
assignment           : 25 45
assignvalues         : 37 38
block                : 6 7
condition            : 24
deletelocal          : 13 14
dowhile              : 28
empty                : 3 8 9 10 15 16 21 39 40 41 44 47 48 50 53 54 55 62 63 64 65 66 67 68 69 70 79 80 109 110
endfunc              : 6 7
eragener             : 37 38
exp                  : 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 99 106 107
exparam              : 37 43
expression           : 34 36 42 43 45 45 46 49 51 52 77 78 78 98
for                  : 27
funcall              : 30 108
function             : 4 5
gotof                : 49 51 52
gotoif               : 51
gotomain             : 1 2
gotot                : 46
gotowhile            : 49
input                : 32
parameter            : 6 12
print                : 29
program              : 0
program1             : 1 2 4
pushcons             : 100 101 102 103 104 105
pushdeclaredarray    : 98
pushdeclaredid       : 33 97 98
pushid               : 6 7 11 12 37 38 58 59 60 61 77 78
pushjump             : 46 49
pushrtn              : 108
pushtype             : 111 112 113 114
return               : 31
savefunc             : 6 7
savereturn           : 34 35
savevar              : 58 59 60 61
setcontext           : 6 7
settypebool          : 71 104 105
settypedec           : 73 103
settypefrac          : 75 102
settypeint           : 72 100
settypestring        : 74 101
settypevoid          : 76
simpleblock          : 45 46 49 51 51 52
startcount           : 37
statement            : 22 23
statements           : 13 17 19 23
type                 : 6 7 11 12 56 57
updatecell           : 78
updatecount          : 42 43
updatejump           : 51 52
updatesize           : 60 61
updatevar            : 77
var                  : 2 13 14 56
var1                 : 56 57 59 60
vartoparam           : 13 14
while                : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMI gotomain program1
    (2) program -> . PROGRAM ID SEMI gotomain var program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMI gotomain program1
    (2) program -> PROGRAM . ID SEMI gotomain var program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMI gotomain program1
    (2) program -> PROGRAM ID . SEMI gotomain var program1

    SEMI            shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMI . gotomain program1
    (2) program -> PROGRAM ID SEMI . gotomain var program1
    (3) gotomain -> . empty
    (115) empty -> .

    VAR             reduce using rule 115 (empty -> .)
    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 5
    gotomain                       shift and go to state 6

state 5

    (3) gotomain -> empty .

    VAR             reduce using rule 3 (gotomain -> empty .)
    BOOLEAN         reduce using rule 3 (gotomain -> empty .)
    INTEGER         reduce using rule 3 (gotomain -> empty .)
    DECIMAL         reduce using rule 3 (gotomain -> empty .)
    STRING          reduce using rule 3 (gotomain -> empty .)
    FRACTION        reduce using rule 3 (gotomain -> empty .)
    VOID            reduce using rule 3 (gotomain -> empty .)


state 6

    (1) program -> PROGRAM ID SEMI gotomain . program1
    (2) program -> PROGRAM ID SEMI gotomain . var program1
    (4) program1 -> . function program1
    (5) program1 -> . function
    (56) var -> . VAR type var1 SEMI var
    (57) var -> . VAR type var1 SEMI
    (6) function -> . type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> . type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    VAR             shift and go to state 9
    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 7
    DECIMAL         shift and go to state 12
    STRING          shift and go to state 13
    FRACTION        shift and go to state 15
    VOID            shift and go to state 11

    var                            shift and go to state 16
    function                       shift and go to state 8
    type                           shift and go to state 17
    program1                       shift and go to state 10

state 7

    (72) type -> INTEGER . settypeint
    (62) settypeint -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 18
    settypeint                     shift and go to state 19

state 8

    (4) program1 -> function . program1
    (5) program1 -> function .
    (4) program1 -> . function program1
    (5) program1 -> . function
    (6) function -> . type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> . type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    $end            reduce using rule 5 (program1 -> function .)
    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 7
    DECIMAL         shift and go to state 12
    STRING          shift and go to state 13
    FRACTION        shift and go to state 15
    VOID            shift and go to state 11

    function                       shift and go to state 8
    type                           shift and go to state 17
    program1                       shift and go to state 20

state 9

    (56) var -> VAR . type var1 SEMI var
    (57) var -> VAR . type var1 SEMI
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 7
    DECIMAL         shift and go to state 12
    STRING          shift and go to state 13
    FRACTION        shift and go to state 15
    VOID            shift and go to state 11

    type                           shift and go to state 21

state 10

    (1) program -> PROGRAM ID SEMI gotomain program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMI gotomain program1 .)


state 11

    (76) type -> VOID . settypevoid
    (67) settypevoid -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 22
    settypevoid                    shift and go to state 23

state 12

    (73) type -> DECIMAL . settypedec
    (63) settypedec -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 24
    settypedec                     shift and go to state 25

state 13

    (74) type -> STRING . settypestring
    (65) settypestring -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 26
    settypestring                  shift and go to state 27

state 14

    (71) type -> BOOLEAN . settypebool
    (66) settypebool -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 28
    settypebool                    shift and go to state 29

state 15

    (75) type -> FRACTION . settypefrac
    (64) settypefrac -> . empty
    (115) empty -> .

    FUNCTION        reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    empty                          shift and go to state 30
    settypefrac                    shift and go to state 31

state 16

    (2) program -> PROGRAM ID SEMI gotomain var . program1
    (4) program1 -> . function program1
    (5) program1 -> . function
    (6) function -> . type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> . type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 7
    DECIMAL         shift and go to state 12
    STRING          shift and go to state 13
    FRACTION        shift and go to state 15
    VOID            shift and go to state 11

    function                       shift and go to state 8
    program1                       shift and go to state 32
    type                           shift and go to state 17

state 17

    (6) function -> type . FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type . FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc

    FUNCTION        shift and go to state 33


state 18

    (62) settypeint -> empty .

    OR              reduce using rule 62 (settypeint -> empty .)
    AND             reduce using rule 62 (settypeint -> empty .)
    SAME            reduce using rule 62 (settypeint -> empty .)
    DIF             reduce using rule 62 (settypeint -> empty .)
    GE              reduce using rule 62 (settypeint -> empty .)
    LE              reduce using rule 62 (settypeint -> empty .)
    NE              reduce using rule 62 (settypeint -> empty .)
    GT              reduce using rule 62 (settypeint -> empty .)
    LT              reduce using rule 62 (settypeint -> empty .)
    PLUS            reduce using rule 62 (settypeint -> empty .)
    MINUS           reduce using rule 62 (settypeint -> empty .)
    MODULO          reduce using rule 62 (settypeint -> empty .)
    DIVIDE          reduce using rule 62 (settypeint -> empty .)
    TIMES           reduce using rule 62 (settypeint -> empty .)
    POWER           reduce using rule 62 (settypeint -> empty .)
    SEMI            reduce using rule 62 (settypeint -> empty .)
    RBRACK          reduce using rule 62 (settypeint -> empty .)
    RPAREN          reduce using rule 62 (settypeint -> empty .)
    COMMA           reduce using rule 62 (settypeint -> empty .)
    FUNCTION        reduce using rule 62 (settypeint -> empty .)
    ID              reduce using rule 62 (settypeint -> empty .)


state 19

    (72) type -> INTEGER settypeint .

    ID              reduce using rule 72 (type -> INTEGER settypeint .)
    FUNCTION        reduce using rule 72 (type -> INTEGER settypeint .)


state 20

    (4) program1 -> function program1 .

    $end            reduce using rule 4 (program1 -> function program1 .)


state 21

    (56) var -> VAR type . var1 SEMI var
    (57) var -> VAR type . var1 SEMI
    (58) var1 -> . ID pushid savevar allocatevar
    (59) var1 -> . ID pushid savevar allocatevar COMMA var1
    (60) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 34

    var1                           shift and go to state 35

state 22

    (67) settypevoid -> empty .

    FUNCTION        reduce using rule 67 (settypevoid -> empty .)
    ID              reduce using rule 67 (settypevoid -> empty .)


state 23

    (76) type -> VOID settypevoid .

    ID              reduce using rule 76 (type -> VOID settypevoid .)
    FUNCTION        reduce using rule 76 (type -> VOID settypevoid .)


state 24

    (63) settypedec -> empty .

    FUNCTION        reduce using rule 63 (settypedec -> empty .)
    ID              reduce using rule 63 (settypedec -> empty .)
    OR              reduce using rule 63 (settypedec -> empty .)
    AND             reduce using rule 63 (settypedec -> empty .)
    SAME            reduce using rule 63 (settypedec -> empty .)
    DIF             reduce using rule 63 (settypedec -> empty .)
    GE              reduce using rule 63 (settypedec -> empty .)
    LE              reduce using rule 63 (settypedec -> empty .)
    NE              reduce using rule 63 (settypedec -> empty .)
    GT              reduce using rule 63 (settypedec -> empty .)
    LT              reduce using rule 63 (settypedec -> empty .)
    PLUS            reduce using rule 63 (settypedec -> empty .)
    MINUS           reduce using rule 63 (settypedec -> empty .)
    MODULO          reduce using rule 63 (settypedec -> empty .)
    DIVIDE          reduce using rule 63 (settypedec -> empty .)
    TIMES           reduce using rule 63 (settypedec -> empty .)
    POWER           reduce using rule 63 (settypedec -> empty .)
    SEMI            reduce using rule 63 (settypedec -> empty .)
    RBRACK          reduce using rule 63 (settypedec -> empty .)
    RPAREN          reduce using rule 63 (settypedec -> empty .)
    COMMA           reduce using rule 63 (settypedec -> empty .)


state 25

    (73) type -> DECIMAL settypedec .

    ID              reduce using rule 73 (type -> DECIMAL settypedec .)
    FUNCTION        reduce using rule 73 (type -> DECIMAL settypedec .)


state 26

    (65) settypestring -> empty .

    FUNCTION        reduce using rule 65 (settypestring -> empty .)
    ID              reduce using rule 65 (settypestring -> empty .)
    OR              reduce using rule 65 (settypestring -> empty .)
    AND             reduce using rule 65 (settypestring -> empty .)
    SAME            reduce using rule 65 (settypestring -> empty .)
    DIF             reduce using rule 65 (settypestring -> empty .)
    GE              reduce using rule 65 (settypestring -> empty .)
    LE              reduce using rule 65 (settypestring -> empty .)
    NE              reduce using rule 65 (settypestring -> empty .)
    GT              reduce using rule 65 (settypestring -> empty .)
    LT              reduce using rule 65 (settypestring -> empty .)
    PLUS            reduce using rule 65 (settypestring -> empty .)
    MINUS           reduce using rule 65 (settypestring -> empty .)
    MODULO          reduce using rule 65 (settypestring -> empty .)
    DIVIDE          reduce using rule 65 (settypestring -> empty .)
    TIMES           reduce using rule 65 (settypestring -> empty .)
    POWER           reduce using rule 65 (settypestring -> empty .)
    SEMI            reduce using rule 65 (settypestring -> empty .)
    RBRACK          reduce using rule 65 (settypestring -> empty .)
    RPAREN          reduce using rule 65 (settypestring -> empty .)
    COMMA           reduce using rule 65 (settypestring -> empty .)


state 27

    (74) type -> STRING settypestring .

    ID              reduce using rule 74 (type -> STRING settypestring .)
    FUNCTION        reduce using rule 74 (type -> STRING settypestring .)


state 28

    (66) settypebool -> empty .

    FUNCTION        reduce using rule 66 (settypebool -> empty .)
    ID              reduce using rule 66 (settypebool -> empty .)
    OR              reduce using rule 66 (settypebool -> empty .)
    AND             reduce using rule 66 (settypebool -> empty .)
    SAME            reduce using rule 66 (settypebool -> empty .)
    DIF             reduce using rule 66 (settypebool -> empty .)
    GE              reduce using rule 66 (settypebool -> empty .)
    LE              reduce using rule 66 (settypebool -> empty .)
    NE              reduce using rule 66 (settypebool -> empty .)
    GT              reduce using rule 66 (settypebool -> empty .)
    LT              reduce using rule 66 (settypebool -> empty .)
    PLUS            reduce using rule 66 (settypebool -> empty .)
    MINUS           reduce using rule 66 (settypebool -> empty .)
    MODULO          reduce using rule 66 (settypebool -> empty .)
    DIVIDE          reduce using rule 66 (settypebool -> empty .)
    TIMES           reduce using rule 66 (settypebool -> empty .)
    POWER           reduce using rule 66 (settypebool -> empty .)
    SEMI            reduce using rule 66 (settypebool -> empty .)
    RBRACK          reduce using rule 66 (settypebool -> empty .)
    RPAREN          reduce using rule 66 (settypebool -> empty .)
    COMMA           reduce using rule 66 (settypebool -> empty .)


state 29

    (71) type -> BOOLEAN settypebool .

    ID              reduce using rule 71 (type -> BOOLEAN settypebool .)
    FUNCTION        reduce using rule 71 (type -> BOOLEAN settypebool .)


state 30

    (64) settypefrac -> empty .

    OR              reduce using rule 64 (settypefrac -> empty .)
    AND             reduce using rule 64 (settypefrac -> empty .)
    SAME            reduce using rule 64 (settypefrac -> empty .)
    DIF             reduce using rule 64 (settypefrac -> empty .)
    GE              reduce using rule 64 (settypefrac -> empty .)
    LE              reduce using rule 64 (settypefrac -> empty .)
    NE              reduce using rule 64 (settypefrac -> empty .)
    GT              reduce using rule 64 (settypefrac -> empty .)
    LT              reduce using rule 64 (settypefrac -> empty .)
    PLUS            reduce using rule 64 (settypefrac -> empty .)
    MINUS           reduce using rule 64 (settypefrac -> empty .)
    MODULO          reduce using rule 64 (settypefrac -> empty .)
    DIVIDE          reduce using rule 64 (settypefrac -> empty .)
    TIMES           reduce using rule 64 (settypefrac -> empty .)
    POWER           reduce using rule 64 (settypefrac -> empty .)
    SEMI            reduce using rule 64 (settypefrac -> empty .)
    RBRACK          reduce using rule 64 (settypefrac -> empty .)
    RPAREN          reduce using rule 64 (settypefrac -> empty .)
    COMMA           reduce using rule 64 (settypefrac -> empty .)
    FUNCTION        reduce using rule 64 (settypefrac -> empty .)
    ID              reduce using rule 64 (settypefrac -> empty .)


state 31

    (75) type -> FRACTION settypefrac .

    ID              reduce using rule 75 (type -> FRACTION settypefrac .)
    FUNCTION        reduce using rule 75 (type -> FRACTION settypefrac .)


state 32

    (2) program -> PROGRAM ID SEMI gotomain var program1 .

    $end            reduce using rule 2 (program -> PROGRAM ID SEMI gotomain var program1 .)


state 33

    (6) function -> type FUNCTION . ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION . ID pushid setcontext LPAREN RPAREN savefunc block endfunc

    ID              shift and go to state 36


state 34

    (58) var1 -> ID . pushid savevar allocatevar
    (59) var1 -> ID . pushid savevar allocatevar COMMA var1
    (60) var1 -> ID . pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID . pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushid                         shift and go to state 39
    pushtype                       shift and go to state 38

state 35

    (56) var -> VAR type var1 . SEMI var
    (57) var -> VAR type var1 . SEMI

    SEMI            shift and go to state 40


state 36

    (6) function -> type FUNCTION ID . pushid setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID . pushid setcontext LPAREN RPAREN savefunc block endfunc
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushid                         shift and go to state 41
    pushtype                       shift and go to state 38

state 37

    (110) pushtype -> empty .

    OR              reduce using rule 110 (pushtype -> empty .)
    AND             reduce using rule 110 (pushtype -> empty .)
    SAME            reduce using rule 110 (pushtype -> empty .)
    DIF             reduce using rule 110 (pushtype -> empty .)
    GE              reduce using rule 110 (pushtype -> empty .)
    LE              reduce using rule 110 (pushtype -> empty .)
    NE              reduce using rule 110 (pushtype -> empty .)
    GT              reduce using rule 110 (pushtype -> empty .)
    LT              reduce using rule 110 (pushtype -> empty .)
    PLUS            reduce using rule 110 (pushtype -> empty .)
    MINUS           reduce using rule 110 (pushtype -> empty .)
    MODULO          reduce using rule 110 (pushtype -> empty .)
    DIVIDE          reduce using rule 110 (pushtype -> empty .)
    TIMES           reduce using rule 110 (pushtype -> empty .)
    POWER           reduce using rule 110 (pushtype -> empty .)
    SEMI            reduce using rule 110 (pushtype -> empty .)
    RBRACK          reduce using rule 110 (pushtype -> empty .)
    RPAREN          reduce using rule 110 (pushtype -> empty .)
    COMMA           reduce using rule 110 (pushtype -> empty .)
    LPAREN          reduce using rule 110 (pushtype -> empty .)
    LBRACK          reduce using rule 110 (pushtype -> empty .)
    EQUALS          reduce using rule 110 (pushtype -> empty .)


state 38

    (111) pushid -> pushtype .

    LPAREN          reduce using rule 111 (pushid -> pushtype .)
    EQUALS          reduce using rule 111 (pushid -> pushtype .)
    LBRACK          reduce using rule 111 (pushid -> pushtype .)
    COMMA           reduce using rule 111 (pushid -> pushtype .)
    SEMI            reduce using rule 111 (pushid -> pushtype .)
    RPAREN          reduce using rule 111 (pushid -> pushtype .)


state 39

    (58) var1 -> ID pushid . savevar allocatevar
    (59) var1 -> ID pushid . savevar allocatevar COMMA var1
    (60) var1 -> ID pushid . savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid . savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (68) savevar -> . empty
    (115) empty -> .

    LBRACK          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    savevar                        shift and go to state 42
    empty                          shift and go to state 43

state 40

    (56) var -> VAR type var1 SEMI . var
    (57) var -> VAR type var1 SEMI .
    (56) var -> . VAR type var1 SEMI var
    (57) var -> . VAR type var1 SEMI

    BOOLEAN         reduce using rule 57 (var -> VAR type var1 SEMI .)
    INTEGER         reduce using rule 57 (var -> VAR type var1 SEMI .)
    DECIMAL         reduce using rule 57 (var -> VAR type var1 SEMI .)
    STRING          reduce using rule 57 (var -> VAR type var1 SEMI .)
    FRACTION        reduce using rule 57 (var -> VAR type var1 SEMI .)
    VOID            reduce using rule 57 (var -> VAR type var1 SEMI .)
    RBRACE          reduce using rule 57 (var -> VAR type var1 SEMI .)
    IF              reduce using rule 57 (var -> VAR type var1 SEMI .)
    ID              reduce using rule 57 (var -> VAR type var1 SEMI .)
    WHILE           reduce using rule 57 (var -> VAR type var1 SEMI .)
    LPAREN          reduce using rule 57 (var -> VAR type var1 SEMI .)
    DO              reduce using rule 57 (var -> VAR type var1 SEMI .)
    PRINT           reduce using rule 57 (var -> VAR type var1 SEMI .)
    CALL            reduce using rule 57 (var -> VAR type var1 SEMI .)
    RETURN          reduce using rule 57 (var -> VAR type var1 SEMI .)
    INPUT           reduce using rule 57 (var -> VAR type var1 SEMI .)
    VAR             shift and go to state 9

    var                            shift and go to state 44

state 41

    (6) function -> type FUNCTION ID pushid . setcontext LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID pushid . setcontext LPAREN RPAREN savefunc block endfunc
    (8) setcontext -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 45
    setcontext                     shift and go to state 46

state 42

    (58) var1 -> ID pushid savevar . allocatevar
    (59) var1 -> ID pushid savevar . allocatevar COMMA var1
    (60) var1 -> ID pushid savevar . LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar . LBRACK INTEGER_CONS updatesize RBRACK allocatevar
    (69) allocatevar -> . empty
    (115) empty -> .

    LBRACK          shift and go to state 49
    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    allocatevar                    shift and go to state 47
    empty                          shift and go to state 48

state 43

    (68) savevar -> empty .

    LBRACK          reduce using rule 68 (savevar -> empty .)
    COMMA           reduce using rule 68 (savevar -> empty .)
    SEMI            reduce using rule 68 (savevar -> empty .)


state 44

    (56) var -> VAR type var1 SEMI var .

    BOOLEAN         reduce using rule 56 (var -> VAR type var1 SEMI var .)
    INTEGER         reduce using rule 56 (var -> VAR type var1 SEMI var .)
    DECIMAL         reduce using rule 56 (var -> VAR type var1 SEMI var .)
    STRING          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    FRACTION        reduce using rule 56 (var -> VAR type var1 SEMI var .)
    VOID            reduce using rule 56 (var -> VAR type var1 SEMI var .)
    RBRACE          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    IF              reduce using rule 56 (var -> VAR type var1 SEMI var .)
    ID              reduce using rule 56 (var -> VAR type var1 SEMI var .)
    WHILE           reduce using rule 56 (var -> VAR type var1 SEMI var .)
    LPAREN          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    DO              reduce using rule 56 (var -> VAR type var1 SEMI var .)
    PRINT           reduce using rule 56 (var -> VAR type var1 SEMI var .)
    CALL            reduce using rule 56 (var -> VAR type var1 SEMI var .)
    RETURN          reduce using rule 56 (var -> VAR type var1 SEMI var .)
    INPUT           reduce using rule 56 (var -> VAR type var1 SEMI var .)


state 45

    (8) setcontext -> empty .

    LPAREN          reduce using rule 8 (setcontext -> empty .)


state 46

    (6) function -> type FUNCTION ID pushid setcontext . LPAREN parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID pushid setcontext . LPAREN RPAREN savefunc block endfunc

    LPAREN          shift and go to state 50


state 47

    (58) var1 -> ID pushid savevar allocatevar .
    (59) var1 -> ID pushid savevar allocatevar . COMMA var1

    SEMI            reduce using rule 58 (var1 -> ID pushid savevar allocatevar .)
    COMMA           shift and go to state 51


state 48

    (69) allocatevar -> empty .

    COMMA           reduce using rule 69 (allocatevar -> empty .)
    SEMI            reduce using rule 69 (allocatevar -> empty .)


state 49

    (60) var1 -> ID pushid savevar LBRACK . INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK . INTEGER_CONS updatesize RBRACK allocatevar

    INTEGER_CONS    shift and go to state 52


state 50

    (6) function -> type FUNCTION ID pushid setcontext LPAREN . parameter RPAREN savefunc block endfunc
    (7) function -> type FUNCTION ID pushid setcontext LPAREN . RPAREN savefunc block endfunc
    (11) parameter -> . type ID pushid
    (12) parameter -> . type ID pushid COMMA parameter
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    RPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 7
    DECIMAL         shift and go to state 12
    STRING          shift and go to state 13
    FRACTION        shift and go to state 15
    VOID            shift and go to state 11

    type                           shift and go to state 53
    parameter                      shift and go to state 54

state 51

    (59) var1 -> ID pushid savevar allocatevar COMMA . var1
    (58) var1 -> . ID pushid savevar allocatevar
    (59) var1 -> . ID pushid savevar allocatevar COMMA var1
    (60) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 34

    var1                           shift and go to state 56

state 52

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS . updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS . updatesize RBRACK allocatevar
    (70) updatesize -> . empty
    (115) empty -> .

    RBRACK          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 57
    updatesize                     shift and go to state 58

state 53

    (11) parameter -> type . ID pushid
    (12) parameter -> type . ID pushid COMMA parameter

    ID              shift and go to state 59


state 54

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter . RPAREN savefunc block endfunc

    RPAREN          shift and go to state 60


state 55

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN . savefunc block endfunc
    (10) savefunc -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 61
    savefunc                       shift and go to state 62

state 56

    (59) var1 -> ID pushid savevar allocatevar COMMA var1 .

    SEMI            reduce using rule 59 (var1 -> ID pushid savevar allocatevar COMMA var1 .)


state 57

    (70) updatesize -> empty .

    RBRACK          reduce using rule 70 (updatesize -> empty .)


state 58

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize . RBRACK allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize . RBRACK allocatevar

    RBRACK          shift and go to state 63


state 59

    (11) parameter -> type ID . pushid
    (12) parameter -> type ID . pushid COMMA parameter
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushid                         shift and go to state 64
    pushtype                       shift and go to state 38

state 60

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN . savefunc block endfunc
    (10) savefunc -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 61
    savefunc                       shift and go to state 65

state 61

    (10) savefunc -> empty .

    LBRACE          reduce using rule 10 (savefunc -> empty .)


state 62

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc . block endfunc
    (13) block -> . LBRACE var vartoparam statements RBRACE deletelocal
    (14) block -> . LBRACE var vartoparam RBRACE deletelocal
    (17) block -> . LBRACE statements RBRACE
    (18) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 66

    block                          shift and go to state 67

state 63

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK . allocatevar COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK . allocatevar
    (69) allocatevar -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)

    allocatevar                    shift and go to state 68
    empty                          shift and go to state 48

state 64

    (11) parameter -> type ID pushid .
    (12) parameter -> type ID pushid . COMMA parameter

    RPAREN          reduce using rule 11 (parameter -> type ID pushid .)
    COMMA           shift and go to state 69


state 65

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc . block endfunc
    (13) block -> . LBRACE var vartoparam statements RBRACE deletelocal
    (14) block -> . LBRACE var vartoparam RBRACE deletelocal
    (17) block -> . LBRACE statements RBRACE
    (18) block -> . LBRACE RBRACE

    LBRACE          shift and go to state 66

    block                          shift and go to state 70

state 66

    (13) block -> LBRACE . var vartoparam statements RBRACE deletelocal
    (14) block -> LBRACE . var vartoparam RBRACE deletelocal
    (17) block -> LBRACE . statements RBRACE
    (18) block -> LBRACE . RBRACE
    (56) var -> . VAR type var1 SEMI var
    (57) var -> . VAR type var1 SEMI
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          shift and go to state 81
    VAR             shift and go to state 9
    IF              shift and go to state 76
    ID              shift and go to state 73
    WHILE           shift and go to state 75
    LPAREN          shift and go to state 80
    DO              shift and go to state 89
    PRINT           shift and go to state 77
    CALL            shift and go to state 91
    RETURN          shift and go to state 71
    INPUT           shift and go to state 72

    while                          shift and go to state 79
    print                          shift and go to state 85
    return                         shift and go to state 82
    funcall                        shift and go to state 74
    input                          shift and go to state 83
    assignment                     shift and go to state 84
    condition                      shift and go to state 86
    dowhile                        shift and go to state 87
    statement                      shift and go to state 88
    var                            shift and go to state 78
    statements                     shift and go to state 92
    for                            shift and go to state 90

state 67

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block . endfunc
    (9) endfunc -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 93
    endfunc                        shift and go to state 94

state 68

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar . COMMA var1
    (61) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar .

    COMMA           shift and go to state 95
    SEMI            reduce using rule 61 (var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar .)


state 69

    (12) parameter -> type ID pushid COMMA . parameter
    (11) parameter -> . type ID pushid
    (12) parameter -> . type ID pushid COMMA parameter
    (71) type -> . BOOLEAN settypebool
    (72) type -> . INTEGER settypeint
    (73) type -> . DECIMAL settypedec
    (74) type -> . STRING settypestring
    (75) type -> . FRACTION settypefrac
    (76) type -> . VOID settypevoid

    BOOLEAN         shift and go to state 14
    INTEGER         shift and go to state 7
    DECIMAL         shift and go to state 12
    STRING          shift and go to state 13
    FRACTION        shift and go to state 15
    VOID            shift and go to state 11

    type                           shift and go to state 53
    parameter                      shift and go to state 96

state 70

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block . endfunc
    (9) endfunc -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 93
    endfunc                        shift and go to state 97

state 71

    (34) return -> RETURN . expression savereturn
    (35) return -> RETURN . savereturn
    (81) expression -> . exp
    (21) savereturn -> . empty
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (115) empty -> .
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    SEMI            reduce using rule 115 (empty -> .)
    CALL            shift and go to state 91

    empty                          shift and go to state 98
    funcall                        shift and go to state 101
    savereturn                     shift and go to state 110
    exp                            shift and go to state 112
    expression                     shift and go to state 104

state 72

    (33) input -> INPUT . ID pushdeclaredid

    ID              shift and go to state 113


state 73

    (77) assignment -> ID . pushid EQUALS expression SEMI updatevar
    (78) assignment -> ID . pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    EQUALS          reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushid                         shift and go to state 114
    pushtype                       shift and go to state 38

state 74

    (30) statement -> funcall . SEMI

    SEMI            shift and go to state 115


state 75

    (49) while -> WHILE . pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (47) pushjump -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 116
    pushjump                       shift and go to state 117

state 76

    (51) condition -> IF . LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF . LPAREN expression RPAREN gotof simpleblock updatejump

    LPAREN          shift and go to state 118


state 77

    (36) print -> PRINT . expression
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 119

state 78

    (13) block -> LBRACE var . vartoparam statements RBRACE deletelocal
    (14) block -> LBRACE var . vartoparam RBRACE deletelocal
    (16) vartoparam -> . empty
    (115) empty -> .

    RBRACE          reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 120
    vartoparam                     shift and go to state 121

state 79

    (26) statement -> while .

    IF              reduce using rule 26 (statement -> while .)
    ID              reduce using rule 26 (statement -> while .)
    WHILE           reduce using rule 26 (statement -> while .)
    LPAREN          reduce using rule 26 (statement -> while .)
    DO              reduce using rule 26 (statement -> while .)
    PRINT           reduce using rule 26 (statement -> while .)
    CALL            reduce using rule 26 (statement -> while .)
    RETURN          reduce using rule 26 (statement -> while .)
    INPUT           reduce using rule 26 (statement -> while .)
    RBRACE          reduce using rule 26 (statement -> while .)


state 80

    (45) for -> LPAREN . assignment expression SEMI expression RPAREN simpleblock
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell

    ID              shift and go to state 73

    assignment                     shift and go to state 122

state 81

    (18) block -> LBRACE RBRACE .

    BOOLEAN         reduce using rule 18 (block -> LBRACE RBRACE .)
    INTEGER         reduce using rule 18 (block -> LBRACE RBRACE .)
    DECIMAL         reduce using rule 18 (block -> LBRACE RBRACE .)
    STRING          reduce using rule 18 (block -> LBRACE RBRACE .)
    FRACTION        reduce using rule 18 (block -> LBRACE RBRACE .)
    VOID            reduce using rule 18 (block -> LBRACE RBRACE .)
    $end            reduce using rule 18 (block -> LBRACE RBRACE .)


state 82

    (31) statement -> return . SEMI

    SEMI            shift and go to state 123


state 83

    (32) statement -> input . SEMI

    SEMI            shift and go to state 124


state 84

    (25) statement -> assignment .

    IF              reduce using rule 25 (statement -> assignment .)
    ID              reduce using rule 25 (statement -> assignment .)
    WHILE           reduce using rule 25 (statement -> assignment .)
    LPAREN          reduce using rule 25 (statement -> assignment .)
    DO              reduce using rule 25 (statement -> assignment .)
    PRINT           reduce using rule 25 (statement -> assignment .)
    CALL            reduce using rule 25 (statement -> assignment .)
    RETURN          reduce using rule 25 (statement -> assignment .)
    INPUT           reduce using rule 25 (statement -> assignment .)
    RBRACE          reduce using rule 25 (statement -> assignment .)


state 85

    (29) statement -> print . SEMI

    SEMI            shift and go to state 125


state 86

    (24) statement -> condition .

    IF              reduce using rule 24 (statement -> condition .)
    ID              reduce using rule 24 (statement -> condition .)
    WHILE           reduce using rule 24 (statement -> condition .)
    LPAREN          reduce using rule 24 (statement -> condition .)
    DO              reduce using rule 24 (statement -> condition .)
    PRINT           reduce using rule 24 (statement -> condition .)
    CALL            reduce using rule 24 (statement -> condition .)
    RETURN          reduce using rule 24 (statement -> condition .)
    INPUT           reduce using rule 24 (statement -> condition .)
    RBRACE          reduce using rule 24 (statement -> condition .)


state 87

    (28) statement -> dowhile .

    IF              reduce using rule 28 (statement -> dowhile .)
    ID              reduce using rule 28 (statement -> dowhile .)
    WHILE           reduce using rule 28 (statement -> dowhile .)
    LPAREN          reduce using rule 28 (statement -> dowhile .)
    DO              reduce using rule 28 (statement -> dowhile .)
    PRINT           reduce using rule 28 (statement -> dowhile .)
    CALL            reduce using rule 28 (statement -> dowhile .)
    RETURN          reduce using rule 28 (statement -> dowhile .)
    INPUT           reduce using rule 28 (statement -> dowhile .)
    RBRACE          reduce using rule 28 (statement -> dowhile .)


state 88

    (22) statements -> statement .
    (23) statements -> statement . statements
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          reduce using rule 22 (statements -> statement .)
    IF              shift and go to state 76
    ID              shift and go to state 73
    WHILE           shift and go to state 75
    LPAREN          shift and go to state 80
    DO              shift and go to state 89
    PRINT           shift and go to state 77
    CALL            shift and go to state 91
    RETURN          shift and go to state 71
    INPUT           shift and go to state 72

    while                          shift and go to state 79
    print                          shift and go to state 85
    return                         shift and go to state 82
    funcall                        shift and go to state 74
    input                          shift and go to state 83
    assignment                     shift and go to state 84
    condition                      shift and go to state 86
    dowhile                        shift and go to state 87
    statement                      shift and go to state 88
    for                            shift and go to state 90
    statements                     shift and go to state 126

state 89

    (46) dowhile -> DO . pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (47) pushjump -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 116
    pushjump                       shift and go to state 127

state 90

    (27) statement -> for .

    IF              reduce using rule 27 (statement -> for .)
    ID              reduce using rule 27 (statement -> for .)
    WHILE           reduce using rule 27 (statement -> for .)
    LPAREN          reduce using rule 27 (statement -> for .)
    DO              reduce using rule 27 (statement -> for .)
    PRINT           reduce using rule 27 (statement -> for .)
    CALL            reduce using rule 27 (statement -> for .)
    RETURN          reduce using rule 27 (statement -> for .)
    INPUT           reduce using rule 27 (statement -> for .)
    RBRACE          reduce using rule 27 (statement -> for .)


state 91

    (37) funcall -> CALL . ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL . ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 128


state 92

    (17) block -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 129


state 93

    (9) endfunc -> empty .

    BOOLEAN         reduce using rule 9 (endfunc -> empty .)
    INTEGER         reduce using rule 9 (endfunc -> empty .)
    DECIMAL         reduce using rule 9 (endfunc -> empty .)
    STRING          reduce using rule 9 (endfunc -> empty .)
    FRACTION        reduce using rule 9 (endfunc -> empty .)
    VOID            reduce using rule 9 (endfunc -> empty .)
    $end            reduce using rule 9 (endfunc -> empty .)


state 94

    (7) function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .

    BOOLEAN         reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    INTEGER         reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    DECIMAL         reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    STRING          reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    FRACTION        reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    VOID            reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)
    $end            reduce using rule 7 (function -> type FUNCTION ID pushid setcontext LPAREN RPAREN savefunc block endfunc .)


state 95

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA . var1
    (58) var1 -> . ID pushid savevar allocatevar
    (59) var1 -> . ID pushid savevar allocatevar COMMA var1
    (60) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1
    (61) var1 -> . ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar

    ID              shift and go to state 34

    var1                           shift and go to state 130

state 96

    (12) parameter -> type ID pushid COMMA parameter .

    RPAREN          reduce using rule 12 (parameter -> type ID pushid COMMA parameter .)


state 97

    (6) function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .

    BOOLEAN         reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    INTEGER         reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    DECIMAL         reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    STRING          reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    FRACTION        reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    VOID            reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)
    $end            reduce using rule 6 (function -> type FUNCTION ID pushid setcontext LPAREN parameter RPAREN savefunc block endfunc .)


state 98

    (21) savereturn -> empty .

    SEMI            reduce using rule 21 (savereturn -> empty .)


state 99

    (101) exp -> STRING_CONS . settypestring pushcons
    (65) settypestring -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 26
    settypestring                  shift and go to state 131

state 100

    (97) exp -> ID . pushdeclaredid
    (98) exp -> ID . pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (112) pushdeclaredid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LBRACK          reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushdeclaredid                 shift and go to state 132
    pushtype                       shift and go to state 133

state 101

    (108) exp -> funcall . pushrtn
    (109) pushrtn -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 134
    pushrtn                        shift and go to state 135

state 102

    (105) exp -> FALSE . settypebool pushcons
    (66) settypebool -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 28
    settypebool                    shift and go to state 136

state 103

    (99) exp -> LBRACK . exp RBRACK
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 137

state 104

    (34) return -> RETURN expression . savereturn
    (21) savereturn -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 98
    savereturn                     shift and go to state 138

state 105

    (103) exp -> DECIMAL_CONS . settypedec pushcons
    (63) settypedec -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 24
    settypedec                     shift and go to state 139

state 106

    (107) exp -> LPAREN . exp RPAREN
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 140

state 107

    (102) exp -> FRACTION_CONS . settypefrac pushcons
    (64) settypefrac -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 30
    settypefrac                    shift and go to state 141

state 108

    (100) exp -> INTEGER_CONS . settypeint pushcons
    (62) settypeint -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 18
    settypeint                     shift and go to state 142

state 109

    (106) exp -> EXMARK . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 143

state 110

    (35) return -> RETURN savereturn .

    SEMI            reduce using rule 35 (return -> RETURN savereturn .)


state 111

    (104) exp -> TRUE . settypebool pushcons
    (66) settypebool -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 28
    settypebool                    shift and go to state 144

state 112

    (81) expression -> exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    SEMI            reduce using rule 81 (expression -> exp .)
    RPAREN          reduce using rule 81 (expression -> exp .)
    RBRACK          reduce using rule 81 (expression -> exp .)
    COMMA           reduce using rule 81 (expression -> exp .)
    OR              shift and go to state 155
    AND             shift and go to state 145
    SAME            shift and go to state 152
    DIF             shift and go to state 151
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154


state 113

    (33) input -> INPUT ID . pushdeclaredid
    (112) pushdeclaredid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushtype                       shift and go to state 133
    pushdeclaredid                 shift and go to state 160

state 114

    (77) assignment -> ID pushid . EQUALS expression SEMI updatevar
    (78) assignment -> ID pushid . LBRACK expression RBRACK EQUALS expression SEMI updatecell

    EQUALS          shift and go to state 162
    LBRACK          shift and go to state 161


state 115

    (30) statement -> funcall SEMI .

    IF              reduce using rule 30 (statement -> funcall SEMI .)
    ID              reduce using rule 30 (statement -> funcall SEMI .)
    WHILE           reduce using rule 30 (statement -> funcall SEMI .)
    LPAREN          reduce using rule 30 (statement -> funcall SEMI .)
    DO              reduce using rule 30 (statement -> funcall SEMI .)
    PRINT           reduce using rule 30 (statement -> funcall SEMI .)
    CALL            reduce using rule 30 (statement -> funcall SEMI .)
    RETURN          reduce using rule 30 (statement -> funcall SEMI .)
    INPUT           reduce using rule 30 (statement -> funcall SEMI .)
    RBRACE          reduce using rule 30 (statement -> funcall SEMI .)


state 116

    (47) pushjump -> empty .

    LPAREN          reduce using rule 47 (pushjump -> empty .)
    LBRACE          reduce using rule 47 (pushjump -> empty .)


state 117

    (49) while -> WHILE pushjump . LPAREN expression RPAREN gotof simpleblock gotowhile

    LPAREN          shift and go to state 163


state 118

    (51) condition -> IF LPAREN . expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN . expression RPAREN gotof simpleblock updatejump
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    expression                     shift and go to state 164
    exp                            shift and go to state 112

state 119

    (36) print -> PRINT expression .

    SEMI            reduce using rule 36 (print -> PRINT expression .)


state 120

    (16) vartoparam -> empty .

    RBRACE          reduce using rule 16 (vartoparam -> empty .)
    IF              reduce using rule 16 (vartoparam -> empty .)
    ID              reduce using rule 16 (vartoparam -> empty .)
    WHILE           reduce using rule 16 (vartoparam -> empty .)
    LPAREN          reduce using rule 16 (vartoparam -> empty .)
    DO              reduce using rule 16 (vartoparam -> empty .)
    PRINT           reduce using rule 16 (vartoparam -> empty .)
    CALL            reduce using rule 16 (vartoparam -> empty .)
    RETURN          reduce using rule 16 (vartoparam -> empty .)
    INPUT           reduce using rule 16 (vartoparam -> empty .)


state 121

    (13) block -> LBRACE var vartoparam . statements RBRACE deletelocal
    (14) block -> LBRACE var vartoparam . RBRACE deletelocal
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          shift and go to state 165
    IF              shift and go to state 76
    ID              shift and go to state 73
    WHILE           shift and go to state 75
    LPAREN          shift and go to state 80
    DO              shift and go to state 89
    PRINT           shift and go to state 77
    CALL            shift and go to state 91
    RETURN          shift and go to state 71
    INPUT           shift and go to state 72

    while                          shift and go to state 79
    print                          shift and go to state 85
    return                         shift and go to state 82
    funcall                        shift and go to state 74
    input                          shift and go to state 83
    assignment                     shift and go to state 84
    condition                      shift and go to state 86
    dowhile                        shift and go to state 87
    statement                      shift and go to state 88
    for                            shift and go to state 90
    statements                     shift and go to state 166

state 122

    (45) for -> LPAREN assignment . expression SEMI expression RPAREN simpleblock
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 167

state 123

    (31) statement -> return SEMI .

    IF              reduce using rule 31 (statement -> return SEMI .)
    ID              reduce using rule 31 (statement -> return SEMI .)
    WHILE           reduce using rule 31 (statement -> return SEMI .)
    LPAREN          reduce using rule 31 (statement -> return SEMI .)
    DO              reduce using rule 31 (statement -> return SEMI .)
    PRINT           reduce using rule 31 (statement -> return SEMI .)
    CALL            reduce using rule 31 (statement -> return SEMI .)
    RETURN          reduce using rule 31 (statement -> return SEMI .)
    INPUT           reduce using rule 31 (statement -> return SEMI .)
    RBRACE          reduce using rule 31 (statement -> return SEMI .)


state 124

    (32) statement -> input SEMI .

    IF              reduce using rule 32 (statement -> input SEMI .)
    ID              reduce using rule 32 (statement -> input SEMI .)
    WHILE           reduce using rule 32 (statement -> input SEMI .)
    LPAREN          reduce using rule 32 (statement -> input SEMI .)
    DO              reduce using rule 32 (statement -> input SEMI .)
    PRINT           reduce using rule 32 (statement -> input SEMI .)
    CALL            reduce using rule 32 (statement -> input SEMI .)
    RETURN          reduce using rule 32 (statement -> input SEMI .)
    INPUT           reduce using rule 32 (statement -> input SEMI .)
    RBRACE          reduce using rule 32 (statement -> input SEMI .)


state 125

    (29) statement -> print SEMI .

    IF              reduce using rule 29 (statement -> print SEMI .)
    ID              reduce using rule 29 (statement -> print SEMI .)
    WHILE           reduce using rule 29 (statement -> print SEMI .)
    LPAREN          reduce using rule 29 (statement -> print SEMI .)
    DO              reduce using rule 29 (statement -> print SEMI .)
    PRINT           reduce using rule 29 (statement -> print SEMI .)
    CALL            reduce using rule 29 (statement -> print SEMI .)
    RETURN          reduce using rule 29 (statement -> print SEMI .)
    INPUT           reduce using rule 29 (statement -> print SEMI .)
    RBRACE          reduce using rule 29 (statement -> print SEMI .)


state 126

    (23) statements -> statement statements .

    RBRACE          reduce using rule 23 (statements -> statement statements .)


state 127

    (46) dowhile -> DO pushjump . simpleblock WHILE LPAREN expression RPAREN gotot
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 169

    simpleblock                    shift and go to state 168

state 128

    (37) funcall -> CALL ID . pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID . pushid LPAREN eragener RPAREN assignvalues
    (111) pushid -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    LPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushid                         shift and go to state 170
    pushtype                       shift and go to state 38

state 129

    (17) block -> LBRACE statements RBRACE .

    BOOLEAN         reduce using rule 17 (block -> LBRACE statements RBRACE .)
    INTEGER         reduce using rule 17 (block -> LBRACE statements RBRACE .)
    DECIMAL         reduce using rule 17 (block -> LBRACE statements RBRACE .)
    STRING          reduce using rule 17 (block -> LBRACE statements RBRACE .)
    FRACTION        reduce using rule 17 (block -> LBRACE statements RBRACE .)
    VOID            reduce using rule 17 (block -> LBRACE statements RBRACE .)
    $end            reduce using rule 17 (block -> LBRACE statements RBRACE .)


state 130

    (60) var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1 .

    SEMI            reduce using rule 60 (var1 -> ID pushid savevar LBRACK INTEGER_CONS updatesize RBRACK allocatevar COMMA var1 .)


state 131

    (101) exp -> STRING_CONS settypestring . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 171
    empty                          shift and go to state 37
    pushtype                       shift and go to state 172

state 132

    (97) exp -> ID pushdeclaredid .
    (98) exp -> ID pushdeclaredid . LBRACK expression RBRACK pushdeclaredarray

    OR              reduce using rule 97 (exp -> ID pushdeclaredid .)
    AND             reduce using rule 97 (exp -> ID pushdeclaredid .)
    SAME            reduce using rule 97 (exp -> ID pushdeclaredid .)
    DIF             reduce using rule 97 (exp -> ID pushdeclaredid .)
    GE              reduce using rule 97 (exp -> ID pushdeclaredid .)
    LE              reduce using rule 97 (exp -> ID pushdeclaredid .)
    NE              reduce using rule 97 (exp -> ID pushdeclaredid .)
    GT              reduce using rule 97 (exp -> ID pushdeclaredid .)
    LT              reduce using rule 97 (exp -> ID pushdeclaredid .)
    PLUS            reduce using rule 97 (exp -> ID pushdeclaredid .)
    MINUS           reduce using rule 97 (exp -> ID pushdeclaredid .)
    MODULO          reduce using rule 97 (exp -> ID pushdeclaredid .)
    DIVIDE          reduce using rule 97 (exp -> ID pushdeclaredid .)
    TIMES           reduce using rule 97 (exp -> ID pushdeclaredid .)
    POWER           reduce using rule 97 (exp -> ID pushdeclaredid .)
    SEMI            reduce using rule 97 (exp -> ID pushdeclaredid .)
    RBRACK          reduce using rule 97 (exp -> ID pushdeclaredid .)
    RPAREN          reduce using rule 97 (exp -> ID pushdeclaredid .)
    COMMA           reduce using rule 97 (exp -> ID pushdeclaredid .)
    LBRACK          shift and go to state 173


state 133

    (112) pushdeclaredid -> pushtype .

    LBRACK          reduce using rule 112 (pushdeclaredid -> pushtype .)
    OR              reduce using rule 112 (pushdeclaredid -> pushtype .)
    AND             reduce using rule 112 (pushdeclaredid -> pushtype .)
    SAME            reduce using rule 112 (pushdeclaredid -> pushtype .)
    DIF             reduce using rule 112 (pushdeclaredid -> pushtype .)
    GE              reduce using rule 112 (pushdeclaredid -> pushtype .)
    LE              reduce using rule 112 (pushdeclaredid -> pushtype .)
    NE              reduce using rule 112 (pushdeclaredid -> pushtype .)
    GT              reduce using rule 112 (pushdeclaredid -> pushtype .)
    LT              reduce using rule 112 (pushdeclaredid -> pushtype .)
    PLUS            reduce using rule 112 (pushdeclaredid -> pushtype .)
    MINUS           reduce using rule 112 (pushdeclaredid -> pushtype .)
    MODULO          reduce using rule 112 (pushdeclaredid -> pushtype .)
    DIVIDE          reduce using rule 112 (pushdeclaredid -> pushtype .)
    TIMES           reduce using rule 112 (pushdeclaredid -> pushtype .)
    POWER           reduce using rule 112 (pushdeclaredid -> pushtype .)
    SEMI            reduce using rule 112 (pushdeclaredid -> pushtype .)
    RBRACK          reduce using rule 112 (pushdeclaredid -> pushtype .)
    RPAREN          reduce using rule 112 (pushdeclaredid -> pushtype .)
    COMMA           reduce using rule 112 (pushdeclaredid -> pushtype .)


state 134

    (109) pushrtn -> empty .

    OR              reduce using rule 109 (pushrtn -> empty .)
    AND             reduce using rule 109 (pushrtn -> empty .)
    SAME            reduce using rule 109 (pushrtn -> empty .)
    DIF             reduce using rule 109 (pushrtn -> empty .)
    GE              reduce using rule 109 (pushrtn -> empty .)
    LE              reduce using rule 109 (pushrtn -> empty .)
    NE              reduce using rule 109 (pushrtn -> empty .)
    GT              reduce using rule 109 (pushrtn -> empty .)
    LT              reduce using rule 109 (pushrtn -> empty .)
    PLUS            reduce using rule 109 (pushrtn -> empty .)
    MINUS           reduce using rule 109 (pushrtn -> empty .)
    MODULO          reduce using rule 109 (pushrtn -> empty .)
    DIVIDE          reduce using rule 109 (pushrtn -> empty .)
    TIMES           reduce using rule 109 (pushrtn -> empty .)
    POWER           reduce using rule 109 (pushrtn -> empty .)
    SEMI            reduce using rule 109 (pushrtn -> empty .)
    RBRACK          reduce using rule 109 (pushrtn -> empty .)
    RPAREN          reduce using rule 109 (pushrtn -> empty .)
    COMMA           reduce using rule 109 (pushrtn -> empty .)


state 135

    (108) exp -> funcall pushrtn .

    OR              reduce using rule 108 (exp -> funcall pushrtn .)
    AND             reduce using rule 108 (exp -> funcall pushrtn .)
    SAME            reduce using rule 108 (exp -> funcall pushrtn .)
    DIF             reduce using rule 108 (exp -> funcall pushrtn .)
    GE              reduce using rule 108 (exp -> funcall pushrtn .)
    LE              reduce using rule 108 (exp -> funcall pushrtn .)
    NE              reduce using rule 108 (exp -> funcall pushrtn .)
    GT              reduce using rule 108 (exp -> funcall pushrtn .)
    LT              reduce using rule 108 (exp -> funcall pushrtn .)
    PLUS            reduce using rule 108 (exp -> funcall pushrtn .)
    MINUS           reduce using rule 108 (exp -> funcall pushrtn .)
    MODULO          reduce using rule 108 (exp -> funcall pushrtn .)
    DIVIDE          reduce using rule 108 (exp -> funcall pushrtn .)
    TIMES           reduce using rule 108 (exp -> funcall pushrtn .)
    POWER           reduce using rule 108 (exp -> funcall pushrtn .)
    SEMI            reduce using rule 108 (exp -> funcall pushrtn .)
    RBRACK          reduce using rule 108 (exp -> funcall pushrtn .)
    RPAREN          reduce using rule 108 (exp -> funcall pushrtn .)
    COMMA           reduce using rule 108 (exp -> funcall pushrtn .)


state 136

    (105) exp -> FALSE settypebool . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 174
    empty                          shift and go to state 37
    pushtype                       shift and go to state 172

state 137

    (99) exp -> LBRACK exp . RBRACK
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    RBRACK          shift and go to state 175
    OR              shift and go to state 155
    AND             shift and go to state 145
    SAME            shift and go to state 152
    DIF             shift and go to state 151
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154


state 138

    (34) return -> RETURN expression savereturn .

    SEMI            reduce using rule 34 (return -> RETURN expression savereturn .)


state 139

    (103) exp -> DECIMAL_CONS settypedec . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 176
    empty                          shift and go to state 37
    pushtype                       shift and go to state 172

state 140

    (107) exp -> LPAREN exp . RPAREN
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    RPAREN          shift and go to state 177
    OR              shift and go to state 155
    AND             shift and go to state 145
    SAME            shift and go to state 152
    DIF             shift and go to state 151
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154


state 141

    (102) exp -> FRACTION_CONS settypefrac . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 178
    empty                          shift and go to state 37
    pushtype                       shift and go to state 172

state 142

    (100) exp -> INTEGER_CONS settypeint . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 179
    pushtype                       shift and go to state 172
    empty                          shift and go to state 37

state 143

    (106) exp -> EXMARK exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 106 (exp -> EXMARK exp .)
    AND             reduce using rule 106 (exp -> EXMARK exp .)
    DIF             reduce using rule 106 (exp -> EXMARK exp .)
    SEMI            reduce using rule 106 (exp -> EXMARK exp .)
    RBRACK          reduce using rule 106 (exp -> EXMARK exp .)
    RPAREN          reduce using rule 106 (exp -> EXMARK exp .)
    COMMA           reduce using rule 106 (exp -> EXMARK exp .)
    SAME            shift and go to state 152
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! SAME            [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! GE              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! LE              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! NE              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! GT              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! LT              [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! PLUS            [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! MINUS           [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! MODULO          [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! DIVIDE          [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! TIMES           [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! POWER           [ reduce using rule 106 (exp -> EXMARK exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! DIF             [ shift and go to state 151 ]


state 144

    (104) exp -> TRUE settypebool . pushcons
    (114) pushcons -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    pushcons                       shift and go to state 180
    empty                          shift and go to state 37
    pushtype                       shift and go to state 172

state 145

    (83) exp -> exp AND . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 181

state 146

    (86) exp -> exp GE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 182

state 147

    (95) exp -> exp TIMES . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 183

state 148

    (92) exp -> exp MINUS . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 184

state 149

    (89) exp -> exp GT . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 185

state 150

    (91) exp -> exp PLUS . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 186

state 151

    (85) exp -> exp DIF . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 187

state 152

    (84) exp -> exp SAME . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 188

state 153

    (93) exp -> exp MODULO . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 189

state 154

    (96) exp -> exp POWER . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 190

state 155

    (82) exp -> exp OR . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 191

state 156

    (90) exp -> exp LT . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 192

state 157

    (88) exp -> exp NE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 193

state 158

    (87) exp -> exp LE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 194

state 159

    (94) exp -> exp DIVIDE . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 195

state 160

    (33) input -> INPUT ID pushdeclaredid .

    SEMI            reduce using rule 33 (input -> INPUT ID pushdeclaredid .)


state 161

    (78) assignment -> ID pushid LBRACK . expression RBRACK EQUALS expression SEMI updatecell
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 196

state 162

    (77) assignment -> ID pushid EQUALS . expression SEMI updatevar
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 197

state 163

    (49) while -> WHILE pushjump LPAREN . expression RPAREN gotof simpleblock gotowhile
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    expression                     shift and go to state 198
    exp                            shift and go to state 112

state 164

    (51) condition -> IF LPAREN expression . RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression . RPAREN gotof simpleblock updatejump

    RPAREN          shift and go to state 199


state 165

    (14) block -> LBRACE var vartoparam RBRACE . deletelocal
    (15) deletelocal -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 200
    deletelocal                    shift and go to state 201

state 166

    (13) block -> LBRACE var vartoparam statements . RBRACE deletelocal

    RBRACE          shift and go to state 202


state 167

    (45) for -> LPAREN assignment expression . SEMI expression RPAREN simpleblock

    SEMI            shift and go to state 203


state 168

    (46) dowhile -> DO pushjump simpleblock . WHILE LPAREN expression RPAREN gotot

    WHILE           shift and go to state 204


state 169

    (19) simpleblock -> LBRACE . statements RBRACE
    (20) simpleblock -> LBRACE . RBRACE
    (22) statements -> . statement
    (23) statements -> . statement statements
    (24) statement -> . condition
    (25) statement -> . assignment
    (26) statement -> . while
    (27) statement -> . for
    (28) statement -> . dowhile
    (29) statement -> . print SEMI
    (30) statement -> . funcall SEMI
    (31) statement -> . return SEMI
    (32) statement -> . input SEMI
    (51) condition -> . IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> . IF LPAREN expression RPAREN gotof simpleblock updatejump
    (77) assignment -> . ID pushid EQUALS expression SEMI updatevar
    (78) assignment -> . ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell
    (49) while -> . WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile
    (45) for -> . LPAREN assignment expression SEMI expression RPAREN simpleblock
    (46) dowhile -> . DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot
    (36) print -> . PRINT expression
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues
    (34) return -> . RETURN expression savereturn
    (35) return -> . RETURN savereturn
    (33) input -> . INPUT ID pushdeclaredid

    RBRACE          shift and go to state 205
    IF              shift and go to state 76
    ID              shift and go to state 73
    WHILE           shift and go to state 75
    LPAREN          shift and go to state 80
    DO              shift and go to state 89
    PRINT           shift and go to state 77
    CALL            shift and go to state 91
    RETURN          shift and go to state 71
    INPUT           shift and go to state 72

    while                          shift and go to state 79
    print                          shift and go to state 85
    return                         shift and go to state 82
    funcall                        shift and go to state 74
    input                          shift and go to state 83
    assignment                     shift and go to state 84
    condition                      shift and go to state 86
    dowhile                        shift and go to state 87
    statement                      shift and go to state 88
    for                            shift and go to state 90
    statements                     shift and go to state 206

state 170

    (37) funcall -> CALL ID pushid . LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID pushid . LPAREN eragener RPAREN assignvalues

    LPAREN          shift and go to state 207


state 171

    (101) exp -> STRING_CONS settypestring pushcons .

    OR              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    AND             reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    SAME            reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    DIF             reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    GE              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    LE              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    NE              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    GT              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    LT              reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    PLUS            reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    MINUS           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    MODULO          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    DIVIDE          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    TIMES           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    POWER           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    SEMI            reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    RBRACK          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    RPAREN          reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)
    COMMA           reduce using rule 101 (exp -> STRING_CONS settypestring pushcons .)


state 172

    (114) pushcons -> pushtype .

    OR              reduce using rule 114 (pushcons -> pushtype .)
    AND             reduce using rule 114 (pushcons -> pushtype .)
    SAME            reduce using rule 114 (pushcons -> pushtype .)
    DIF             reduce using rule 114 (pushcons -> pushtype .)
    GE              reduce using rule 114 (pushcons -> pushtype .)
    LE              reduce using rule 114 (pushcons -> pushtype .)
    NE              reduce using rule 114 (pushcons -> pushtype .)
    GT              reduce using rule 114 (pushcons -> pushtype .)
    LT              reduce using rule 114 (pushcons -> pushtype .)
    PLUS            reduce using rule 114 (pushcons -> pushtype .)
    MINUS           reduce using rule 114 (pushcons -> pushtype .)
    MODULO          reduce using rule 114 (pushcons -> pushtype .)
    DIVIDE          reduce using rule 114 (pushcons -> pushtype .)
    TIMES           reduce using rule 114 (pushcons -> pushtype .)
    POWER           reduce using rule 114 (pushcons -> pushtype .)
    SEMI            reduce using rule 114 (pushcons -> pushtype .)
    RBRACK          reduce using rule 114 (pushcons -> pushtype .)
    RPAREN          reduce using rule 114 (pushcons -> pushtype .)
    COMMA           reduce using rule 114 (pushcons -> pushtype .)


state 173

    (98) exp -> ID pushdeclaredid LBRACK . expression RBRACK pushdeclaredarray
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    expression                     shift and go to state 208
    exp                            shift and go to state 112

state 174

    (105) exp -> FALSE settypebool pushcons .

    OR              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    AND             reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    SAME            reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    DIF             reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    GE              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    LE              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    NE              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    GT              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    LT              reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    PLUS            reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    MINUS           reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    MODULO          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    DIVIDE          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    TIMES           reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    POWER           reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    SEMI            reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    RBRACK          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    RPAREN          reduce using rule 105 (exp -> FALSE settypebool pushcons .)
    COMMA           reduce using rule 105 (exp -> FALSE settypebool pushcons .)


state 175

    (99) exp -> LBRACK exp RBRACK .

    OR              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    AND             reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    SAME            reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    DIF             reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    GE              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    LE              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    NE              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    GT              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    LT              reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    PLUS            reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    MINUS           reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    MODULO          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    DIVIDE          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    TIMES           reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    POWER           reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    SEMI            reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    RBRACK          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    RPAREN          reduce using rule 99 (exp -> LBRACK exp RBRACK .)
    COMMA           reduce using rule 99 (exp -> LBRACK exp RBRACK .)


state 176

    (103) exp -> DECIMAL_CONS settypedec pushcons .

    OR              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    AND             reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    SAME            reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    DIF             reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    GE              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    LE              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    NE              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    GT              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    LT              reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    PLUS            reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    MINUS           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    MODULO          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    DIVIDE          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    TIMES           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    POWER           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    SEMI            reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    RBRACK          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    RPAREN          reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)
    COMMA           reduce using rule 103 (exp -> DECIMAL_CONS settypedec pushcons .)


state 177

    (107) exp -> LPAREN exp RPAREN .

    OR              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    SAME            reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    DIF             reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    NE              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    MODULO          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    POWER           reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    SEMI            reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    RBRACK          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 107 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 107 (exp -> LPAREN exp RPAREN .)


state 178

    (102) exp -> FRACTION_CONS settypefrac pushcons .

    OR              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    AND             reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    SAME            reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    DIF             reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    GE              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    LE              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    NE              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    GT              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    LT              reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    PLUS            reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    MINUS           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    MODULO          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    DIVIDE          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    TIMES           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    POWER           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    SEMI            reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    RBRACK          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    RPAREN          reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)
    COMMA           reduce using rule 102 (exp -> FRACTION_CONS settypefrac pushcons .)


state 179

    (100) exp -> INTEGER_CONS settypeint pushcons .

    OR              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    AND             reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    SAME            reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    DIF             reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    GE              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    LE              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    NE              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    GT              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    LT              reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    PLUS            reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    MINUS           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    MODULO          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    DIVIDE          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    TIMES           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    POWER           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    SEMI            reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    RBRACK          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    RPAREN          reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)
    COMMA           reduce using rule 100 (exp -> INTEGER_CONS settypeint pushcons .)


state 180

    (104) exp -> TRUE settypebool pushcons .

    OR              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    AND             reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    SAME            reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    DIF             reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    GE              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    LE              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    NE              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    GT              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    LT              reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    PLUS            reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    MINUS           reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    MODULO          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    DIVIDE          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    TIMES           reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    POWER           reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    SEMI            reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    RBRACK          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    RPAREN          reduce using rule 104 (exp -> TRUE settypebool pushcons .)
    COMMA           reduce using rule 104 (exp -> TRUE settypebool pushcons .)


state 181

    (83) exp -> exp AND exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 83 (exp -> exp AND exp .)
    AND             reduce using rule 83 (exp -> exp AND exp .)
    DIF             reduce using rule 83 (exp -> exp AND exp .)
    SEMI            reduce using rule 83 (exp -> exp AND exp .)
    RBRACK          reduce using rule 83 (exp -> exp AND exp .)
    RPAREN          reduce using rule 83 (exp -> exp AND exp .)
    COMMA           reduce using rule 83 (exp -> exp AND exp .)
    SAME            shift and go to state 152
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! SAME            [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! GE              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! LE              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! NE              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! PLUS            [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! MINUS           [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! MODULO          [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! DIVIDE          [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! TIMES           [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! POWER           [ reduce using rule 83 (exp -> exp AND exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! DIF             [ shift and go to state 151 ]


state 182

    (86) exp -> exp GE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 86 (exp -> exp GE exp .)
    AND             reduce using rule 86 (exp -> exp GE exp .)
    SAME            reduce using rule 86 (exp -> exp GE exp .)
    DIF             reduce using rule 86 (exp -> exp GE exp .)
    GE              reduce using rule 86 (exp -> exp GE exp .)
    LE              reduce using rule 86 (exp -> exp GE exp .)
    NE              reduce using rule 86 (exp -> exp GE exp .)
    GT              reduce using rule 86 (exp -> exp GE exp .)
    LT              reduce using rule 86 (exp -> exp GE exp .)
    SEMI            reduce using rule 86 (exp -> exp GE exp .)
    RBRACK          reduce using rule 86 (exp -> exp GE exp .)
    RPAREN          reduce using rule 86 (exp -> exp GE exp .)
    COMMA           reduce using rule 86 (exp -> exp GE exp .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! PLUS            [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! MINUS           [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! MODULO          [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! DIVIDE          [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! TIMES           [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! POWER           [ reduce using rule 86 (exp -> exp GE exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]


state 183

    (95) exp -> exp TIMES exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 95 (exp -> exp TIMES exp .)
    AND             reduce using rule 95 (exp -> exp TIMES exp .)
    SAME            reduce using rule 95 (exp -> exp TIMES exp .)
    DIF             reduce using rule 95 (exp -> exp TIMES exp .)
    GE              reduce using rule 95 (exp -> exp TIMES exp .)
    LE              reduce using rule 95 (exp -> exp TIMES exp .)
    NE              reduce using rule 95 (exp -> exp TIMES exp .)
    GT              reduce using rule 95 (exp -> exp TIMES exp .)
    LT              reduce using rule 95 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 95 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 95 (exp -> exp TIMES exp .)
    MODULO          reduce using rule 95 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 95 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 95 (exp -> exp TIMES exp .)
    SEMI            reduce using rule 95 (exp -> exp TIMES exp .)
    RBRACK          reduce using rule 95 (exp -> exp TIMES exp .)
    RPAREN          reduce using rule 95 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 95 (exp -> exp TIMES exp .)
    POWER           shift and go to state 154

  ! POWER           [ reduce using rule 95 (exp -> exp TIMES exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 148 ]
  ! MODULO          [ shift and go to state 153 ]
  ! DIVIDE          [ shift and go to state 159 ]
  ! TIMES           [ shift and go to state 147 ]


state 184

    (92) exp -> exp MINUS exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 92 (exp -> exp MINUS exp .)
    AND             reduce using rule 92 (exp -> exp MINUS exp .)
    SAME            reduce using rule 92 (exp -> exp MINUS exp .)
    DIF             reduce using rule 92 (exp -> exp MINUS exp .)
    GE              reduce using rule 92 (exp -> exp MINUS exp .)
    LE              reduce using rule 92 (exp -> exp MINUS exp .)
    NE              reduce using rule 92 (exp -> exp MINUS exp .)
    GT              reduce using rule 92 (exp -> exp MINUS exp .)
    LT              reduce using rule 92 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 92 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 92 (exp -> exp MINUS exp .)
    SEMI            reduce using rule 92 (exp -> exp MINUS exp .)
    RBRACK          reduce using rule 92 (exp -> exp MINUS exp .)
    RPAREN          reduce using rule 92 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 92 (exp -> exp MINUS exp .)
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! MODULO          [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! TIMES           [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 92 (exp -> exp MINUS exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 148 ]


state 185

    (89) exp -> exp GT exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 89 (exp -> exp GT exp .)
    AND             reduce using rule 89 (exp -> exp GT exp .)
    SAME            reduce using rule 89 (exp -> exp GT exp .)
    DIF             reduce using rule 89 (exp -> exp GT exp .)
    GE              reduce using rule 89 (exp -> exp GT exp .)
    LE              reduce using rule 89 (exp -> exp GT exp .)
    NE              reduce using rule 89 (exp -> exp GT exp .)
    GT              reduce using rule 89 (exp -> exp GT exp .)
    LT              reduce using rule 89 (exp -> exp GT exp .)
    SEMI            reduce using rule 89 (exp -> exp GT exp .)
    RBRACK          reduce using rule 89 (exp -> exp GT exp .)
    RPAREN          reduce using rule 89 (exp -> exp GT exp .)
    COMMA           reduce using rule 89 (exp -> exp GT exp .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! PLUS            [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! MINUS           [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! MODULO          [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! DIVIDE          [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! TIMES           [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! POWER           [ reduce using rule 89 (exp -> exp GT exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]


state 186

    (91) exp -> exp PLUS exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 91 (exp -> exp PLUS exp .)
    AND             reduce using rule 91 (exp -> exp PLUS exp .)
    SAME            reduce using rule 91 (exp -> exp PLUS exp .)
    DIF             reduce using rule 91 (exp -> exp PLUS exp .)
    GE              reduce using rule 91 (exp -> exp PLUS exp .)
    LE              reduce using rule 91 (exp -> exp PLUS exp .)
    NE              reduce using rule 91 (exp -> exp PLUS exp .)
    GT              reduce using rule 91 (exp -> exp PLUS exp .)
    LT              reduce using rule 91 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 91 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 91 (exp -> exp PLUS exp .)
    SEMI            reduce using rule 91 (exp -> exp PLUS exp .)
    RBRACK          reduce using rule 91 (exp -> exp PLUS exp .)
    RPAREN          reduce using rule 91 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 91 (exp -> exp PLUS exp .)
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! MODULO          [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! TIMES           [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 91 (exp -> exp PLUS exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 148 ]


state 187

    (85) exp -> exp DIF exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for SAME resolved as shift
  ! shift/reduce conflict for DIF resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    SEMI            reduce using rule 85 (exp -> exp DIF exp .)
    RBRACK          reduce using rule 85 (exp -> exp DIF exp .)
    RPAREN          reduce using rule 85 (exp -> exp DIF exp .)
    COMMA           reduce using rule 85 (exp -> exp DIF exp .)
    OR              shift and go to state 155
    AND             shift and go to state 145
    SAME            shift and go to state 152
    DIF             shift and go to state 151
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! OR              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! AND             [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! SAME            [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! DIF             [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! GE              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! LE              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! NE              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! GT              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! LT              [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! PLUS            [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! MINUS           [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! MODULO          [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! DIVIDE          [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! TIMES           [ reduce using rule 85 (exp -> exp DIF exp .) ]
  ! POWER           [ reduce using rule 85 (exp -> exp DIF exp .) ]


state 188

    (84) exp -> exp SAME exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 84 (exp -> exp SAME exp .)
    AND             reduce using rule 84 (exp -> exp SAME exp .)
    SAME            reduce using rule 84 (exp -> exp SAME exp .)
    DIF             reduce using rule 84 (exp -> exp SAME exp .)
    GE              reduce using rule 84 (exp -> exp SAME exp .)
    LE              reduce using rule 84 (exp -> exp SAME exp .)
    NE              reduce using rule 84 (exp -> exp SAME exp .)
    GT              reduce using rule 84 (exp -> exp SAME exp .)
    LT              reduce using rule 84 (exp -> exp SAME exp .)
    SEMI            reduce using rule 84 (exp -> exp SAME exp .)
    RBRACK          reduce using rule 84 (exp -> exp SAME exp .)
    RPAREN          reduce using rule 84 (exp -> exp SAME exp .)
    COMMA           reduce using rule 84 (exp -> exp SAME exp .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! PLUS            [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! MINUS           [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! MODULO          [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! DIVIDE          [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! TIMES           [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! POWER           [ reduce using rule 84 (exp -> exp SAME exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]


state 189

    (93) exp -> exp MODULO exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 93 (exp -> exp MODULO exp .)
    AND             reduce using rule 93 (exp -> exp MODULO exp .)
    SAME            reduce using rule 93 (exp -> exp MODULO exp .)
    DIF             reduce using rule 93 (exp -> exp MODULO exp .)
    GE              reduce using rule 93 (exp -> exp MODULO exp .)
    LE              reduce using rule 93 (exp -> exp MODULO exp .)
    NE              reduce using rule 93 (exp -> exp MODULO exp .)
    GT              reduce using rule 93 (exp -> exp MODULO exp .)
    LT              reduce using rule 93 (exp -> exp MODULO exp .)
    PLUS            reduce using rule 93 (exp -> exp MODULO exp .)
    MINUS           reduce using rule 93 (exp -> exp MODULO exp .)
    MODULO          reduce using rule 93 (exp -> exp MODULO exp .)
    DIVIDE          reduce using rule 93 (exp -> exp MODULO exp .)
    TIMES           reduce using rule 93 (exp -> exp MODULO exp .)
    SEMI            reduce using rule 93 (exp -> exp MODULO exp .)
    RBRACK          reduce using rule 93 (exp -> exp MODULO exp .)
    RPAREN          reduce using rule 93 (exp -> exp MODULO exp .)
    COMMA           reduce using rule 93 (exp -> exp MODULO exp .)
    POWER           shift and go to state 154

  ! POWER           [ reduce using rule 93 (exp -> exp MODULO exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 148 ]
  ! MODULO          [ shift and go to state 153 ]
  ! DIVIDE          [ shift and go to state 159 ]
  ! TIMES           [ shift and go to state 147 ]


state 190

    (96) exp -> exp POWER exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 96 (exp -> exp POWER exp .)
    AND             reduce using rule 96 (exp -> exp POWER exp .)
    SAME            reduce using rule 96 (exp -> exp POWER exp .)
    DIF             reduce using rule 96 (exp -> exp POWER exp .)
    GE              reduce using rule 96 (exp -> exp POWER exp .)
    LE              reduce using rule 96 (exp -> exp POWER exp .)
    NE              reduce using rule 96 (exp -> exp POWER exp .)
    GT              reduce using rule 96 (exp -> exp POWER exp .)
    LT              reduce using rule 96 (exp -> exp POWER exp .)
    PLUS            reduce using rule 96 (exp -> exp POWER exp .)
    MINUS           reduce using rule 96 (exp -> exp POWER exp .)
    MODULO          reduce using rule 96 (exp -> exp POWER exp .)
    DIVIDE          reduce using rule 96 (exp -> exp POWER exp .)
    TIMES           reduce using rule 96 (exp -> exp POWER exp .)
    POWER           reduce using rule 96 (exp -> exp POWER exp .)
    SEMI            reduce using rule 96 (exp -> exp POWER exp .)
    RBRACK          reduce using rule 96 (exp -> exp POWER exp .)
    RPAREN          reduce using rule 96 (exp -> exp POWER exp .)
    COMMA           reduce using rule 96 (exp -> exp POWER exp .)

  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 148 ]
  ! MODULO          [ shift and go to state 153 ]
  ! DIVIDE          [ shift and go to state 159 ]
  ! TIMES           [ shift and go to state 147 ]
  ! POWER           [ shift and go to state 154 ]


state 191

    (82) exp -> exp OR exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 82 (exp -> exp OR exp .)
    DIF             reduce using rule 82 (exp -> exp OR exp .)
    SEMI            reduce using rule 82 (exp -> exp OR exp .)
    RBRACK          reduce using rule 82 (exp -> exp OR exp .)
    RPAREN          reduce using rule 82 (exp -> exp OR exp .)
    COMMA           reduce using rule 82 (exp -> exp OR exp .)
    AND             shift and go to state 145
    SAME            shift and go to state 152
    GE              shift and go to state 146
    LE              shift and go to state 158
    NE              shift and go to state 157
    GT              shift and go to state 149
    LT              shift and go to state 156
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! AND             [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! SAME            [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! GE              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! LE              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! NE              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! PLUS            [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! MINUS           [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! MODULO          [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! DIVIDE          [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! TIMES           [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! POWER           [ reduce using rule 82 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! DIF             [ shift and go to state 151 ]


state 192

    (90) exp -> exp LT exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 90 (exp -> exp LT exp .)
    AND             reduce using rule 90 (exp -> exp LT exp .)
    SAME            reduce using rule 90 (exp -> exp LT exp .)
    DIF             reduce using rule 90 (exp -> exp LT exp .)
    GE              reduce using rule 90 (exp -> exp LT exp .)
    LE              reduce using rule 90 (exp -> exp LT exp .)
    NE              reduce using rule 90 (exp -> exp LT exp .)
    GT              reduce using rule 90 (exp -> exp LT exp .)
    LT              reduce using rule 90 (exp -> exp LT exp .)
    SEMI            reduce using rule 90 (exp -> exp LT exp .)
    RBRACK          reduce using rule 90 (exp -> exp LT exp .)
    RPAREN          reduce using rule 90 (exp -> exp LT exp .)
    COMMA           reduce using rule 90 (exp -> exp LT exp .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! PLUS            [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! MINUS           [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! MODULO          [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! DIVIDE          [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! TIMES           [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! POWER           [ reduce using rule 90 (exp -> exp LT exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]


state 193

    (88) exp -> exp NE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 88 (exp -> exp NE exp .)
    AND             reduce using rule 88 (exp -> exp NE exp .)
    SAME            reduce using rule 88 (exp -> exp NE exp .)
    DIF             reduce using rule 88 (exp -> exp NE exp .)
    GE              reduce using rule 88 (exp -> exp NE exp .)
    LE              reduce using rule 88 (exp -> exp NE exp .)
    NE              reduce using rule 88 (exp -> exp NE exp .)
    GT              reduce using rule 88 (exp -> exp NE exp .)
    LT              reduce using rule 88 (exp -> exp NE exp .)
    SEMI            reduce using rule 88 (exp -> exp NE exp .)
    RBRACK          reduce using rule 88 (exp -> exp NE exp .)
    RPAREN          reduce using rule 88 (exp -> exp NE exp .)
    COMMA           reduce using rule 88 (exp -> exp NE exp .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! PLUS            [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! MINUS           [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! MODULO          [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! DIVIDE          [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! TIMES           [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! POWER           [ reduce using rule 88 (exp -> exp NE exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]


state 194

    (87) exp -> exp LE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 87 (exp -> exp LE exp .)
    AND             reduce using rule 87 (exp -> exp LE exp .)
    SAME            reduce using rule 87 (exp -> exp LE exp .)
    DIF             reduce using rule 87 (exp -> exp LE exp .)
    GE              reduce using rule 87 (exp -> exp LE exp .)
    LE              reduce using rule 87 (exp -> exp LE exp .)
    NE              reduce using rule 87 (exp -> exp LE exp .)
    GT              reduce using rule 87 (exp -> exp LE exp .)
    LT              reduce using rule 87 (exp -> exp LE exp .)
    SEMI            reduce using rule 87 (exp -> exp LE exp .)
    RBRACK          reduce using rule 87 (exp -> exp LE exp .)
    RPAREN          reduce using rule 87 (exp -> exp LE exp .)
    COMMA           reduce using rule 87 (exp -> exp LE exp .)
    PLUS            shift and go to state 150
    MINUS           shift and go to state 148
    MODULO          shift and go to state 153
    DIVIDE          shift and go to state 159
    TIMES           shift and go to state 147
    POWER           shift and go to state 154

  ! PLUS            [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! MODULO          [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! POWER           [ reduce using rule 87 (exp -> exp LE exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]


state 195

    (94) exp -> exp DIVIDE exp .
    (82) exp -> exp . OR exp
    (83) exp -> exp . AND exp
    (84) exp -> exp . SAME exp
    (85) exp -> exp . DIF exp
    (86) exp -> exp . GE exp
    (87) exp -> exp . LE exp
    (88) exp -> exp . NE exp
    (89) exp -> exp . GT exp
    (90) exp -> exp . LT exp
    (91) exp -> exp . PLUS exp
    (92) exp -> exp . MINUS exp
    (93) exp -> exp . MODULO exp
    (94) exp -> exp . DIVIDE exp
    (95) exp -> exp . TIMES exp
    (96) exp -> exp . POWER exp

    OR              reduce using rule 94 (exp -> exp DIVIDE exp .)
    AND             reduce using rule 94 (exp -> exp DIVIDE exp .)
    SAME            reduce using rule 94 (exp -> exp DIVIDE exp .)
    DIF             reduce using rule 94 (exp -> exp DIVIDE exp .)
    GE              reduce using rule 94 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 94 (exp -> exp DIVIDE exp .)
    NE              reduce using rule 94 (exp -> exp DIVIDE exp .)
    GT              reduce using rule 94 (exp -> exp DIVIDE exp .)
    LT              reduce using rule 94 (exp -> exp DIVIDE exp .)
    PLUS            reduce using rule 94 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 94 (exp -> exp DIVIDE exp .)
    MODULO          reduce using rule 94 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 94 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 94 (exp -> exp DIVIDE exp .)
    SEMI            reduce using rule 94 (exp -> exp DIVIDE exp .)
    RBRACK          reduce using rule 94 (exp -> exp DIVIDE exp .)
    RPAREN          reduce using rule 94 (exp -> exp DIVIDE exp .)
    COMMA           reduce using rule 94 (exp -> exp DIVIDE exp .)
    POWER           shift and go to state 154

  ! POWER           [ reduce using rule 94 (exp -> exp DIVIDE exp .) ]
  ! OR              [ shift and go to state 155 ]
  ! AND             [ shift and go to state 145 ]
  ! SAME            [ shift and go to state 152 ]
  ! DIF             [ shift and go to state 151 ]
  ! GE              [ shift and go to state 146 ]
  ! LE              [ shift and go to state 158 ]
  ! NE              [ shift and go to state 157 ]
  ! GT              [ shift and go to state 149 ]
  ! LT              [ shift and go to state 156 ]
  ! PLUS            [ shift and go to state 150 ]
  ! MINUS           [ shift and go to state 148 ]
  ! MODULO          [ shift and go to state 153 ]
  ! DIVIDE          [ shift and go to state 159 ]
  ! TIMES           [ shift and go to state 147 ]


state 196

    (78) assignment -> ID pushid LBRACK expression . RBRACK EQUALS expression SEMI updatecell

    RBRACK          shift and go to state 209


state 197

    (77) assignment -> ID pushid EQUALS expression . SEMI updatevar

    SEMI            shift and go to state 210


state 198

    (49) while -> WHILE pushjump LPAREN expression . RPAREN gotof simpleblock gotowhile

    RPAREN          shift and go to state 211


state 199

    (51) condition -> IF LPAREN expression RPAREN . gotof simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression RPAREN . gotof simpleblock updatejump
    (54) gotof -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 212
    gotof                          shift and go to state 213

state 200

    (15) deletelocal -> empty .

    BOOLEAN         reduce using rule 15 (deletelocal -> empty .)
    INTEGER         reduce using rule 15 (deletelocal -> empty .)
    DECIMAL         reduce using rule 15 (deletelocal -> empty .)
    STRING          reduce using rule 15 (deletelocal -> empty .)
    FRACTION        reduce using rule 15 (deletelocal -> empty .)
    VOID            reduce using rule 15 (deletelocal -> empty .)
    $end            reduce using rule 15 (deletelocal -> empty .)


state 201

    (14) block -> LBRACE var vartoparam RBRACE deletelocal .

    BOOLEAN         reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    INTEGER         reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    DECIMAL         reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    STRING          reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    FRACTION        reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    VOID            reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)
    $end            reduce using rule 14 (block -> LBRACE var vartoparam RBRACE deletelocal .)


state 202

    (13) block -> LBRACE var vartoparam statements RBRACE . deletelocal
    (15) deletelocal -> . empty
    (115) empty -> .

    BOOLEAN         reduce using rule 115 (empty -> .)
    INTEGER         reduce using rule 115 (empty -> .)
    DECIMAL         reduce using rule 115 (empty -> .)
    STRING          reduce using rule 115 (empty -> .)
    FRACTION        reduce using rule 115 (empty -> .)
    VOID            reduce using rule 115 (empty -> .)
    $end            reduce using rule 115 (empty -> .)

    deletelocal                    shift and go to state 214
    empty                          shift and go to state 200

state 203

    (45) for -> LPAREN assignment expression SEMI . expression RPAREN simpleblock
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 215

state 204

    (46) dowhile -> DO pushjump simpleblock WHILE . LPAREN expression RPAREN gotot

    LPAREN          shift and go to state 216


state 205

    (20) simpleblock -> LBRACE RBRACE .

    IF              reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    ID              reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    WHILE           reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    LPAREN          reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    DO              reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    PRINT           reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    CALL            reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    RETURN          reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    INPUT           reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    RBRACE          reduce using rule 20 (simpleblock -> LBRACE RBRACE .)
    ELSE            reduce using rule 20 (simpleblock -> LBRACE RBRACE .)


state 206

    (19) simpleblock -> LBRACE statements . RBRACE

    RBRACE          shift and go to state 217


state 207

    (37) funcall -> CALL ID pushid LPAREN . eragener startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID pushid LPAREN . eragener RPAREN assignvalues
    (39) eragener -> . empty
    (115) empty -> .

    RPAREN          reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 218
    eragener                       shift and go to state 219

state 208

    (98) exp -> ID pushdeclaredid LBRACK expression . RBRACK pushdeclaredarray

    RBRACK          shift and go to state 220


state 209

    (78) assignment -> ID pushid LBRACK expression RBRACK . EQUALS expression SEMI updatecell

    EQUALS          shift and go to state 221


state 210

    (77) assignment -> ID pushid EQUALS expression SEMI . updatevar
    (80) updatevar -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)

    updatevar                      shift and go to state 222
    empty                          shift and go to state 223

state 211

    (49) while -> WHILE pushjump LPAREN expression RPAREN . gotof simpleblock gotowhile
    (54) gotof -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 212
    gotof                          shift and go to state 224

state 212

    (54) gotof -> empty .

    LBRACE          reduce using rule 54 (gotof -> empty .)


state 213

    (51) condition -> IF LPAREN expression RPAREN gotof . simpleblock ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression RPAREN gotof . simpleblock updatejump
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 169

    simpleblock                    shift and go to state 225

state 214

    (13) block -> LBRACE var vartoparam statements RBRACE deletelocal .

    BOOLEAN         reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    INTEGER         reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    DECIMAL         reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    STRING          reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    FRACTION        reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    VOID            reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)
    $end            reduce using rule 13 (block -> LBRACE var vartoparam statements RBRACE deletelocal .)


state 215

    (45) for -> LPAREN assignment expression SEMI expression . RPAREN simpleblock

    RPAREN          shift and go to state 226


state 216

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN . expression RPAREN gotot
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 227

state 217

    (19) simpleblock -> LBRACE statements RBRACE .

    IF              reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    ID              reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    LPAREN          reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    DO              reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    PRINT           reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    CALL            reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    INPUT           reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 19 (simpleblock -> LBRACE statements RBRACE .)


state 218

    (39) eragener -> empty .

    RPAREN          reduce using rule 39 (eragener -> empty .)
    ID              reduce using rule 39 (eragener -> empty .)
    LBRACK          reduce using rule 39 (eragener -> empty .)
    INTEGER_CONS    reduce using rule 39 (eragener -> empty .)
    STRING_CONS     reduce using rule 39 (eragener -> empty .)
    FRACTION_CONS   reduce using rule 39 (eragener -> empty .)
    DECIMAL_CONS    reduce using rule 39 (eragener -> empty .)
    TRUE            reduce using rule 39 (eragener -> empty .)
    FALSE           reduce using rule 39 (eragener -> empty .)
    EXMARK          reduce using rule 39 (eragener -> empty .)
    LPAREN          reduce using rule 39 (eragener -> empty .)
    CALL            reduce using rule 39 (eragener -> empty .)


state 219

    (37) funcall -> CALL ID pushid LPAREN eragener . startcount exparam RPAREN assignvalues
    (38) funcall -> CALL ID pushid LPAREN eragener . RPAREN assignvalues
    (40) startcount -> . empty
    (115) empty -> .

    RPAREN          shift and go to state 230
    ID              reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)

    empty                          shift and go to state 228
    startcount                     shift and go to state 229

state 220

    (98) exp -> ID pushdeclaredid LBRACK expression RBRACK . pushdeclaredarray
    (113) pushdeclaredarray -> . pushtype
    (110) pushtype -> . empty
    (115) empty -> .

    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    SEMI            reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 37
    pushdeclaredarray              shift and go to state 231
    pushtype                       shift and go to state 232

state 221

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS . expression SEMI updatecell
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exp                            shift and go to state 112
    expression                     shift and go to state 233

state 222

    (77) assignment -> ID pushid EQUALS expression SEMI updatevar .

    IF              reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    ID              reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    WHILE           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    LPAREN          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    DO              reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    PRINT           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    CALL            reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    RETURN          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    INPUT           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    RBRACE          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    LBRACK          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    INTEGER_CONS    reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    STRING_CONS     reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    FRACTION_CONS   reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    DECIMAL_CONS    reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    TRUE            reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    FALSE           reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)
    EXMARK          reduce using rule 77 (assignment -> ID pushid EQUALS expression SEMI updatevar .)


state 223

    (80) updatevar -> empty .

    IF              reduce using rule 80 (updatevar -> empty .)
    ID              reduce using rule 80 (updatevar -> empty .)
    WHILE           reduce using rule 80 (updatevar -> empty .)
    LPAREN          reduce using rule 80 (updatevar -> empty .)
    DO              reduce using rule 80 (updatevar -> empty .)
    PRINT           reduce using rule 80 (updatevar -> empty .)
    CALL            reduce using rule 80 (updatevar -> empty .)
    RETURN          reduce using rule 80 (updatevar -> empty .)
    INPUT           reduce using rule 80 (updatevar -> empty .)
    RBRACE          reduce using rule 80 (updatevar -> empty .)
    LBRACK          reduce using rule 80 (updatevar -> empty .)
    INTEGER_CONS    reduce using rule 80 (updatevar -> empty .)
    STRING_CONS     reduce using rule 80 (updatevar -> empty .)
    FRACTION_CONS   reduce using rule 80 (updatevar -> empty .)
    DECIMAL_CONS    reduce using rule 80 (updatevar -> empty .)
    TRUE            reduce using rule 80 (updatevar -> empty .)
    FALSE           reduce using rule 80 (updatevar -> empty .)
    EXMARK          reduce using rule 80 (updatevar -> empty .)


state 224

    (49) while -> WHILE pushjump LPAREN expression RPAREN gotof . simpleblock gotowhile
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 169

    simpleblock                    shift and go to state 234

state 225

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock . ELSE gotoif simpleblock updatejump
    (52) condition -> IF LPAREN expression RPAREN gotof simpleblock . updatejump
    (55) updatejump -> . empty
    (115) empty -> .

    ELSE            shift and go to state 237
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 235
    updatejump                     shift and go to state 236

state 226

    (45) for -> LPAREN assignment expression SEMI expression RPAREN . simpleblock
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 169

    simpleblock                    shift and go to state 238

state 227

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN expression . RPAREN gotot

    RPAREN          shift and go to state 239


state 228

    (40) startcount -> empty .

    ID              reduce using rule 40 (startcount -> empty .)
    LBRACK          reduce using rule 40 (startcount -> empty .)
    INTEGER_CONS    reduce using rule 40 (startcount -> empty .)
    STRING_CONS     reduce using rule 40 (startcount -> empty .)
    FRACTION_CONS   reduce using rule 40 (startcount -> empty .)
    DECIMAL_CONS    reduce using rule 40 (startcount -> empty .)
    TRUE            reduce using rule 40 (startcount -> empty .)
    FALSE           reduce using rule 40 (startcount -> empty .)
    EXMARK          reduce using rule 40 (startcount -> empty .)
    LPAREN          reduce using rule 40 (startcount -> empty .)
    CALL            reduce using rule 40 (startcount -> empty .)


state 229

    (37) funcall -> CALL ID pushid LPAREN eragener startcount . exparam RPAREN assignvalues
    (42) exparam -> . expression updatecount
    (43) exparam -> . expression updatecount COMMA exparam
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exparam                        shift and go to state 240
    expression                     shift and go to state 241
    exp                            shift and go to state 112

state 230

    (38) funcall -> CALL ID pushid LPAREN eragener RPAREN . assignvalues
    (44) assignvalues -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 242
    assignvalues                   shift and go to state 243

state 231

    (98) exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .

    OR              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    AND             reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    SAME            reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    DIF             reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    GE              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    LE              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    NE              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    GT              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    LT              reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    PLUS            reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    MINUS           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    MODULO          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    DIVIDE          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    TIMES           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    POWER           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    SEMI            reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    RBRACK          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    RPAREN          reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)
    COMMA           reduce using rule 98 (exp -> ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray .)


state 232

    (113) pushdeclaredarray -> pushtype .

    OR              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    AND             reduce using rule 113 (pushdeclaredarray -> pushtype .)
    SAME            reduce using rule 113 (pushdeclaredarray -> pushtype .)
    DIF             reduce using rule 113 (pushdeclaredarray -> pushtype .)
    GE              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    LE              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    NE              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    GT              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    LT              reduce using rule 113 (pushdeclaredarray -> pushtype .)
    PLUS            reduce using rule 113 (pushdeclaredarray -> pushtype .)
    MINUS           reduce using rule 113 (pushdeclaredarray -> pushtype .)
    MODULO          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    DIVIDE          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    TIMES           reduce using rule 113 (pushdeclaredarray -> pushtype .)
    POWER           reduce using rule 113 (pushdeclaredarray -> pushtype .)
    SEMI            reduce using rule 113 (pushdeclaredarray -> pushtype .)
    RBRACK          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    RPAREN          reduce using rule 113 (pushdeclaredarray -> pushtype .)
    COMMA           reduce using rule 113 (pushdeclaredarray -> pushtype .)


state 233

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression . SEMI updatecell

    SEMI            shift and go to state 244


state 234

    (49) while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock . gotowhile
    (50) gotowhile -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 245
    gotowhile                      shift and go to state 246

state 235

    (55) updatejump -> empty .

    IF              reduce using rule 55 (updatejump -> empty .)
    ID              reduce using rule 55 (updatejump -> empty .)
    WHILE           reduce using rule 55 (updatejump -> empty .)
    LPAREN          reduce using rule 55 (updatejump -> empty .)
    DO              reduce using rule 55 (updatejump -> empty .)
    PRINT           reduce using rule 55 (updatejump -> empty .)
    CALL            reduce using rule 55 (updatejump -> empty .)
    RETURN          reduce using rule 55 (updatejump -> empty .)
    INPUT           reduce using rule 55 (updatejump -> empty .)
    RBRACE          reduce using rule 55 (updatejump -> empty .)


state 236

    (52) condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .

    IF              reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    ID              reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    WHILE           reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    LPAREN          reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    DO              reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    PRINT           reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    CALL            reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    RETURN          reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    INPUT           reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)
    RBRACE          reduce using rule 52 (condition -> IF LPAREN expression RPAREN gotof simpleblock updatejump .)


state 237

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE . gotoif simpleblock updatejump
    (53) gotoif -> . empty
    (115) empty -> .

    LBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 247
    gotoif                         shift and go to state 248

state 238

    (45) for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .

    IF              reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    ID              reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    WHILE           reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    LPAREN          reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    DO              reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    PRINT           reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    CALL            reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    RETURN          reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    INPUT           reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)
    RBRACE          reduce using rule 45 (for -> LPAREN assignment expression SEMI expression RPAREN simpleblock .)


state 239

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN . gotot
    (48) gotot -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    gotot                          shift and go to state 250
    empty                          shift and go to state 249

state 240

    (37) funcall -> CALL ID pushid LPAREN eragener startcount exparam . RPAREN assignvalues

    RPAREN          shift and go to state 251


state 241

    (42) exparam -> expression . updatecount
    (43) exparam -> expression . updatecount COMMA exparam
    (41) updatecount -> . empty
    (115) empty -> .

    COMMA           reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 252
    updatecount                    shift and go to state 253

state 242

    (44) assignvalues -> empty .

    SEMI            reduce using rule 44 (assignvalues -> empty .)
    OR              reduce using rule 44 (assignvalues -> empty .)
    AND             reduce using rule 44 (assignvalues -> empty .)
    SAME            reduce using rule 44 (assignvalues -> empty .)
    DIF             reduce using rule 44 (assignvalues -> empty .)
    GE              reduce using rule 44 (assignvalues -> empty .)
    LE              reduce using rule 44 (assignvalues -> empty .)
    NE              reduce using rule 44 (assignvalues -> empty .)
    GT              reduce using rule 44 (assignvalues -> empty .)
    LT              reduce using rule 44 (assignvalues -> empty .)
    PLUS            reduce using rule 44 (assignvalues -> empty .)
    MINUS           reduce using rule 44 (assignvalues -> empty .)
    MODULO          reduce using rule 44 (assignvalues -> empty .)
    DIVIDE          reduce using rule 44 (assignvalues -> empty .)
    TIMES           reduce using rule 44 (assignvalues -> empty .)
    POWER           reduce using rule 44 (assignvalues -> empty .)
    RBRACK          reduce using rule 44 (assignvalues -> empty .)
    RPAREN          reduce using rule 44 (assignvalues -> empty .)
    COMMA           reduce using rule 44 (assignvalues -> empty .)


state 243

    (38) funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .

    OR              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    AND             reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    SAME            reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    DIF             reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    GE              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    LE              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    NE              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    GT              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    LT              reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    PLUS            reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    MINUS           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    MODULO          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    DIVIDE          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    TIMES           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    POWER           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    SEMI            reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    RBRACK          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    RPAREN          reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)
    COMMA           reduce using rule 38 (funcall -> CALL ID pushid LPAREN eragener RPAREN assignvalues .)


state 244

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI . updatecell
    (79) updatecell -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)
    LBRACK          reduce using rule 115 (empty -> .)
    INTEGER_CONS    reduce using rule 115 (empty -> .)
    STRING_CONS     reduce using rule 115 (empty -> .)
    FRACTION_CONS   reduce using rule 115 (empty -> .)
    DECIMAL_CONS    reduce using rule 115 (empty -> .)
    TRUE            reduce using rule 115 (empty -> .)
    FALSE           reduce using rule 115 (empty -> .)
    EXMARK          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 254
    updatecell                     shift and go to state 255

state 245

    (50) gotowhile -> empty .

    IF              reduce using rule 50 (gotowhile -> empty .)
    ID              reduce using rule 50 (gotowhile -> empty .)
    WHILE           reduce using rule 50 (gotowhile -> empty .)
    LPAREN          reduce using rule 50 (gotowhile -> empty .)
    DO              reduce using rule 50 (gotowhile -> empty .)
    PRINT           reduce using rule 50 (gotowhile -> empty .)
    CALL            reduce using rule 50 (gotowhile -> empty .)
    RETURN          reduce using rule 50 (gotowhile -> empty .)
    INPUT           reduce using rule 50 (gotowhile -> empty .)
    RBRACE          reduce using rule 50 (gotowhile -> empty .)


state 246

    (49) while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .

    IF              reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    ID              reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    WHILE           reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    LPAREN          reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    DO              reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    PRINT           reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    CALL            reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    RETURN          reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    INPUT           reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)
    RBRACE          reduce using rule 49 (while -> WHILE pushjump LPAREN expression RPAREN gotof simpleblock gotowhile .)


state 247

    (53) gotoif -> empty .

    LBRACE          reduce using rule 53 (gotoif -> empty .)


state 248

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif . simpleblock updatejump
    (19) simpleblock -> . LBRACE statements RBRACE
    (20) simpleblock -> . LBRACE RBRACE

    LBRACE          shift and go to state 169

    simpleblock                    shift and go to state 256

state 249

    (48) gotot -> empty .

    IF              reduce using rule 48 (gotot -> empty .)
    ID              reduce using rule 48 (gotot -> empty .)
    WHILE           reduce using rule 48 (gotot -> empty .)
    LPAREN          reduce using rule 48 (gotot -> empty .)
    DO              reduce using rule 48 (gotot -> empty .)
    PRINT           reduce using rule 48 (gotot -> empty .)
    CALL            reduce using rule 48 (gotot -> empty .)
    RETURN          reduce using rule 48 (gotot -> empty .)
    INPUT           reduce using rule 48 (gotot -> empty .)
    RBRACE          reduce using rule 48 (gotot -> empty .)


state 250

    (46) dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .

    IF              reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    ID              reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    WHILE           reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    LPAREN          reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    DO              reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    PRINT           reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    CALL            reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    RETURN          reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    INPUT           reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)
    RBRACE          reduce using rule 46 (dowhile -> DO pushjump simpleblock WHILE LPAREN expression RPAREN gotot .)


state 251

    (37) funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN . assignvalues
    (44) assignvalues -> . empty
    (115) empty -> .

    SEMI            reduce using rule 115 (empty -> .)
    OR              reduce using rule 115 (empty -> .)
    AND             reduce using rule 115 (empty -> .)
    SAME            reduce using rule 115 (empty -> .)
    DIF             reduce using rule 115 (empty -> .)
    GE              reduce using rule 115 (empty -> .)
    LE              reduce using rule 115 (empty -> .)
    NE              reduce using rule 115 (empty -> .)
    GT              reduce using rule 115 (empty -> .)
    LT              reduce using rule 115 (empty -> .)
    PLUS            reduce using rule 115 (empty -> .)
    MINUS           reduce using rule 115 (empty -> .)
    MODULO          reduce using rule 115 (empty -> .)
    DIVIDE          reduce using rule 115 (empty -> .)
    TIMES           reduce using rule 115 (empty -> .)
    POWER           reduce using rule 115 (empty -> .)
    RBRACK          reduce using rule 115 (empty -> .)
    RPAREN          reduce using rule 115 (empty -> .)
    COMMA           reduce using rule 115 (empty -> .)

    empty                          shift and go to state 242
    assignvalues                   shift and go to state 257

state 252

    (41) updatecount -> empty .

    COMMA           reduce using rule 41 (updatecount -> empty .)
    RPAREN          reduce using rule 41 (updatecount -> empty .)


state 253

    (42) exparam -> expression updatecount .
    (43) exparam -> expression updatecount . COMMA exparam

    RPAREN          reduce using rule 42 (exparam -> expression updatecount .)
    COMMA           shift and go to state 258


state 254

    (79) updatecell -> empty .

    IF              reduce using rule 79 (updatecell -> empty .)
    ID              reduce using rule 79 (updatecell -> empty .)
    WHILE           reduce using rule 79 (updatecell -> empty .)
    LPAREN          reduce using rule 79 (updatecell -> empty .)
    DO              reduce using rule 79 (updatecell -> empty .)
    PRINT           reduce using rule 79 (updatecell -> empty .)
    CALL            reduce using rule 79 (updatecell -> empty .)
    RETURN          reduce using rule 79 (updatecell -> empty .)
    INPUT           reduce using rule 79 (updatecell -> empty .)
    RBRACE          reduce using rule 79 (updatecell -> empty .)
    LBRACK          reduce using rule 79 (updatecell -> empty .)
    INTEGER_CONS    reduce using rule 79 (updatecell -> empty .)
    STRING_CONS     reduce using rule 79 (updatecell -> empty .)
    FRACTION_CONS   reduce using rule 79 (updatecell -> empty .)
    DECIMAL_CONS    reduce using rule 79 (updatecell -> empty .)
    TRUE            reduce using rule 79 (updatecell -> empty .)
    FALSE           reduce using rule 79 (updatecell -> empty .)
    EXMARK          reduce using rule 79 (updatecell -> empty .)


state 255

    (78) assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .

    IF              reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    ID              reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    WHILE           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    LPAREN          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    DO              reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    PRINT           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    CALL            reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    RETURN          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    INPUT           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    RBRACE          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    LBRACK          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    INTEGER_CONS    reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    STRING_CONS     reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    FRACTION_CONS   reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    DECIMAL_CONS    reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    TRUE            reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    FALSE           reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)
    EXMARK          reduce using rule 78 (assignment -> ID pushid LBRACK expression RBRACK EQUALS expression SEMI updatecell .)


state 256

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock . updatejump
    (55) updatejump -> . empty
    (115) empty -> .

    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    LPAREN          reduce using rule 115 (empty -> .)
    DO              reduce using rule 115 (empty -> .)
    PRINT           reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    RETURN          reduce using rule 115 (empty -> .)
    INPUT           reduce using rule 115 (empty -> .)
    RBRACE          reduce using rule 115 (empty -> .)

    empty                          shift and go to state 235
    updatejump                     shift and go to state 259

state 257

    (37) funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .

    OR              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    AND             reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    SAME            reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    DIF             reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    GE              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    LE              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    NE              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    GT              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    LT              reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    PLUS            reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    MINUS           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    MODULO          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    DIVIDE          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    TIMES           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    POWER           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    SEMI            reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    RBRACK          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    RPAREN          reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)
    COMMA           reduce using rule 37 (funcall -> CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues .)


state 258

    (43) exparam -> expression updatecount COMMA . exparam
    (42) exparam -> . expression updatecount
    (43) exparam -> . expression updatecount COMMA exparam
    (81) expression -> . exp
    (82) exp -> . exp OR exp
    (83) exp -> . exp AND exp
    (84) exp -> . exp SAME exp
    (85) exp -> . exp DIF exp
    (86) exp -> . exp GE exp
    (87) exp -> . exp LE exp
    (88) exp -> . exp NE exp
    (89) exp -> . exp GT exp
    (90) exp -> . exp LT exp
    (91) exp -> . exp PLUS exp
    (92) exp -> . exp MINUS exp
    (93) exp -> . exp MODULO exp
    (94) exp -> . exp DIVIDE exp
    (95) exp -> . exp TIMES exp
    (96) exp -> . exp POWER exp
    (97) exp -> . ID pushdeclaredid
    (98) exp -> . ID pushdeclaredid LBRACK expression RBRACK pushdeclaredarray
    (99) exp -> . LBRACK exp RBRACK
    (100) exp -> . INTEGER_CONS settypeint pushcons
    (101) exp -> . STRING_CONS settypestring pushcons
    (102) exp -> . FRACTION_CONS settypefrac pushcons
    (103) exp -> . DECIMAL_CONS settypedec pushcons
    (104) exp -> . TRUE settypebool pushcons
    (105) exp -> . FALSE settypebool pushcons
    (106) exp -> . EXMARK exp
    (107) exp -> . LPAREN exp RPAREN
    (108) exp -> . funcall pushrtn
    (37) funcall -> . CALL ID pushid LPAREN eragener startcount exparam RPAREN assignvalues
    (38) funcall -> . CALL ID pushid LPAREN eragener RPAREN assignvalues

    ID              shift and go to state 100
    LBRACK          shift and go to state 103
    INTEGER_CONS    shift and go to state 108
    STRING_CONS     shift and go to state 99
    FRACTION_CONS   shift and go to state 107
    DECIMAL_CONS    shift and go to state 105
    TRUE            shift and go to state 111
    FALSE           shift and go to state 102
    EXMARK          shift and go to state 109
    LPAREN          shift and go to state 106
    CALL            shift and go to state 91

    funcall                        shift and go to state 101
    exparam                        shift and go to state 260
    expression                     shift and go to state 241
    exp                            shift and go to state 112

state 259

    (51) condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .

    IF              reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    ID              reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    WHILE           reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    LPAREN          reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    DO              reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    PRINT           reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    CALL            reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    RETURN          reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    INPUT           reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)
    RBRACE          reduce using rule 51 (condition -> IF LPAREN expression RPAREN gotof simpleblock ELSE gotoif simpleblock updatejump .)


state 260

    (43) exparam -> expression updatecount COMMA exparam .

    RPAREN          reduce using rule 43 (exparam -> expression updatecount COMMA exparam .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OR in state 187 resolved as shift
WARNING: shift/reduce conflict for AND in state 187 resolved as shift
WARNING: shift/reduce conflict for SAME in state 187 resolved as shift
WARNING: shift/reduce conflict for DIF in state 187 resolved as shift
WARNING: shift/reduce conflict for GE in state 187 resolved as shift
WARNING: shift/reduce conflict for LE in state 187 resolved as shift
WARNING: shift/reduce conflict for NE in state 187 resolved as shift
WARNING: shift/reduce conflict for GT in state 187 resolved as shift
WARNING: shift/reduce conflict for LT in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 187 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 187 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 187 resolved as shift
WARNING: shift/reduce conflict for POWER in state 187 resolved as shift
